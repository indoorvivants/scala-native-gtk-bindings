package gio

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GAction = CStruct0
object GAction:
  given _tag: Tag[GAction] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gactionmap.h
*/
opaque type GActionEntry = CArray[CChar, Nat.Digit2[Nat._6, Nat._4]]
object GActionEntry:
  given _tag: Tag[GActionEntry] = Tag.CArray[CChar, Nat.Digit2[Nat._6, Nat._4]](Tag.Byte, Tag.Digit2[Nat._6, Nat._4](Tag.Nat6, Tag.Nat4))
  def apply()(using Zone): Ptr[GActionEntry] = scala.scalanative.unsafe.alloc[GActionEntry](1)
  def apply(name : Ptr[_root_.glib.gchar], activate : CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], parameter_type : Ptr[_root_.glib.gchar], state : Ptr[_root_.glib.gchar], change_state : CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], padding : CArray[_root_.glib.gsize, Nat._3])(using Zone): Ptr[GActionEntry] = 
    val ____ptr = apply()
    (!____ptr).name = name
    (!____ptr).activate = activate
    (!____ptr).parameter_type = parameter_type
    (!____ptr).state = state
    (!____ptr).change_state = change_state
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GActionEntry)
    def name: Ptr[_root_.glib.gchar] = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def activate: CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]]]
    def activate_=(value: CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]]] = value
    def parameter_type: Ptr[_root_.glib.gchar] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def parameter_type_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def state: Ptr[_root_.glib.gchar] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def state_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def change_state: CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]]]
    def change_state_=(value: CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]]] = value
    def padding: CArray[_root_.glib.gsize, Nat._3] = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gsize, Nat._3]]]
    def padding_=(value: CArray[_root_.glib.gsize, Nat._3]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gsize, Nat._3]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(1) = align(res(0) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(4) = align(res(3) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]].toInt, alignmentof[_root_.glib.gsize].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GActionGroup = CStruct0
object GActionGroup:
  given _tag: Tag[GActionGroup] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gactiongroup.h
*/
opaque type GActionGroupInterface = CArray[CChar, Nat.Digit3[Nat._1, Nat._2, Nat._8]]
object GActionGroupInterface:
  given _tag: Tag[GActionGroupInterface] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._2, Nat._8]](Tag.Byte, Tag.Digit3[Nat._1, Nat._2, Nat._8](Tag.Nat1, Tag.Nat2, Tag.Nat8))
  def apply()(using Zone): Ptr[GActionGroupInterface] = scala.scalanative.unsafe.alloc[GActionGroupInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, has_action : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], list_actions : CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]], get_action_enabled : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], get_action_parameter_type : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], get_action_state_type : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], get_action_state_hint : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], get_action_state : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], change_action_state : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], activate_action : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], action_added : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], action_removed : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], action_enabled_changed : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit], action_state_changed : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], query_action : CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean])(using Zone): Ptr[GActionGroupInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).has_action = has_action
    (!____ptr).list_actions = list_actions
    (!____ptr).get_action_enabled = get_action_enabled
    (!____ptr).get_action_parameter_type = get_action_parameter_type
    (!____ptr).get_action_state_type = get_action_state_type
    (!____ptr).get_action_state_hint = get_action_state_hint
    (!____ptr).get_action_state = get_action_state
    (!____ptr).change_action_state = change_action_state
    (!____ptr).activate_action = activate_action
    (!____ptr).action_added = action_added
    (!____ptr).action_removed = action_removed
    (!____ptr).action_enabled_changed = action_enabled_changed
    (!____ptr).action_state_changed = action_state_changed
    (!____ptr).query_action = query_action
    ____ptr
  extension (struct: GActionGroupInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def has_action: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]]]
    def has_action_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]]] = value
    def list_actions: CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]]]]
    def list_actions_=(value: CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def get_action_enabled: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]]]
    def get_action_enabled_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]]] = value
    def get_action_parameter_type: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]]]
    def get_action_parameter_type_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]]] = value
    def get_action_state_type: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]]]
    def get_action_state_type_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]]] = value
    def get_action_state_hint: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]]]
    def get_action_state_hint_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]]] = value
    def get_action_state: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]]]
    def get_action_state_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]]] = value
    def change_action_state: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]]
    def change_action_state_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]] = value
    def activate_action: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]]
    def activate_action_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]] = value
    def action_added: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]]]
    def action_added_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]]] = value
    def action_removed: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]]]
    def action_removed_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]]] = value
    def action_enabled_changed: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit]]]
    def action_enabled_changed_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit]]] = value
    def action_state_changed: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]]
    def action_state_changed_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]] = value
    def query_action: CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]]
    def query_action_=(value: CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](15)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]].toInt, alignmentof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gaction.h
*/
opaque type GActionInterface = CArray[CChar, Nat.Digit2[Nat._8, Nat._0]]
object GActionInterface:
  given _tag: Tag[GActionInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._8, Nat._0]](Tag.Byte, Tag.Digit2[Nat._8, Nat._0](Tag.Nat8, Tag.Nat0))
  def apply()(using Zone): Ptr[GActionInterface] = scala.scalanative.unsafe.alloc[GActionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, get_name : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]], get_parameter_type : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], get_state_type : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], get_state_hint : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], get_enabled : CFuncPtr1[Ptr[GAction], _root_.glib.gboolean], get_state : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], change_state : CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit], activate : CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit])(using Zone): Ptr[GActionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).get_name = get_name
    (!____ptr).get_parameter_type = get_parameter_type
    (!____ptr).get_state_type = get_state_type
    (!____ptr).get_state_hint = get_state_hint
    (!____ptr).get_enabled = get_enabled
    (!____ptr).get_state = get_state
    (!____ptr).change_state = change_state
    (!____ptr).activate = activate
    ____ptr
  extension (struct: GActionInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def get_name: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]]]]
    def get_name_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]]]] = value
    def get_parameter_type: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]]]
    def get_parameter_type_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]]] = value
    def get_state_type: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]]]
    def get_state_type_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]]] = value
    def get_state_hint: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]]]
    def get_state_hint_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]]] = value
    def get_enabled: CFuncPtr1[Ptr[GAction], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], _root_.glib.gboolean]]]
    def get_enabled_=(value: CFuncPtr1[Ptr[GAction], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], _root_.glib.gboolean]]] = value
    def get_state: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]]]
    def get_state_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]]] = value
    def change_state: CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]]]
    def change_state_=(value: CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]]] = value
    def activate: CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]]]
    def activate_=(value: CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](9)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]].toInt, alignmentof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]].toInt, alignmentof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]].toInt, alignmentof[CFuncPtr1[Ptr[GAction], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GAction], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]].toInt, alignmentof[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GActionMap = CStruct0
object GActionMap:
  given _tag: Tag[GActionMap] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gactionmap.h
*/
opaque type GActionMapInterface = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GActionMapInterface:
  given _tag: Tag[GActionMapInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GActionMapInterface] = scala.scalanative.unsafe.alloc[GActionMapInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, lookup_action : CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]], add_action : CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit], remove_action : CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit])(using Zone): Ptr[GActionMapInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).lookup_action = lookup_action
    (!____ptr).add_action = add_action
    (!____ptr).remove_action = remove_action
    ____ptr
  extension (struct: GActionMapInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def lookup_action: CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]]]]
    def lookup_action_=(value: CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]]]] = value
    def add_action: CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit]]]
    def add_action_=(value: CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit]]] = value
    def remove_action: CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]]]
    def remove_action_=(value: CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]]].toInt, alignmentof[CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GAppInfo = CStruct0
object GAppInfo:
  given _tag: Tag[GAppInfo] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type GAppInfoIface = CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]]
object GAppInfoIface:
  given _tag: Tag[GAppInfoIface] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._1, Nat._6](Tag.Nat2, Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GAppInfoIface] = scala.scalanative.unsafe.alloc[GAppInfoIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, dup : CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]], equal : CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean], get_id : CFuncPtr1[Ptr[GAppInfo], CString], get_name : CFuncPtr1[Ptr[GAppInfo], CString], get_description : CFuncPtr1[Ptr[GAppInfo], CString], get_executable : CFuncPtr1[Ptr[GAppInfo], CString], get_icon : CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]], launch : CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], supports_uris : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], supports_files : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], launch_uris : CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], should_show : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], set_as_default_for_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_as_default_for_extension : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], add_supports_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_remove_supports_type : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], remove_supports_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_delete : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], do_delete : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], get_commandline : CFuncPtr1[Ptr[GAppInfo], CString], get_display_name : CFuncPtr1[Ptr[GAppInfo], CString], set_as_last_used_for_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_supported_types : CFuncPtr1[Ptr[GAppInfo], Ptr[CString]], launch_uris_async : CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], launch_uris_finish : CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GAppInfoIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).dup = dup
    (!____ptr).equal = equal
    (!____ptr).get_id = get_id
    (!____ptr).get_name = get_name
    (!____ptr).get_description = get_description
    (!____ptr).get_executable = get_executable
    (!____ptr).get_icon = get_icon
    (!____ptr).launch = launch
    (!____ptr).supports_uris = supports_uris
    (!____ptr).supports_files = supports_files
    (!____ptr).launch_uris = launch_uris
    (!____ptr).should_show = should_show
    (!____ptr).set_as_default_for_type = set_as_default_for_type
    (!____ptr).set_as_default_for_extension = set_as_default_for_extension
    (!____ptr).add_supports_type = add_supports_type
    (!____ptr).can_remove_supports_type = can_remove_supports_type
    (!____ptr).remove_supports_type = remove_supports_type
    (!____ptr).can_delete = can_delete
    (!____ptr).do_delete = do_delete
    (!____ptr).get_commandline = get_commandline
    (!____ptr).get_display_name = get_display_name
    (!____ptr).set_as_last_used_for_type = set_as_last_used_for_type
    (!____ptr).get_supported_types = get_supported_types
    (!____ptr).launch_uris_async = launch_uris_async
    (!____ptr).launch_uris_finish = launch_uris_finish
    ____ptr
  extension (struct: GAppInfoIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def dup: CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]]]
    def dup_=(value: CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]]] = value
    def equal: CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]]]
    def equal_=(value: CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def get_id: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_id_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_name: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_description: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_description_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_executable: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_executable_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]]] = value
    def launch: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def launch_=(value: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def supports_uris: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def supports_uris_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def supports_files: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def supports_files_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def launch_uris: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def launch_uris_=(value: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def should_show: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def should_show_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def set_as_default_for_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_as_default_for_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_as_default_for_extension: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_as_default_for_extension_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def add_supports_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def add_supports_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_remove_supports_type: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def can_remove_supports_type_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def remove_supports_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def remove_supports_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_delete: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def can_delete_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def do_delete: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def do_delete_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def get_commandline: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_commandline_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_display_name: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_display_name_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def set_as_last_used_for_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_as_last_used_for_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_supported_types: CFuncPtr1[Ptr[GAppInfo], Ptr[CString]] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]]]
    def get_supported_types_=(value: CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]]] = value
    def launch_uris_async: CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def launch_uris_async_=(value: CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def launch_uris_finish: CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def launch_uris_finish_=(value: CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](26)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]].toInt, alignmentof[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]].toInt, alignmentof[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type GAppInfoMonitor = CStruct0
object GAppInfoMonitor:
  given _tag: Tag[GAppInfoMonitor] = Tag.materializeCStruct0Tag

/**
 * GAppLaunchContext:

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type GAppLaunchContext = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GAppLaunchContext:
  given _tag: Tag[GAppLaunchContext] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GAppLaunchContext] = scala.scalanative.unsafe.alloc[GAppLaunchContext](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GAppLaunchContextPrivate])(using Zone): Ptr[GAppLaunchContext] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GAppLaunchContext)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GAppLaunchContextPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GAppLaunchContextPrivate]]]
    def priv_=(value: Ptr[GAppLaunchContextPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GAppLaunchContextPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GAppLaunchContextPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type GAppLaunchContextClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]]
object GAppLaunchContextClass:
  given _tag: Tag[GAppLaunchContextClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]](Tag.Byte, Tag.Digit3[Nat._2, Nat._0, Nat._0](Tag.Nat2, Tag.Nat0, Tag.Nat0))
  def apply()(using Zone): Ptr[GAppLaunchContextClass] = scala.scalanative.unsafe.alloc[GAppLaunchContextClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_display : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString], get_startup_notify_id : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString], launch_failed : CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit], launched : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], launch_started : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[GAppLaunchContextClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_display = get_display
    (!____ptr).get_startup_notify_id = get_startup_notify_id
    (!____ptr).launch_failed = launch_failed
    (!____ptr).launched = launched
    (!____ptr).launch_started = launch_started
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: GAppLaunchContextClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_display: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]]]
    def get_display_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]]] = value
    def get_startup_notify_id: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]]]
    def get_startup_notify_id_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]]] = value
    def launch_failed: CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit]]]
    def launch_failed_=(value: CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit]]] = value
    def launched: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]]]
    def launched_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]]] = value
    def launch_started: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]]]
    def launch_started_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](9)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]].toInt, alignmentof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]].toInt, alignmentof[CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type GAppLaunchContextPrivate = CStruct0
object GAppLaunchContextPrivate:
  given _tag: Tag[GAppLaunchContextPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplication.h
*/
opaque type GApplication = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GApplication:
  given _tag: Tag[GApplication] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GApplication] = scala.scalanative.unsafe.alloc[GApplication](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GApplicationPrivate])(using Zone): Ptr[GApplication] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GApplication)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GApplicationPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GApplicationPrivate]]]
    def priv_=(value: Ptr[GApplicationPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GApplicationPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GApplicationPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplication.h
*/
opaque type GApplicationClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._1, Nat._2]]
object GApplicationClass:
  given _tag: Tag[GApplicationClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._1, Nat._2]](Tag.Byte, Tag.Digit3[Nat._3, Nat._1, Nat._2](Tag.Nat3, Tag.Nat1, Tag.Nat2))
  def apply()(using Zone): Ptr[GApplicationClass] = scala.scalanative.unsafe.alloc[GApplicationClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, startup : CFuncPtr1[Ptr[GApplication], Unit], activate : CFuncPtr1[Ptr[GApplication], Unit], open : CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit], command_line : CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt], local_command_line : CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean], before_emit : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], after_emit : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], add_platform_data : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit], quit_mainloop : CFuncPtr1[Ptr[GApplication], Unit], run_mainloop : CFuncPtr1[Ptr[GApplication], Unit], shutdown : CFuncPtr1[Ptr[GApplication], Unit], dbus_register : CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], dbus_unregister : CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit], handle_local_options : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint], name_lost : CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat._7])(using Zone): Ptr[GApplicationClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).startup = startup
    (!____ptr).activate = activate
    (!____ptr).open = open
    (!____ptr).command_line = command_line
    (!____ptr).local_command_line = local_command_line
    (!____ptr).before_emit = before_emit
    (!____ptr).after_emit = after_emit
    (!____ptr).add_platform_data = add_platform_data
    (!____ptr).quit_mainloop = quit_mainloop
    (!____ptr).run_mainloop = run_mainloop
    (!____ptr).shutdown = shutdown
    (!____ptr).dbus_register = dbus_register
    (!____ptr).dbus_unregister = dbus_unregister
    (!____ptr).handle_local_options = handle_local_options
    (!____ptr).name_lost = name_lost
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GApplicationClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def startup: CFuncPtr1[Ptr[GApplication], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]]
    def startup_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]] = value
    def activate: CFuncPtr1[Ptr[GApplication], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]]
    def activate_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]] = value
    def open: CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit]]]
    def open_=(value: CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit]]] = value
    def command_line: CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt]]]
    def command_line_=(value: CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt]]] = value
    def local_command_line: CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean]]]
    def local_command_line_=(value: CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean]]] = value
    def before_emit: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]]]
    def before_emit_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]]] = value
    def after_emit: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]]]
    def after_emit_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]]] = value
    def add_platform_data: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit]]]
    def add_platform_data_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit]]] = value
    def quit_mainloop: CFuncPtr1[Ptr[GApplication], Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]]
    def quit_mainloop_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]] = value
    def run_mainloop: CFuncPtr1[Ptr[GApplication], Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]]
    def run_mainloop_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]] = value
    def shutdown: CFuncPtr1[Ptr[GApplication], Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]]
    def shutdown_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], Unit]]] = value
    def dbus_register: CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def dbus_register_=(value: CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def dbus_unregister: CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit]]]
    def dbus_unregister_=(value: CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit]]] = value
    def handle_local_options: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint]]]
    def handle_local_options_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint]]] = value
    def name_lost: CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean]]]
    def name_lost_=(value: CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._7] = !struct.at(offsets(16)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._7]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._7]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._7]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](17)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GApplication], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GApplication], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GApplication], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GApplication], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt]].toInt, alignmentof[CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GApplication], Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GApplication], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GApplication], Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GApplication], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GApplication], Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr1[Ptr[GApplication], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint]].toInt, alignmentof[CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplicationcommandline.h
*/
opaque type GApplicationCommandLine = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GApplicationCommandLine:
  given _tag: Tag[GApplicationCommandLine] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GApplicationCommandLine] = scala.scalanative.unsafe.alloc[GApplicationCommandLine](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GApplicationCommandLinePrivate])(using Zone): Ptr[GApplicationCommandLine] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GApplicationCommandLine)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GApplicationCommandLinePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GApplicationCommandLinePrivate]]]
    def priv_=(value: Ptr[GApplicationCommandLinePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GApplicationCommandLinePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GApplicationCommandLinePrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplicationcommandline.h
*/
opaque type GApplicationCommandLineClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._8]]
object GApplicationCommandLineClass:
  given _tag: Tag[GApplicationCommandLineClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._8]](Tag.Byte, Tag.Digit3[Nat._2, Nat._4, Nat._8](Tag.Nat2, Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GApplicationCommandLineClass] = scala.scalanative.unsafe.alloc[GApplicationCommandLineClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, print_literal : CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], printerr_literal : CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], get_stdin : CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]], done : CFuncPtr1[Ptr[GApplicationCommandLine], Unit], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]])(using Zone): Ptr[GApplicationCommandLineClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).print_literal = print_literal
    (!____ptr).printerr_literal = printerr_literal
    (!____ptr).get_stdin = get_stdin
    (!____ptr).done = done
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GApplicationCommandLineClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def print_literal: CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]]]
    def print_literal_=(value: CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]]] = value
    def printerr_literal: CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]]]
    def printerr_literal_=(value: CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]]] = value
    def get_stdin: CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]]]]
    def get_stdin_=(value: CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]]]] = value
    def done: CFuncPtr1[Ptr[GApplicationCommandLine], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplicationCommandLine], Unit]]]
    def done_=(value: CFuncPtr1[Ptr[GApplicationCommandLine], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GApplicationCommandLine], Unit]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]]].toInt, alignmentof[CFuncPtr1[Ptr[GApplicationCommandLine], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GApplicationCommandLine], Unit]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplicationcommandline.h
*/
opaque type GApplicationCommandLinePrivate = CStruct0
object GApplicationCommandLinePrivate:
  given _tag: Tag[GApplicationCommandLinePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplication.h
*/
opaque type GApplicationPrivate = CStruct0
object GApplicationPrivate:
  given _tag: Tag[GApplicationPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GAsyncInitable = CStruct0
object GAsyncInitable:
  given _tag: Tag[GAsyncInitable] = Tag.materializeCStruct0Tag

/**
 * GAsyncInitableIface: _iface: The parent interface. _async: Starts initialization of the object. _finish: Finishes initialization of the object.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gasyncinitable.h
*/
opaque type GAsyncInitableIface = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GAsyncInitableIface:
  given _tag: Tag[GAsyncInitableIface] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GAsyncInitableIface] = scala.scalanative.unsafe.alloc[GAsyncInitableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, init_async : CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], init_finish : CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GAsyncInitableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).init_async = init_async
    (!____ptr).init_finish = init_finish
    ____ptr
  extension (struct: GAsyncInitableIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def init_async: CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def init_async_=(value: CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def init_finish: CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def init_finish_=(value: CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GAsyncResult = CStruct0
object GAsyncResult:
  given _tag: Tag[GAsyncResult] = Tag.materializeCStruct0Tag

/**
 * GAsyncResultIface: _iface: The parent interface. _user_data: Gets the user data passed to the callback. _source_object: Gets the source object that issued the asynchronous operation.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gasyncresult.h
*/
opaque type GAsyncResultIface = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GAsyncResultIface:
  given _tag: Tag[GAsyncResultIface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GAsyncResultIface] = scala.scalanative.unsafe.alloc[GAsyncResultIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, get_user_data : CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer], get_source_object : CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]], is_tagged : CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean])(using Zone): Ptr[GAsyncResultIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).get_user_data = get_user_data
    (!____ptr).get_source_object = get_source_object
    (!____ptr).is_tagged = is_tagged
    ____ptr
  extension (struct: GAsyncResultIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def get_user_data: CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer]]]
    def get_user_data_=(value: CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer]]] = value
    def get_source_object: CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]]]]
    def get_source_object_=(value: CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]]]] = value
    def is_tagged: CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]]]
    def is_tagged_=(value: CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer]].toInt, alignmentof[CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]]].toInt, alignmentof[CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedinputstream.h
*/
opaque type GBufferedInputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GBufferedInputStream:
  given _tag: Tag[GBufferedInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GBufferedInputStream] = scala.scalanative.unsafe.alloc[GBufferedInputStream](1)
  def apply(parent_instance : GFilterInputStream, priv : Ptr[GBufferedInputStreamPrivate])(using Zone): Ptr[GBufferedInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GBufferedInputStream)
    def parent_instance: GFilterInputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStream]]
    def parent_instance_=(value: GFilterInputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStream]] = value
    def priv: Ptr[GBufferedInputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GBufferedInputStreamPrivate]]]
    def priv_=(value: Ptr[GBufferedInputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GBufferedInputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterInputStream].toInt)
    res(1) = align(res(0) + sizeof[GFilterInputStream].toInt, alignmentof[Ptr[GBufferedInputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedinputstream.h
*/
opaque type GBufferedInputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]]
object GBufferedInputStreamClass:
  given _tag: Tag[GBufferedInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._3, Nat._6](Tag.Nat3, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GBufferedInputStreamClass] = scala.scalanative.unsafe.alloc[GBufferedInputStreamClass](1)
  def apply(parent_class : GFilterInputStreamClass, fill : CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], fill_async : CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], fill_finish : CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GBufferedInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).fill = fill
    (!____ptr).fill_async = fill_async
    (!____ptr).fill_finish = fill_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GBufferedInputStreamClass)
    def parent_class: GFilterInputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStreamClass]]
    def parent_class_=(value: GFilterInputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStreamClass]] = value
    def fill: CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def fill_=(value: CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def fill_async: CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def fill_async_=(value: CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def fill_finish: CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def fill_finish_=(value: CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](9)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterInputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GFilterInputStreamClass].toInt, alignmentof[CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedinputstream.h
*/
opaque type GBufferedInputStreamPrivate = CStruct0
object GBufferedInputStreamPrivate:
  given _tag: Tag[GBufferedInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedoutputstream.h
*/
opaque type GBufferedOutputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GBufferedOutputStream:
  given _tag: Tag[GBufferedOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GBufferedOutputStream] = scala.scalanative.unsafe.alloc[GBufferedOutputStream](1)
  def apply(parent_instance : GFilterOutputStream, priv : Ptr[GBufferedOutputStreamPrivate])(using Zone): Ptr[GBufferedOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GBufferedOutputStream)
    def parent_instance: GFilterOutputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStream]]
    def parent_instance_=(value: GFilterOutputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStream]] = value
    def priv: Ptr[GBufferedOutputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GBufferedOutputStreamPrivate]]]
    def priv_=(value: Ptr[GBufferedOutputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GBufferedOutputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterOutputStream].toInt)
    res(1) = align(res(0) + sizeof[GFilterOutputStream].toInt, alignmentof[Ptr[GBufferedOutputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedoutputstream.h
*/
opaque type GBufferedOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]]
object GBufferedOutputStreamClass:
  given _tag: Tag[GBufferedOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._3, Nat._6](Tag.Nat3, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GBufferedOutputStreamClass] = scala.scalanative.unsafe.alloc[GBufferedOutputStreamClass](1)
  def apply(parent_class : GFilterOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit])(using Zone): Ptr[GBufferedOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    ____ptr
  extension (struct: GBufferedOutputStreamClass)
    def parent_class: GFilterOutputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStreamClass]]
    def parent_class_=(value: GFilterOutputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterOutputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GFilterOutputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedoutputstream.h
*/
opaque type GBufferedOutputStreamPrivate = CStruct0
object GBufferedOutputStreamPrivate:
  given _tag: Tag[GBufferedOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GBytesIcon = CStruct0
object GBytesIcon:
  given _tag: Tag[GBytesIcon] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcancellable.h
*/
opaque type GCancellable = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GCancellable:
  given _tag: Tag[GCancellable] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GCancellable] = scala.scalanative.unsafe.alloc[GCancellable](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GCancellablePrivate])(using Zone): Ptr[GCancellable] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GCancellable)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GCancellablePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GCancellablePrivate]]]
    def priv_=(value: Ptr[GCancellablePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GCancellablePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GCancellablePrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcancellable.h
*/
opaque type GCancellableClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._8, Nat._4]]
object GCancellableClass:
  given _tag: Tag[GCancellableClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._8, Nat._4]](Tag.Byte, Tag.Digit3[Nat._1, Nat._8, Nat._4](Tag.Nat1, Tag.Nat8, Tag.Nat4))
  def apply()(using Zone): Ptr[GCancellableClass] = scala.scalanative.unsafe.alloc[GCancellableClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, cancelled : CFuncPtr1[Ptr[GCancellable], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GCancellableClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).cancelled = cancelled
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GCancellableClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def cancelled: CFuncPtr1[Ptr[GCancellable], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GCancellable], Unit]]]
    def cancelled_=(value: CFuncPtr1[Ptr[GCancellable], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GCancellable], Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](7)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GCancellable], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GCancellable], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcancellable.h
*/
opaque type GCancellablePrivate = CStruct0
object GCancellablePrivate:
  given _tag: Tag[GCancellablePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GCharsetConverter = CStruct0
object GCharsetConverter:
  given _tag: Tag[GCharsetConverter] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcharsetconverter.h
*/
opaque type GCharsetConverterClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GCharsetConverterClass:
  given _tag: Tag[GCharsetConverterClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GCharsetConverterClass] = scala.scalanative.unsafe.alloc[GCharsetConverterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GCharsetConverterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GCharsetConverterClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GConverter = CStruct0
object GConverter:
  given _tag: Tag[GConverter] = Tag.materializeCStruct0Tag

/**
 * GConverterIface: _iface: The parent interface. : Converts data. : Reverts the internal state of the converter to its initial state.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverter.h
*/
opaque type GConverterIface = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GConverterIface:
  given _tag: Tag[GConverterIface] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GConverterIface] = scala.scalanative.unsafe.alloc[GConverterIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, convert : CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult], reset : CFuncPtr1[Ptr[GConverter], Unit])(using Zone): Ptr[GConverterIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).convert = convert
    (!____ptr).reset = reset
    ____ptr
  extension (struct: GConverterIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def convert: CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult]]]
    def convert_=(value: CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult]]] = value
    def reset: CFuncPtr1[Ptr[GConverter], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GConverter], Unit]]]
    def reset_=(value: CFuncPtr1[Ptr[GConverter], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GConverter], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult]].toInt, alignmentof[CFuncPtr1[Ptr[GConverter], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverterinputstream.h
*/
opaque type GConverterInputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GConverterInputStream:
  given _tag: Tag[GConverterInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GConverterInputStream] = scala.scalanative.unsafe.alloc[GConverterInputStream](1)
  def apply(parent_instance : GFilterInputStream, priv : Ptr[GConverterInputStreamPrivate])(using Zone): Ptr[GConverterInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GConverterInputStream)
    def parent_instance: GFilterInputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStream]]
    def parent_instance_=(value: GFilterInputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStream]] = value
    def priv: Ptr[GConverterInputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GConverterInputStreamPrivate]]]
    def priv_=(value: Ptr[GConverterInputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GConverterInputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterInputStream].toInt)
    res(1) = align(res(0) + sizeof[GFilterInputStream].toInt, alignmentof[Ptr[GConverterInputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverterinputstream.h
*/
opaque type GConverterInputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._1, Nat._2]]
object GConverterInputStreamClass:
  given _tag: Tag[GConverterInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._1, Nat._2]](Tag.Byte, Tag.Digit3[Nat._3, Nat._1, Nat._2](Tag.Nat3, Tag.Nat1, Tag.Nat2))
  def apply()(using Zone): Ptr[GConverterInputStreamClass] = scala.scalanative.unsafe.alloc[GConverterInputStreamClass](1)
  def apply(parent_class : GFilterInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GConverterInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GConverterInputStreamClass)
    def parent_class: GFilterInputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStreamClass]]
    def parent_class_=(value: GFilterInputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterInputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterInputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GFilterInputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverterinputstream.h
*/
opaque type GConverterInputStreamPrivate = CStruct0
object GConverterInputStreamPrivate:
  given _tag: Tag[GConverterInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverteroutputstream.h
*/
opaque type GConverterOutputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GConverterOutputStream:
  given _tag: Tag[GConverterOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GConverterOutputStream] = scala.scalanative.unsafe.alloc[GConverterOutputStream](1)
  def apply(parent_instance : GFilterOutputStream, priv : Ptr[GConverterOutputStreamPrivate])(using Zone): Ptr[GConverterOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GConverterOutputStream)
    def parent_instance: GFilterOutputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStream]]
    def parent_instance_=(value: GFilterOutputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStream]] = value
    def priv: Ptr[GConverterOutputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GConverterOutputStreamPrivate]]]
    def priv_=(value: Ptr[GConverterOutputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GConverterOutputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterOutputStream].toInt)
    res(1) = align(res(0) + sizeof[GFilterOutputStream].toInt, alignmentof[Ptr[GConverterOutputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverteroutputstream.h
*/
opaque type GConverterOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._0]]
object GConverterOutputStreamClass:
  given _tag: Tag[GConverterOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._3, Nat._6, Nat._0](Tag.Nat3, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GConverterOutputStreamClass] = scala.scalanative.unsafe.alloc[GConverterOutputStreamClass](1)
  def apply(parent_class : GFilterOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GConverterOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GConverterOutputStreamClass)
    def parent_class: GFilterOutputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStreamClass]]
    def parent_class_=(value: GFilterOutputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterOutputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GFilterOutputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverteroutputstream.h
*/
opaque type GConverterOutputStreamPrivate = CStruct0
object GConverterOutputStreamPrivate:
  given _tag: Tag[GConverterOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GCredentials = CStruct0
object GCredentials:
  given _tag: Tag[GCredentials] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcredentials.h
*/
opaque type GCredentialsClass = CStruct0
object GCredentialsClass:
  given _tag: Tag[GCredentialsClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusActionGroup = CStruct0
object GDBusActionGroup:
  given _tag: Tag[GDBusActionGroup] = Tag.materializeCStruct0Tag

/**
 * GDBusAnnotationInfo: _count: The reference count or -1 if statically allocated. : The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated". : The value of the annotation. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusAnnotationInfo = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusAnnotationInfo:
  given _tag: Tag[GDBusAnnotationInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusAnnotationInfo] = scala.scalanative.unsafe.alloc[GDBusAnnotationInfo](1)
  def apply(ref_count : _root_.glib.gint, key : Ptr[_root_.glib.gchar], value : Ptr[_root_.glib.gchar], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusAnnotationInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).key = key
    (!____ptr).value = value
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusAnnotationInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def key: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def key_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def value: Ptr[_root_.glib.gchar] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def value_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * GDBusArgInfo: _count: The reference count or -1 if statically allocated. : D-Bus signature of the argument (a single complete type). : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusArgInfo = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusArgInfo:
  given _tag: Tag[GDBusArgInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusArgInfo] = scala.scalanative.unsafe.alloc[GDBusArgInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], signature : Ptr[_root_.glib.gchar], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusArgInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).signature = signature
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusArgInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def name: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def signature: Ptr[_root_.glib.gchar] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def signature_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusAuthObserver = CStruct0
object GDBusAuthObserver:
  given _tag: Tag[GDBusAuthObserver] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusConnection = CStruct0
object GDBusConnection:
  given _tag: Tag[GDBusConnection] = Tag.materializeCStruct0Tag

/**
 * GDBusErrorEntry: _code: An error code. _error_name: The D-Bus error name to associate with _code.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbuserror.h
*/
opaque type GDBusErrorEntry = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GDBusErrorEntry:
  given _tag: Tag[GDBusErrorEntry] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GDBusErrorEntry] = scala.scalanative.unsafe.alloc[GDBusErrorEntry](1)
  def apply(error_code : _root_.glib.gint, dbus_error_name : Ptr[_root_.glib.gchar])(using Zone): Ptr[GDBusErrorEntry] = 
    val ____ptr = apply()
    (!____ptr).error_code = error_code
    (!____ptr).dbus_error_name = dbus_error_name
    ____ptr
  extension (struct: GDBusErrorEntry)
    def error_code: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def error_code_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def dbus_error_name: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def dbus_error_name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusInterface = CStruct0
object GDBusInterface:
  given _tag: Tag[GDBusInterface] = Tag.materializeCStruct0Tag

/**
 * GDBusInterfaceIface: _iface: The parent interface. _info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info(). _object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterface.h
*/
opaque type GDBusInterfaceIface = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GDBusInterfaceIface:
  given _tag: Tag[GDBusInterfaceIface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GDBusInterfaceIface] = scala.scalanative.unsafe.alloc[GDBusInterfaceIface](1)
  def apply(parent_iface : _root_.gobject.GTypeInterface, get_info : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]], get_object : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]], set_object : CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit], dup_object : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]])(using Zone): Ptr[GDBusInterfaceIface] = 
    val ____ptr = apply()
    (!____ptr).parent_iface = parent_iface
    (!____ptr).get_info = get_info
    (!____ptr).get_object = get_object
    (!____ptr).set_object = set_object
    (!____ptr).dup_object = dup_object
    ____ptr
  extension (struct: GDBusInterfaceIface)
    def parent_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def parent_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def get_info: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]]]
    def get_info_=(value: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]]] = value
    def get_object: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]]]
    def get_object_=(value: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]]] = value
    def set_object: CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit]]]
    def set_object_=(value: CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit]]] = value
    def dup_object: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]]]
    def dup_object_=(value: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]].toInt)
    res
  end offsets

/**
 * GDBusInterfaceInfo: _count: The reference count or -1 if statically allocated. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusInterfaceInfo = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GDBusInterfaceInfo:
  given _tag: Tag[GDBusInterfaceInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GDBusInterfaceInfo] = scala.scalanative.unsafe.alloc[GDBusInterfaceInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], methods : Ptr[Ptr[GDBusMethodInfo]], signals : Ptr[Ptr[GDBusSignalInfo]], properties : Ptr[Ptr[GDBusPropertyInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusInterfaceInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).methods = methods
    (!____ptr).signals = signals
    (!____ptr).properties = properties
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusInterfaceInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def name: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def methods: Ptr[Ptr[GDBusMethodInfo]] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusMethodInfo]]]]
    def methods_=(value: Ptr[Ptr[GDBusMethodInfo]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusMethodInfo]]]] = value
    def signals: Ptr[Ptr[GDBusSignalInfo]] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusSignalInfo]]]]
    def signals_=(value: Ptr[Ptr[GDBusSignalInfo]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusSignalInfo]]]] = value
    def properties: Ptr[Ptr[GDBusPropertyInfo]] = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusPropertyInfo]]]]
    def properties_=(value: Ptr[Ptr[GDBusPropertyInfo]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusPropertyInfo]]]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(5)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[Ptr[GDBusMethodInfo]]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[Ptr[GDBusMethodInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusSignalInfo]]].toInt)
    res(4) = align(res(3) + sizeof[Ptr[Ptr[GDBusSignalInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusPropertyInfo]]].toInt)
    res(5) = align(res(4) + sizeof[Ptr[Ptr[GDBusPropertyInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterfaceskeleton.h
*/
opaque type GDBusInterfaceSkeleton = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusInterfaceSkeleton:
  given _tag: Tag[GDBusInterfaceSkeleton] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusInterfaceSkeleton] = scala.scalanative.unsafe.alloc[GDBusInterfaceSkeleton](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusInterfaceSkeletonPrivate])(using Zone): Ptr[GDBusInterfaceSkeleton] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDBusInterfaceSkeleton)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GDBusInterfaceSkeletonPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusInterfaceSkeletonPrivate]]]
    def priv_=(value: Ptr[GDBusInterfaceSkeletonPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusInterfaceSkeletonPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GDBusInterfaceSkeletonPrivate]].toInt)
    res
  end offsets

/**
 * GDBusInterfaceSkeletonClass: _class: The parent class. _info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details. _vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details. _properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties(). : Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush(). _authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterfaceskeleton.h
*/
opaque type GDBusInterfaceSkeletonClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]]
object GDBusInterfaceSkeletonClass:
  given _tag: Tag[GDBusInterfaceSkeletonClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]](Tag.Byte, Tag.Digit3[Nat._3, Nat._0, Nat._4](Tag.Nat3, Tag.Nat0, Tag.Nat4))
  def apply()(using Zone): Ptr[GDBusInterfaceSkeletonClass] = scala.scalanative.unsafe.alloc[GDBusInterfaceSkeletonClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_info : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]], get_vtable : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]], get_properties : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]], flush : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit], vfunc_padding : CArray[_root_.glib.gpointer, Nat._8], g_authorize_method : CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], signal_padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusInterfaceSkeletonClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_info = get_info
    (!____ptr).get_vtable = get_vtable
    (!____ptr).get_properties = get_properties
    (!____ptr).flush = flush
    (!____ptr).vfunc_padding = vfunc_padding
    (!____ptr).g_authorize_method = g_authorize_method
    (!____ptr).signal_padding = signal_padding
    ____ptr
  extension (struct: GDBusInterfaceSkeletonClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_info: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]]]
    def get_info_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]]] = value
    def get_vtable: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]]]]
    def get_vtable_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]]]] = value
    def get_properties: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]]]]
    def get_properties_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]]]] = value
    def flush: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit]]]
    def flush_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit]]] = value
    def vfunc_padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def vfunc_padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
    def g_authorize_method: CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]]]
    def g_authorize_method_=(value: CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]]] = value
    def signal_padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def signal_padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res(6) = align(res(5) + sizeof[CArray[_root_.glib.gpointer, Nat._8]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterfaceskeleton.h
*/
opaque type GDBusInterfaceSkeletonPrivate = CStruct0
object GDBusInterfaceSkeletonPrivate:
  given _tag: Tag[GDBusInterfaceSkeletonPrivate] = Tag.materializeCStruct0Tag

/**
 * GDBusInterfaceVTable: _property: Function for getting a property.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusconnection.h
*/
opaque type GDBusInterfaceVTable = CArray[CChar, Nat.Digit2[Nat._8, Nat._8]]
object GDBusInterfaceVTable:
  given _tag: Tag[GDBusInterfaceVTable] = Tag.CArray[CChar, Nat.Digit2[Nat._8, Nat._8]](Tag.Byte, Tag.Digit2[Nat._8, Nat._8](Tag.Nat8, Tag.Nat8))
  def apply()(using Zone): Ptr[GDBusInterfaceVTable] = scala.scalanative.unsafe.alloc[GDBusInterfaceVTable](1)
  def apply(method_call : GDBusInterfaceMethodCallFunc, get_property : GDBusInterfaceGetPropertyFunc, set_property : GDBusInterfaceSetPropertyFunc, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusInterfaceVTable] = 
    val ____ptr = apply()
    (!____ptr).method_call = method_call
    (!____ptr).get_property = get_property
    (!____ptr).set_property = set_property
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusInterfaceVTable)
    def method_call: GDBusInterfaceMethodCallFunc = !struct.at(offsets(0)).asInstanceOf[Ptr[GDBusInterfaceMethodCallFunc]]
    def method_call_=(value: GDBusInterfaceMethodCallFunc): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GDBusInterfaceMethodCallFunc]] = value
    def get_property: GDBusInterfaceGetPropertyFunc = !struct.at(offsets(1)).asInstanceOf[Ptr[GDBusInterfaceGetPropertyFunc]]
    def get_property_=(value: GDBusInterfaceGetPropertyFunc): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[GDBusInterfaceGetPropertyFunc]] = value
    def set_property: GDBusInterfaceSetPropertyFunc = !struct.at(offsets(2)).asInstanceOf[Ptr[GDBusInterfaceSetPropertyFunc]]
    def set_property_=(value: GDBusInterfaceSetPropertyFunc): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[GDBusInterfaceSetPropertyFunc]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GDBusInterfaceMethodCallFunc].toInt)
    res(1) = align(res(0) + sizeof[GDBusInterfaceMethodCallFunc].toInt, alignmentof[GDBusInterfaceGetPropertyFunc].toInt)
    res(2) = align(res(1) + sizeof[GDBusInterfaceGetPropertyFunc].toInt, alignmentof[GDBusInterfaceSetPropertyFunc].toInt)
    res(3) = align(res(2) + sizeof[GDBusInterfaceSetPropertyFunc].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusmenumodel.h
*/
opaque type GDBusMenuModel = CStruct0
object GDBusMenuModel:
  given _tag: Tag[GDBusMenuModel] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusMessage = CStruct0
object GDBusMessage:
  given _tag: Tag[GDBusMessage] = Tag.materializeCStruct0Tag

/**
 * GDBusMethodInfo: _count: The reference count or -1 if statically allocated. _args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments. _args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusMethodInfo = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GDBusMethodInfo:
  given _tag: Tag[GDBusMethodInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GDBusMethodInfo] = scala.scalanative.unsafe.alloc[GDBusMethodInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], in_args : Ptr[Ptr[GDBusArgInfo]], out_args : Ptr[Ptr[GDBusArgInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusMethodInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).in_args = in_args
    (!____ptr).out_args = out_args
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusMethodInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def name: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def in_args: Ptr[Ptr[GDBusArgInfo]] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusArgInfo]]]]
    def in_args_=(value: Ptr[Ptr[GDBusArgInfo]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusArgInfo]]]] = value
    def out_args: Ptr[Ptr[GDBusArgInfo]] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusArgInfo]]]]
    def out_args_=(value: Ptr[Ptr[GDBusArgInfo]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusArgInfo]]]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[Ptr[GDBusArgInfo]]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[Ptr[GDBusArgInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusArgInfo]]].toInt)
    res(4) = align(res(3) + sizeof[Ptr[Ptr[GDBusArgInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusMethodInvocation = CStruct0
object GDBusMethodInvocation:
  given _tag: Tag[GDBusMethodInvocation] = Tag.materializeCStruct0Tag

/**
 * GDBusNodeInfo: _count: The reference count or -1 if statically allocated. : The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusNodeInfo = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GDBusNodeInfo:
  given _tag: Tag[GDBusNodeInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GDBusNodeInfo] = scala.scalanative.unsafe.alloc[GDBusNodeInfo](1)
  def apply(ref_count : _root_.glib.gint, path : Ptr[_root_.glib.gchar], interfaces : Ptr[Ptr[GDBusInterfaceInfo]], nodes : Ptr[Ptr[GDBusNodeInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusNodeInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).path = path
    (!____ptr).interfaces = interfaces
    (!____ptr).nodes = nodes
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusNodeInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def path: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def path_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def interfaces: Ptr[Ptr[GDBusInterfaceInfo]] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusInterfaceInfo]]]]
    def interfaces_=(value: Ptr[Ptr[GDBusInterfaceInfo]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusInterfaceInfo]]]] = value
    def nodes: Ptr[Ptr[GDBusNodeInfo]] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusNodeInfo]]]]
    def nodes_=(value: Ptr[Ptr[GDBusNodeInfo]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusNodeInfo]]]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[Ptr[GDBusInterfaceInfo]]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[Ptr[GDBusInterfaceInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusNodeInfo]]].toInt)
    res(4) = align(res(3) + sizeof[Ptr[Ptr[GDBusNodeInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusObject = CStruct0
object GDBusObject:
  given _tag: Tag[GDBusObject] = Tag.materializeCStruct0Tag

/**
 * GDBusObjectIface: _iface: The parent interface. _object_path: Returns the object path. See g_dbus_object_get_object_path(). _interfaces: Returns all interfaces. See g_dbus_object_get_interfaces(). _interface: Returns an interface by name. See g_dbus_object_get_interface().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobject.h
*/
opaque type GDBusObjectIface = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GDBusObjectIface:
  given _tag: Tag[GDBusObjectIface] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GDBusObjectIface] = scala.scalanative.unsafe.alloc[GDBusObjectIface](1)
  def apply(parent_iface : _root_.gobject.GTypeInterface, get_object_path : CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]], get_interfaces : CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]], get_interface : CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], interface_added : CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit], interface_removed : CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit])(using Zone): Ptr[GDBusObjectIface] = 
    val ____ptr = apply()
    (!____ptr).parent_iface = parent_iface
    (!____ptr).get_object_path = get_object_path
    (!____ptr).get_interfaces = get_interfaces
    (!____ptr).get_interface = get_interface
    (!____ptr).interface_added = interface_added
    (!____ptr).interface_removed = interface_removed
    ____ptr
  extension (struct: GDBusObjectIface)
    def parent_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def parent_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def get_object_path: CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]]]]
    def get_object_path_=(value: CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]]]] = value
    def get_interfaces: CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]]]
    def get_interfaces_=(value: CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]]] = value
    def get_interface: CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]]]
    def get_interface_=(value: CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]]] = value
    def interface_added: CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]]
    def interface_added_=(value: CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]] = value
    def interface_removed: CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]]
    def interface_removed_=(value: CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusObjectManager = CStruct0
object GDBusObjectManager:
  given _tag: Tag[GDBusObjectManager] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerclient.h
*/
opaque type GDBusObjectManagerClient = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusObjectManagerClient:
  given _tag: Tag[GDBusObjectManagerClient] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusObjectManagerClient] = scala.scalanative.unsafe.alloc[GDBusObjectManagerClient](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectManagerClientPrivate])(using Zone): Ptr[GDBusObjectManagerClient] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDBusObjectManagerClient)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GDBusObjectManagerClientPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectManagerClientPrivate]]]
    def priv_=(value: Ptr[GDBusObjectManagerClientPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectManagerClientPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GDBusObjectManagerClientPrivate]].toInt)
    res
  end offsets

/**
 * GDBusObjectManagerClientClass: _class: The parent class.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerclient.h
*/
opaque type GDBusObjectManagerClientClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]]
object GDBusObjectManagerClientClass:
  given _tag: Tag[GDBusObjectManagerClientClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._1, Nat._6](Tag.Nat2, Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GDBusObjectManagerClientClass] = scala.scalanative.unsafe.alloc[GDBusObjectManagerClientClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, interface_proxy_signal : CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], interface_proxy_properties_changed : CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusObjectManagerClientClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).interface_proxy_signal = interface_proxy_signal
    (!____ptr).interface_proxy_properties_changed = interface_proxy_properties_changed
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusObjectManagerClientClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def interface_proxy_signal: CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]]
    def interface_proxy_signal_=(value: CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]] = value
    def interface_proxy_properties_changed: CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]]]
    def interface_proxy_properties_changed_=(value: CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerclient.h
*/
opaque type GDBusObjectManagerClientPrivate = CStruct0
object GDBusObjectManagerClientPrivate:
  given _tag: Tag[GDBusObjectManagerClientPrivate] = Tag.materializeCStruct0Tag

/**
 * GDBusObjectManagerIface: _iface: The parent interface. _object_path: Virtual function for g_dbus_object_manager_get_object_path(). _objects: Virtual function for g_dbus_object_manager_get_objects(). _object: Virtual function for g_dbus_object_manager_get_object(). _interface: Virtual function for g_dbus_object_manager_get_interface(). _added: Signal handler for the #GDBusObjectManager::object-added signal. _removed: Signal handler for the #GDBusObjectManager::object-removed signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanager.h
*/
opaque type GDBusObjectManagerIface = CArray[CChar, Nat.Digit2[Nat._8, Nat._0]]
object GDBusObjectManagerIface:
  given _tag: Tag[GDBusObjectManagerIface] = Tag.CArray[CChar, Nat.Digit2[Nat._8, Nat._0]](Tag.Byte, Tag.Digit2[Nat._8, Nat._0](Tag.Nat8, Tag.Nat0))
  def apply()(using Zone): Ptr[GDBusObjectManagerIface] = scala.scalanative.unsafe.alloc[GDBusObjectManagerIface](1)
  def apply(parent_iface : _root_.gobject.GTypeInterface, get_object_path : CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]], get_objects : CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]], get_object : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]], get_interface : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], object_added : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], object_removed : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], interface_added : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit], interface_removed : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit])(using Zone): Ptr[GDBusObjectManagerIface] = 
    val ____ptr = apply()
    (!____ptr).parent_iface = parent_iface
    (!____ptr).get_object_path = get_object_path
    (!____ptr).get_objects = get_objects
    (!____ptr).get_object = get_object
    (!____ptr).get_interface = get_interface
    (!____ptr).object_added = object_added
    (!____ptr).object_removed = object_removed
    (!____ptr).interface_added = interface_added
    (!____ptr).interface_removed = interface_removed
    ____ptr
  extension (struct: GDBusObjectManagerIface)
    def parent_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def parent_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def get_object_path: CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]]]]
    def get_object_path_=(value: CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]]]] = value
    def get_objects: CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]]]
    def get_objects_=(value: CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]]] = value
    def get_object: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]]]]
    def get_object_=(value: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]]]] = value
    def get_interface: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]]]
    def get_interface_=(value: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]]] = value
    def object_added: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]]]
    def object_added_=(value: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]]] = value
    def object_removed: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]]]
    def object_removed_=(value: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]]] = value
    def interface_added: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]]
    def interface_added_=(value: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]] = value
    def interface_removed: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]]
    def interface_removed_=(value: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](9)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]]].toInt, alignmentof[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerserver.h
*/
opaque type GDBusObjectManagerServer = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusObjectManagerServer:
  given _tag: Tag[GDBusObjectManagerServer] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusObjectManagerServer] = scala.scalanative.unsafe.alloc[GDBusObjectManagerServer](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectManagerServerPrivate])(using Zone): Ptr[GDBusObjectManagerServer] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDBusObjectManagerServer)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GDBusObjectManagerServerPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectManagerServerPrivate]]]
    def priv_=(value: Ptr[GDBusObjectManagerServerPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectManagerServerPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GDBusObjectManagerServerPrivate]].toInt)
    res
  end offsets

/**
 * GDBusObjectManagerServerClass: _class: The parent class.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerserver.h
*/
opaque type GDBusObjectManagerServerClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]]
object GDBusObjectManagerServerClass:
  given _tag: Tag[GDBusObjectManagerServerClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]](Tag.Byte, Tag.Digit3[Nat._2, Nat._0, Nat._0](Tag.Nat2, Tag.Nat0, Tag.Nat0))
  def apply()(using Zone): Ptr[GDBusObjectManagerServerClass] = scala.scalanative.unsafe.alloc[GDBusObjectManagerServerClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusObjectManagerServerClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusObjectManagerServerClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerserver.h
*/
opaque type GDBusObjectManagerServerPrivate = CStruct0
object GDBusObjectManagerServerPrivate:
  given _tag: Tag[GDBusObjectManagerServerPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectproxy.h
*/
opaque type GDBusObjectProxy = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusObjectProxy:
  given _tag: Tag[GDBusObjectProxy] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusObjectProxy] = scala.scalanative.unsafe.alloc[GDBusObjectProxy](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectProxyPrivate])(using Zone): Ptr[GDBusObjectProxy] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDBusObjectProxy)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GDBusObjectProxyPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectProxyPrivate]]]
    def priv_=(value: Ptr[GDBusObjectProxyPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectProxyPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GDBusObjectProxyPrivate]].toInt)
    res
  end offsets

/**
 * GDBusObjectProxyClass: _class: The parent class.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectproxy.h
*/
opaque type GDBusObjectProxyClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]]
object GDBusObjectProxyClass:
  given _tag: Tag[GDBusObjectProxyClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]](Tag.Byte, Tag.Digit3[Nat._2, Nat._0, Nat._0](Tag.Nat2, Tag.Nat0, Tag.Nat0))
  def apply()(using Zone): Ptr[GDBusObjectProxyClass] = scala.scalanative.unsafe.alloc[GDBusObjectProxyClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusObjectProxyClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusObjectProxyClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectproxy.h
*/
opaque type GDBusObjectProxyPrivate = CStruct0
object GDBusObjectProxyPrivate:
  given _tag: Tag[GDBusObjectProxyPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectskeleton.h
*/
opaque type GDBusObjectSkeleton = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusObjectSkeleton:
  given _tag: Tag[GDBusObjectSkeleton] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusObjectSkeleton] = scala.scalanative.unsafe.alloc[GDBusObjectSkeleton](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectSkeletonPrivate])(using Zone): Ptr[GDBusObjectSkeleton] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDBusObjectSkeleton)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GDBusObjectSkeletonPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectSkeletonPrivate]]]
    def priv_=(value: Ptr[GDBusObjectSkeletonPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusObjectSkeletonPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GDBusObjectSkeletonPrivate]].toInt)
    res
  end offsets

/**
 * GDBusObjectSkeletonClass: _class: The parent class. _method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectskeleton.h
*/
opaque type GDBusObjectSkeletonClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._8]]
object GDBusObjectSkeletonClass:
  given _tag: Tag[GDBusObjectSkeletonClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._8]](Tag.Byte, Tag.Digit3[Nat._2, Nat._0, Nat._8](Tag.Nat2, Tag.Nat0, Tag.Nat8))
  def apply()(using Zone): Ptr[GDBusObjectSkeletonClass] = scala.scalanative.unsafe.alloc[GDBusObjectSkeletonClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, authorize_method : CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusObjectSkeletonClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).authorize_method = authorize_method
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusObjectSkeletonClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def authorize_method: CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]]]
    def authorize_method_=(value: CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(2)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectskeleton.h
*/
opaque type GDBusObjectSkeletonPrivate = CStruct0
object GDBusObjectSkeletonPrivate:
  given _tag: Tag[GDBusObjectSkeletonPrivate] = Tag.materializeCStruct0Tag

/**
 * GDBusPropertyInfo: _count: The reference count or -1 if statically allocated. : The D-Bus signature of the property (a single complete type). : Access control flags for the property. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusPropertyInfo = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GDBusPropertyInfo:
  given _tag: Tag[GDBusPropertyInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GDBusPropertyInfo] = scala.scalanative.unsafe.alloc[GDBusPropertyInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], signature : Ptr[_root_.glib.gchar], flags : GDBusPropertyInfoFlags, annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusPropertyInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).signature = signature
    (!____ptr).flags = flags
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusPropertyInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def name: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def signature: Ptr[_root_.glib.gchar] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def signature_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def flags: GDBusPropertyInfoFlags = !struct.at(offsets(3)).asInstanceOf[Ptr[GDBusPropertyInfoFlags]]
    def flags_=(value: GDBusPropertyInfoFlags): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[GDBusPropertyInfoFlags]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[GDBusPropertyInfoFlags].toInt)
    res(4) = align(res(3) + sizeof[GDBusPropertyInfoFlags].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusproxy.h
*/
opaque type GDBusProxy = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusProxy:
  given _tag: Tag[GDBusProxy] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusProxy] = scala.scalanative.unsafe.alloc[GDBusProxy](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusProxyPrivate])(using Zone): Ptr[GDBusProxy] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDBusProxy)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GDBusProxyPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusProxyPrivate]]]
    def priv_=(value: Ptr[GDBusProxyPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDBusProxyPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GDBusProxyPrivate]].toInt)
    res
  end offsets

/**
 * GDBusProxyClass: _properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal. _signal: Signal class handler for the #GDBusProxy::g-signal signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusproxy.h
*/
opaque type GDBusProxyClass = CArray[CChar, Nat.Digit3[Nat._4, Nat._0, Nat._8]]
object GDBusProxyClass:
  given _tag: Tag[GDBusProxyClass] = Tag.CArray[CChar, Nat.Digit3[Nat._4, Nat._0, Nat._8]](Tag.Byte, Tag.Digit3[Nat._4, Nat._0, Nat._8](Tag.Nat4, Tag.Nat0, Tag.Nat8))
  def apply()(using Zone): Ptr[GDBusProxyClass] = scala.scalanative.unsafe.alloc[GDBusProxyClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, g_properties_changed : CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], g_signal : CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]])(using Zone): Ptr[GDBusProxyClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).g_properties_changed = g_properties_changed
    (!____ptr).g_signal = g_signal
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusProxyClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def g_properties_changed: CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]]]
    def g_properties_changed_=(value: CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]]] = value
    def g_signal: CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]]
    def g_signal_=(value: CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusproxy.h
*/
opaque type GDBusProxyPrivate = CStruct0
object GDBusProxyPrivate:
  given _tag: Tag[GDBusProxyPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDBusServer = CStruct0
object GDBusServer:
  given _tag: Tag[GDBusServer] = Tag.materializeCStruct0Tag

/**
 * GDBusSignalInfo: _count: The reference count or -1 if statically allocated.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type GDBusSignalInfo = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GDBusSignalInfo:
  given _tag: Tag[GDBusSignalInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GDBusSignalInfo] = scala.scalanative.unsafe.alloc[GDBusSignalInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], args : Ptr[Ptr[GDBusArgInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[GDBusSignalInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).args = args
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: GDBusSignalInfo)
    def ref_count: _root_.glib.gint = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]]
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def name: Ptr[_root_.glib.gchar] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]]
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[_root_.glib.gchar]]] = value
    def args: Ptr[Ptr[GDBusArgInfo]] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusArgInfo]]]]
    def args_=(value: Ptr[Ptr[GDBusArgInfo]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[Ptr[GDBusArgInfo]]]] = value
    def annotations: Ptr[Ptr[GDBusAnnotationInfo]] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[Ptr[GDBusAnnotationInfo]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gint].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[_root_.glib.gchar]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[_root_.glib.gchar]].toInt, alignmentof[Ptr[Ptr[GDBusArgInfo]]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[Ptr[GDBusArgInfo]]].toInt, alignmentof[Ptr[Ptr[GDBusAnnotationInfo]]].toInt)
    res
  end offsets

/**
 * GDBusSubtreeVTable: : Function for enumerating child nodes. : Function for introspecting a child node. : Function for dispatching a remote call on a child node.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusconnection.h
*/
opaque type GDBusSubtreeVTable = CArray[CChar, Nat.Digit2[Nat._8, Nat._8]]
object GDBusSubtreeVTable:
  given _tag: Tag[GDBusSubtreeVTable] = Tag.CArray[CChar, Nat.Digit2[Nat._8, Nat._8]](Tag.Byte, Tag.Digit2[Nat._8, Nat._8](Tag.Nat8, Tag.Nat8))
  def apply()(using Zone): Ptr[GDBusSubtreeVTable] = scala.scalanative.unsafe.alloc[GDBusSubtreeVTable](1)
  def apply(enumerate : GDBusSubtreeEnumerateFunc, introspect : GDBusSubtreeIntrospectFunc, dispatch : GDBusSubtreeDispatchFunc, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GDBusSubtreeVTable] = 
    val ____ptr = apply()
    (!____ptr).enumerate = enumerate
    (!____ptr).introspect = introspect
    (!____ptr).dispatch = dispatch
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDBusSubtreeVTable)
    def enumerate: GDBusSubtreeEnumerateFunc = !struct.at(offsets(0)).asInstanceOf[Ptr[GDBusSubtreeEnumerateFunc]]
    def enumerate_=(value: GDBusSubtreeEnumerateFunc): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GDBusSubtreeEnumerateFunc]] = value
    def introspect: GDBusSubtreeIntrospectFunc = !struct.at(offsets(1)).asInstanceOf[Ptr[GDBusSubtreeIntrospectFunc]]
    def introspect_=(value: GDBusSubtreeIntrospectFunc): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[GDBusSubtreeIntrospectFunc]] = value
    def dispatch: GDBusSubtreeDispatchFunc = !struct.at(offsets(2)).asInstanceOf[Ptr[GDBusSubtreeDispatchFunc]]
    def dispatch_=(value: GDBusSubtreeDispatchFunc): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[GDBusSubtreeDispatchFunc]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GDBusSubtreeEnumerateFunc].toInt)
    res(1) = align(res(0) + sizeof[GDBusSubtreeEnumerateFunc].toInt, alignmentof[GDBusSubtreeIntrospectFunc].toInt)
    res(2) = align(res(1) + sizeof[GDBusSubtreeIntrospectFunc].toInt, alignmentof[GDBusSubtreeDispatchFunc].toInt)
    res(3) = align(res(2) + sizeof[GDBusSubtreeDispatchFunc].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatainputstream.h
*/
opaque type GDataInputStream = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GDataInputStream:
  given _tag: Tag[GDataInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GDataInputStream] = scala.scalanative.unsafe.alloc[GDataInputStream](1)
  def apply(parent_instance : GBufferedInputStream, priv : Ptr[GDataInputStreamPrivate])(using Zone): Ptr[GDataInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDataInputStream)
    def parent_instance: GBufferedInputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GBufferedInputStream]]
    def parent_instance_=(value: GBufferedInputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GBufferedInputStream]] = value
    def priv: Ptr[GDataInputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDataInputStreamPrivate]]]
    def priv_=(value: Ptr[GDataInputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDataInputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GBufferedInputStream].toInt)
    res(1) = align(res(0) + sizeof[GBufferedInputStream].toInt, alignmentof[Ptr[GDataInputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatainputstream.h
*/
opaque type GDataInputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._7, Nat._6]]
object GDataInputStreamClass:
  given _tag: Tag[GDataInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._7, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._7, Nat._6](Tag.Nat3, Tag.Nat7, Tag.Nat6))
  def apply()(using Zone): Ptr[GDataInputStreamClass] = scala.scalanative.unsafe.alloc[GDataInputStreamClass](1)
  def apply(parent_class : GBufferedInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GDataInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GDataInputStreamClass)
    def parent_class: GBufferedInputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GBufferedInputStreamClass]]
    def parent_class_=(value: GBufferedInputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GBufferedInputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GBufferedInputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GBufferedInputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatainputstream.h
*/
opaque type GDataInputStreamPrivate = CStruct0
object GDataInputStreamPrivate:
  given _tag: Tag[GDataInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdataoutputstream.h
*/
opaque type GDataOutputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GDataOutputStream:
  given _tag: Tag[GDataOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GDataOutputStream] = scala.scalanative.unsafe.alloc[GDataOutputStream](1)
  def apply(parent_instance : GFilterOutputStream, priv : Ptr[GDataOutputStreamPrivate])(using Zone): Ptr[GDataOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GDataOutputStream)
    def parent_instance: GFilterOutputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStream]]
    def parent_instance_=(value: GFilterOutputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStream]] = value
    def priv: Ptr[GDataOutputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDataOutputStreamPrivate]]]
    def priv_=(value: Ptr[GDataOutputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GDataOutputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterOutputStream].toInt)
    res(1) = align(res(0) + sizeof[GFilterOutputStream].toInt, alignmentof[Ptr[GDataOutputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdataoutputstream.h
*/
opaque type GDataOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._0]]
object GDataOutputStreamClass:
  given _tag: Tag[GDataOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._3, Nat._6, Nat._0](Tag.Nat3, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GDataOutputStreamClass] = scala.scalanative.unsafe.alloc[GDataOutputStreamClass](1)
  def apply(parent_class : GFilterOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GDataOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GDataOutputStreamClass)
    def parent_class: GFilterOutputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStreamClass]]
    def parent_class_=(value: GFilterOutputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GFilterOutputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GFilterOutputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GFilterOutputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdataoutputstream.h
*/
opaque type GDataOutputStreamPrivate = CStruct0
object GDataOutputStreamPrivate:
  given _tag: Tag[GDataOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDatagramBased = CStruct0
object GDatagramBased:
  given _tag: Tag[GDatagramBased] = Tag.materializeCStruct0Tag

/**
 * GDatagramBasedInterface: _iface: The parent interface. _messages: Virtual method for g_datagram_based_receive_messages(). _messages: Virtual method for g_datagram_based_send_messages(). _source: Virtual method for g_datagram_based_create_source(). _check: Virtual method for g_datagram_based_condition_check(). _wait: Virtual method for g_datagram_based_condition_wait().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatagrambased.h
*/
opaque type GDatagramBasedInterface = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GDatagramBasedInterface:
  given _tag: Tag[GDatagramBasedInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GDatagramBasedInterface] = scala.scalanative.unsafe.alloc[GDatagramBasedInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, receive_messages : CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], send_messages : CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], create_source : CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]], condition_check : CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition], condition_wait : CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GDatagramBasedInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).receive_messages = receive_messages
    (!____ptr).send_messages = send_messages
    (!____ptr).create_source = create_source
    (!____ptr).condition_check = condition_check
    (!____ptr).condition_wait = condition_wait
    ____ptr
  extension (struct: GDatagramBasedInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def receive_messages: CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]]]
    def receive_messages_=(value: CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]]] = value
    def send_messages: CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]]]
    def send_messages_=(value: CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]]] = value
    def create_source: CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]]]
    def create_source_=(value: CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]]] = value
    def condition_check: CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition]]]
    def condition_check_=(value: CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition]]] = value
    def condition_wait: CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def condition_wait_=(value: CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]].toInt, alignmentof[CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]].toInt, alignmentof[CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]].toInt, alignmentof[CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition]].toInt, alignmentof[CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

opaque type GDebugController = CStruct0
object GDebugController:
  given _tag: Tag[GDebugController] = Tag.materializeCStruct0Tag

opaque type GDebugControllerDBus = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GDebugControllerDBus:
  given _tag: Tag[GDebugControllerDBus] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GDebugControllerDBus] = scala.scalanative.unsafe.alloc[GDebugControllerDBus](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[GDebugControllerDBus] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: GDebugControllerDBus)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res
  end offsets

/**
 * GDebugControllerDBusClass: _class: The parent class. : Default handler for the #GDebugControllerDBus::authorize signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdebugcontrollerdbus.h
*/
opaque type GDebugControllerDBusClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._0]]
object GDebugControllerDBusClass:
  given _tag: Tag[GDebugControllerDBusClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._0]](Tag.Byte, Tag.Digit3[Nat._2, Nat._4, Nat._0](Tag.Nat2, Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GDebugControllerDBusClass] = scala.scalanative.unsafe.alloc[GDebugControllerDBusClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, authorize : CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]])(using Zone): Ptr[GDebugControllerDBusClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).authorize = authorize
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GDebugControllerDBusClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def authorize: CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]]]
    def authorize_=(value: CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * GDebugControllerInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdebugcontroller.h
*/
opaque type GDebugControllerInterface = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GDebugControllerInterface:
  given _tag: Tag[GDebugControllerInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GDebugControllerInterface] = scala.scalanative.unsafe.alloc[GDebugControllerInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[GDebugControllerInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: GDebugControllerInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDrive = CStruct0
object GDrive:
  given _tag: Tag[GDrive] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdrive.h
*/
opaque type GDriveIface = CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]]
object GDriveIface:
  given _tag: Tag[GDriveIface] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._7, Nat._2](Tag.Nat2, Tag.Nat7, Tag.Nat2))
  def apply()(using Zone): Ptr[GDriveIface] = scala.scalanative.unsafe.alloc[GDriveIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, changed : CFuncPtr1[Ptr[GDrive], Unit], disconnected : CFuncPtr1[Ptr[GDrive], Unit], eject_button : CFuncPtr1[Ptr[GDrive], Unit], get_name : CFuncPtr1[Ptr[GDrive], CString], get_icon : CFuncPtr1[Ptr[GDrive], Ptr[GIcon]], has_volumes : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], get_volumes : CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]], is_media_removable : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], has_media : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], is_media_check_automatic : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], can_eject : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], can_poll_for_media : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], eject : CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], poll_for_media : CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], poll_for_media_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_identifier : CFuncPtr2[Ptr[GDrive], CString, CString], enumerate_identifiers : CFuncPtr1[Ptr[GDrive], Ptr[CString]], get_start_stop_type : CFuncPtr1[Ptr[GDrive], GDriveStartStopType], can_start : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], can_start_degraded : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], start : CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], start_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_stop : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], stop : CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], stop_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], stop_button : CFuncPtr1[Ptr[GDrive], Unit], eject_with_operation : CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_with_operation_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_sort_key : CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]], get_symbolic_icon : CFuncPtr1[Ptr[GDrive], Ptr[GIcon]], is_removable : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean])(using Zone): Ptr[GDriveIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).changed = changed
    (!____ptr).disconnected = disconnected
    (!____ptr).eject_button = eject_button
    (!____ptr).get_name = get_name
    (!____ptr).get_icon = get_icon
    (!____ptr).has_volumes = has_volumes
    (!____ptr).get_volumes = get_volumes
    (!____ptr).is_media_removable = is_media_removable
    (!____ptr).has_media = has_media
    (!____ptr).is_media_check_automatic = is_media_check_automatic
    (!____ptr).can_eject = can_eject
    (!____ptr).can_poll_for_media = can_poll_for_media
    (!____ptr).eject = eject
    (!____ptr).eject_finish = eject_finish
    (!____ptr).poll_for_media = poll_for_media
    (!____ptr).poll_for_media_finish = poll_for_media_finish
    (!____ptr).get_identifier = get_identifier
    (!____ptr).enumerate_identifiers = enumerate_identifiers
    (!____ptr).get_start_stop_type = get_start_stop_type
    (!____ptr).can_start = can_start
    (!____ptr).can_start_degraded = can_start_degraded
    (!____ptr).start = start
    (!____ptr).start_finish = start_finish
    (!____ptr).can_stop = can_stop
    (!____ptr).stop = stop
    (!____ptr).stop_finish = stop_finish
    (!____ptr).stop_button = stop_button
    (!____ptr).eject_with_operation = eject_with_operation
    (!____ptr).eject_with_operation_finish = eject_with_operation_finish
    (!____ptr).get_sort_key = get_sort_key
    (!____ptr).get_symbolic_icon = get_symbolic_icon
    (!____ptr).is_removable = is_removable
    ____ptr
  extension (struct: GDriveIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def changed: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def changed_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def disconnected: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def disconnected_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def eject_button: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def eject_button_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def get_name: CFuncPtr1[Ptr[GDrive], CString] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GDrive], CString]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]] = value
    def has_volumes: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def has_volumes_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def get_volumes: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]]]
    def get_volumes_=(value: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]]] = value
    def is_media_removable: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def is_media_removable_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def has_media: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def has_media_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def is_media_check_automatic: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def is_media_check_automatic_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def can_eject: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_eject_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def can_poll_for_media: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_poll_for_media_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def eject: CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_=(value: CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def poll_for_media: CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def poll_for_media_=(value: CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def poll_for_media_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def poll_for_media_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_identifier: CFuncPtr2[Ptr[GDrive], CString, CString] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDrive], CString, CString]]]
    def get_identifier_=(value: CFuncPtr2[Ptr[GDrive], CString, CString]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDrive], CString, CString]]] = value
    def enumerate_identifiers: CFuncPtr1[Ptr[GDrive], Ptr[CString]] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[CString]]]]
    def enumerate_identifiers_=(value: CFuncPtr1[Ptr[GDrive], Ptr[CString]]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[CString]]]] = value
    def get_start_stop_type: CFuncPtr1[Ptr[GDrive], GDriveStartStopType] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]]]
    def get_start_stop_type_=(value: CFuncPtr1[Ptr[GDrive], GDriveStartStopType]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]]] = value
    def can_start: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_start_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def can_start_degraded: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_start_degraded_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def start: CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def start_=(value: CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def start_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def start_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_stop: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_stop_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def stop: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def stop_=(value: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def stop_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def stop_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def stop_button: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def stop_button_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def eject_with_operation: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_with_operation_=(value: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_with_operation_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_with_operation_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_sort_key: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]] = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]]]
    def get_sort_key_=(value: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]]] = value
    def get_symbolic_icon: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]] = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]]
    def get_symbolic_icon_=(value: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]): Unit = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]] = value
    def is_removable: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def is_removable_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](33)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], CString]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GDrive], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GDrive], CString, CString]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr2[Ptr[GDrive], CString, CString]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[CString]]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[CString]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(26) = align(res(25) + sizeof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(27) = align(res(26) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(28) = align(res(27) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(29) = align(res(28) + sizeof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(30) = align(res(29) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]].toInt)
    res(31) = align(res(30) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt)
    res(32) = align(res(31) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDtlsClientConnection = CStruct0
object GDtlsClientConnection:
  given _tag: Tag[GDtlsClientConnection] = Tag.materializeCStruct0Tag

/**
 * GDtlsClientConnectionInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdtlsclientconnection.h
*/
opaque type GDtlsClientConnectionInterface = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GDtlsClientConnectionInterface:
  given _tag: Tag[GDtlsClientConnectionInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GDtlsClientConnectionInterface] = scala.scalanative.unsafe.alloc[GDtlsClientConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[GDtlsClientConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: GDtlsClientConnectionInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDtlsConnection = CStruct0
object GDtlsConnection:
  given _tag: Tag[GDtlsConnection] = Tag.materializeCStruct0Tag

/**
 * GDtlsConnectionInterface: _iface: The parent interface. _certificate: Check whether to accept a certificate. : Perform a handshake operation. _async: Start an asynchronous handshake operation. _finish: Finish an asynchronous handshake operation. : Shut down one or both directions of the connection. _async: Start an asynchronous shutdown operation. _finish: Finish an asynchronous shutdown operation.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdtlsconnection.h
*/
opaque type GDtlsConnectionInterface = CArray[CChar, Nat.Digit2[Nat._9, Nat._6]]
object GDtlsConnectionInterface:
  given _tag: Tag[GDtlsConnectionInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._9, Nat._6]](Tag.Byte, Tag.Digit2[Nat._9, Nat._6](Tag.Nat9, Tag.Nat6))
  def apply()(using Zone): Ptr[GDtlsConnectionInterface] = scala.scalanative.unsafe.alloc[GDtlsConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, accept_certificate : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], handshake : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], handshake_async : CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], handshake_finish : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], shutdown : CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], shutdown_async : CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], shutdown_finish : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_advertised_protocols : CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit], get_negotiated_protocol : CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]], get_binding_data : CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GDtlsConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).accept_certificate = accept_certificate
    (!____ptr).handshake = handshake
    (!____ptr).handshake_async = handshake_async
    (!____ptr).handshake_finish = handshake_finish
    (!____ptr).shutdown = shutdown
    (!____ptr).shutdown_async = shutdown_async
    (!____ptr).shutdown_finish = shutdown_finish
    (!____ptr).set_advertised_protocols = set_advertised_protocols
    (!____ptr).get_negotiated_protocol = get_negotiated_protocol
    (!____ptr).get_binding_data = get_binding_data
    ____ptr
  extension (struct: GDtlsConnectionInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def accept_certificate: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]]]
    def accept_certificate_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]]] = value
    def handshake: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def handshake_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def handshake_async: CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def handshake_async_=(value: CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def handshake_finish: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def handshake_finish_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def shutdown: CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def shutdown_=(value: CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def shutdown_async: CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def shutdown_async_=(value: CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def shutdown_finish: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def shutdown_finish_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_advertised_protocols: CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit]]]
    def set_advertised_protocols_=(value: CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit]]] = value
    def get_negotiated_protocol: CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]]]]
    def get_negotiated_protocol_=(value: CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]]]] = value
    def get_binding_data: CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def get_binding_data_=(value: CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](11)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GDtlsServerConnection = CStruct0
object GDtlsServerConnection:
  given _tag: Tag[GDtlsServerConnection] = Tag.materializeCStruct0Tag

/**
 * GDtlsServerConnectionInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdtlsserverconnection.h
*/
opaque type GDtlsServerConnectionInterface = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GDtlsServerConnectionInterface:
  given _tag: Tag[GDtlsServerConnectionInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GDtlsServerConnectionInterface] = scala.scalanative.unsafe.alloc[GDtlsServerConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[GDtlsServerConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: GDtlsServerConnectionInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblem.h
*/
opaque type GEmblem = CStruct0
object GEmblem:
  given _tag: Tag[GEmblem] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblem.h
*/
opaque type GEmblemClass = CStruct0
object GEmblemClass:
  given _tag: Tag[GEmblemClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblemedicon.h
*/
opaque type GEmblemedIcon = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GEmblemedIcon:
  given _tag: Tag[GEmblemedIcon] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GEmblemedIcon] = scala.scalanative.unsafe.alloc[GEmblemedIcon](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GEmblemedIconPrivate])(using Zone): Ptr[GEmblemedIcon] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GEmblemedIcon)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GEmblemedIconPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GEmblemedIconPrivate]]]
    def priv_=(value: Ptr[GEmblemedIconPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GEmblemedIconPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GEmblemedIconPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblemedicon.h
*/
opaque type GEmblemedIconClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GEmblemedIconClass:
  given _tag: Tag[GEmblemedIconClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GEmblemedIconClass] = scala.scalanative.unsafe.alloc[GEmblemedIconClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GEmblemedIconClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GEmblemedIconClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblemedicon.h
*/
opaque type GEmblemedIconPrivate = CStruct0
object GEmblemedIconPrivate:
  given _tag: Tag[GEmblemedIconPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GFile = CStruct0
object GFile:
  given _tag: Tag[GFile] = Tag.materializeCStruct0Tag

/**
 * GFileAttributeInfo: : the #GFileAttributeType type of the attribute. : a set of #GFileAttributeInfoFlags.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileattribute.h
*/
opaque type GFileAttributeInfo = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GFileAttributeInfo:
  given _tag: Tag[GFileAttributeInfo] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GFileAttributeInfo] = scala.scalanative.unsafe.alloc[GFileAttributeInfo](1)
  def apply(name : CString, `type` : GFileAttributeType, flags : GFileAttributeInfoFlags)(using Zone): Ptr[GFileAttributeInfo] = 
    val ____ptr = apply()
    (!____ptr).name = name
    (!____ptr).`type` = `type`
    (!____ptr).flags = flags
    ____ptr
  extension (struct: GFileAttributeInfo)
    def name: CString = !struct.at(offsets(0)).asInstanceOf[Ptr[CString]]
    def name_=(value: CString): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[CString]] = value
    def `type`: GFileAttributeType = !struct.at(offsets(1)).asInstanceOf[Ptr[GFileAttributeType]]
    def type_=(value: GFileAttributeType): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[GFileAttributeType]] = value
    def flags: GFileAttributeInfoFlags = !struct.at(offsets(2)).asInstanceOf[Ptr[GFileAttributeInfoFlags]]
    def flags_=(value: GFileAttributeInfoFlags): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[GFileAttributeInfoFlags]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[CString].toInt)
    res(1) = align(res(0) + sizeof[CString].toInt, alignmentof[GFileAttributeType].toInt)
    res(2) = align(res(1) + sizeof[GFileAttributeType].toInt, alignmentof[GFileAttributeInfoFlags].toInt)
    res
  end offsets

/**
 * GFileAttributeInfoList: : an array of #GFileAttributeInfos. _infos: the number of values in the array.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileattribute.h
*/
opaque type GFileAttributeInfoList = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GFileAttributeInfoList:
  given _tag: Tag[GFileAttributeInfoList] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GFileAttributeInfoList] = scala.scalanative.unsafe.alloc[GFileAttributeInfoList](1)
  def apply(infos : Ptr[GFileAttributeInfo], n_infos : CInt)(using Zone): Ptr[GFileAttributeInfoList] = 
    val ____ptr = apply()
    (!____ptr).infos = infos
    (!____ptr).n_infos = n_infos
    ____ptr
  extension (struct: GFileAttributeInfoList)
    def infos: Ptr[GFileAttributeInfo] = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[GFileAttributeInfo]]]
    def infos_=(value: Ptr[GFileAttributeInfo]): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[GFileAttributeInfo]]] = value
    def n_infos: CInt = !struct.at(offsets(1)).asInstanceOf[Ptr[CInt]]
    def n_infos_=(value: CInt): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CInt]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[Ptr[GFileAttributeInfo]].toInt)
    res(1) = align(res(0) + sizeof[Ptr[GFileAttributeInfo]].toInt, alignmentof[CInt].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GFileAttributeMatcher = CStruct0
object GFileAttributeMatcher:
  given _tag: Tag[GFileAttributeMatcher] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileenumerator.h
*/
opaque type GFileEnumerator = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GFileEnumerator:
  given _tag: Tag[GFileEnumerator] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GFileEnumerator] = scala.scalanative.unsafe.alloc[GFileEnumerator](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GFileEnumeratorPrivate])(using Zone): Ptr[GFileEnumerator] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GFileEnumerator)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GFileEnumeratorPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileEnumeratorPrivate]]]
    def priv_=(value: Ptr[GFileEnumeratorPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileEnumeratorPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GFileEnumeratorPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileenumerator.h
*/
opaque type GFileEnumeratorClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._0]]
object GFileEnumeratorClass:
  given _tag: Tag[GFileEnumeratorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._0]](Tag.Byte, Tag.Digit3[Nat._2, Nat._4, Nat._0](Tag.Nat2, Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFileEnumeratorClass] = scala.scalanative.unsafe.alloc[GFileEnumeratorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, next_file : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], close_fn : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], next_files_async : CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], next_files_finish : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], close_async : CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit])(using Zone): Ptr[GFileEnumeratorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).next_file = next_file
    (!____ptr).close_fn = close_fn
    (!____ptr).next_files_async = next_files_async
    (!____ptr).next_files_finish = next_files_finish
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    ____ptr
  extension (struct: GFileEnumeratorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def next_file: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def next_file_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def close_fn: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_fn_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def next_files_async: CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def next_files_async_=(value: CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def next_files_finish: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def next_files_finish_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def close_async: CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def close_async_=(value: CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def close_finish: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_finish_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved7: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](14)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileenumerator.h
*/
opaque type GFileEnumeratorPrivate = CStruct0
object GFileEnumeratorPrivate:
  given _tag: Tag[GFileEnumeratorPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileiostream.h
*/
opaque type GFileIOStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GFileIOStream:
  given _tag: Tag[GFileIOStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFileIOStream] = scala.scalanative.unsafe.alloc[GFileIOStream](1)
  def apply(parent_instance : GIOStream, priv : Ptr[GFileIOStreamPrivate])(using Zone): Ptr[GFileIOStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GFileIOStream)
    def parent_instance: GIOStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStream]]
    def parent_instance_=(value: GIOStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStream]] = value
    def priv: Ptr[GFileIOStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileIOStreamPrivate]]]
    def priv_=(value: Ptr[GFileIOStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileIOStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GIOStream].toInt)
    res(1) = align(res(0) + sizeof[GIOStream].toInt, alignmentof[Ptr[GFileIOStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileiostream.h
*/
opaque type GFileIOStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._8]]
object GFileIOStreamClass:
  given _tag: Tag[GFileIOStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._8]](Tag.Byte, Tag.Digit3[Nat._3, Nat._6, Nat._8](Tag.Nat3, Tag.Nat6, Tag.Nat8))
  def apply()(using Zone): Ptr[GFileIOStreamClass] = scala.scalanative.unsafe.alloc[GFileIOStreamClass](1)
  def apply(parent_class : GIOStreamClass, tell : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_truncate : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], truncate_fn : CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], query_info : CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], get_etag : CFuncPtr1[Ptr[GFileIOStream], CString], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GFileIOStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).can_truncate = can_truncate
    (!____ptr).truncate_fn = truncate_fn
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr).get_etag = get_etag
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GFileIOStreamClass)
    def parent_class: GIOStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStreamClass]]
    def parent_class_=(value: GIOStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStreamClass]] = value
    def tell: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset]]]
    def tell_=(value: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset]]] = value
    def can_seek: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]]]
    def can_seek_=(value: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]]] = value
    def seek: CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def seek_=(value: CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_truncate: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]]]
    def can_truncate_=(value: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]]] = value
    def truncate_fn: CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def truncate_fn_=(value: CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def query_info: CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_=(value: CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_info_async: CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_info_async_=(value: CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_info_finish: CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def get_etag: CFuncPtr1[Ptr[GFileIOStream], CString] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], CString]]]
    def get_etag_=(value: CFuncPtr1[Ptr[GFileIOStream], CString]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileIOStream], CString]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](15)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GIOStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GIOStreamClass].toInt, alignmentof[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset]].toInt, alignmentof[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr1[Ptr[GFileIOStream], CString]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GFileIOStream], CString]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileiostream.h
*/
opaque type GFileIOStreamPrivate = CStruct0
object GFileIOStreamPrivate:
  given _tag: Tag[GFileIOStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GFileIcon = CStruct0
object GFileIcon:
  given _tag: Tag[GFileIcon] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileicon.h
*/
opaque type GFileIconClass = CStruct0
object GFileIconClass:
  given _tag: Tag[GFileIconClass] = Tag.materializeCStruct0Tag

/**
 * GFileIface: _iface: The parent interface. : Duplicates a #GFile. : Creates a hash of a #GFile. : Checks equality of two given #GFiles. _uri_scheme: Checks to see if a #GFile has a given URI scheme. _uri_scheme: Gets the URI scheme for a #GFile. _basename: Gets the basename for a given #GFile. _path: Gets the current path within a #GFile. _uri: Gets a URI for the path within a #GFile. _parse_name: Gets the parsed name for the #GFile. _parent: Gets the parent directory for the #GFile. _matches: Checks whether a #GFile contains a specified file. _relative_path: Gets the path for a #GFile relative to a given path. _relative_path: Resolves a relative path for a #GFile to an absolute path. _child_for_display_name: Gets the child #GFile for a given display name. _children: Gets a #GFileEnumerator with the children of a #GFile. _children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile. _children_finish: Finishes asynchronously enumerating the children. _info: Gets the #GFileInfo for a #GFile. _info_async: Asynchronously gets the #GFileInfo for a #GFile. _info_finish: Finishes an asynchronous query info operation. _filesystem_info: Gets a #GFileInfo for the file system #GFile is on. _filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on. _filesystem_info_finish: Finishes asynchronously getting the file system info. _enclosing_mount: Gets a #GMount for the #GFile. _enclosing_mount_async: Asynchronously gets the #GMount for a #GFile. _enclosing_mount_finish: Finishes asynchronously getting the volume.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfile.h
*/
opaque type GFileIface = CArray[CChar, Nat.Digit3[Nat._8, Nat._4, Nat._0]]
object GFileIface:
  given _tag: Tag[GFileIface] = Tag.CArray[CChar, Nat.Digit3[Nat._8, Nat._4, Nat._0]](Tag.Byte, Tag.Digit3[Nat._8, Nat._4, Nat._0](Tag.Nat8, Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFileIface] = scala.scalanative.unsafe.alloc[GFileIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, dup : CFuncPtr1[Ptr[GFile], Ptr[GFile]], hash : CFuncPtr1[Ptr[GFile], _root_.glib.guint], equal : CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean], is_native : CFuncPtr1[Ptr[GFile], _root_.glib.gboolean], has_uri_scheme : CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean], get_uri_scheme : CFuncPtr1[Ptr[GFile], CString], get_basename : CFuncPtr1[Ptr[GFile], CString], get_path : CFuncPtr1[Ptr[GFile], CString], get_uri : CFuncPtr1[Ptr[GFile], CString], get_parse_name : CFuncPtr1[Ptr[GFile], CString], get_parent : CFuncPtr1[Ptr[GFile], Ptr[GFile]], prefix_matches : CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean], get_relative_path : CFuncPtr2[Ptr[GFile], Ptr[GFile], CString], resolve_relative_path : CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]], get_child_for_display_name : CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], enumerate_children : CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]], enumerate_children_async : CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], enumerate_children_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]], query_info : CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_filesystem_info : CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_filesystem_info_async : CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_filesystem_info_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], find_enclosing_mount : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]], find_enclosing_mount_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], find_enclosing_mount_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]], set_display_name : CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], set_display_name_async : CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], set_display_name_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], query_settable_attributes : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]], _query_settable_attributes_async : CFuncPtr0[Unit], _query_settable_attributes_finish : CFuncPtr0[Unit], query_writable_namespaces : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]], _query_writable_namespaces_async : CFuncPtr0[Unit], _query_writable_namespaces_finish : CFuncPtr0[Unit], set_attribute : CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_attributes_from_info : CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_attributes_async : CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], set_attributes_finish : CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], read_fn : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]], read_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], read_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]], append_to : CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], append_to_async : CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], append_to_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], create : CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], create_async : CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], create_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], replace : CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], replace_async : CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], replace_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], delete_file : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], delete_file_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], delete_file_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], trash : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], trash_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], trash_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_directory : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_directory_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], make_directory_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_symbolic_link : CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_symbolic_link_async : CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], make_symbolic_link_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], copy : CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], copy_async : CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit], copy_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], move : CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], move_async : CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit], move_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], mount_mountable : CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], mount_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], unmount_mountable : CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject_mountable : CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], mount_enclosing_volume : CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], mount_enclosing_volume_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], monitor_dir : CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]], monitor_file : CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]], open_readwrite : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], open_readwrite_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], open_readwrite_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], create_readwrite : CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], create_readwrite_async : CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], create_readwrite_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], replace_readwrite : CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], replace_readwrite_async : CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], replace_readwrite_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], start_mountable : CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], start_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], stop_mountable : CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], stop_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], supports_thread_contexts : _root_.glib.gboolean, unmount_mountable_with_operation : CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_mountable_with_operation_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject_mountable_with_operation : CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_mountable_with_operation_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], poll_mountable : CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], poll_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], measure_disk_usage : CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], measure_disk_usage_async : CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit], measure_disk_usage_finish : CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GFileIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).dup = dup
    (!____ptr).hash = hash
    (!____ptr).equal = equal
    (!____ptr).is_native = is_native
    (!____ptr).has_uri_scheme = has_uri_scheme
    (!____ptr).get_uri_scheme = get_uri_scheme
    (!____ptr).get_basename = get_basename
    (!____ptr).get_path = get_path
    (!____ptr).get_uri = get_uri
    (!____ptr).get_parse_name = get_parse_name
    (!____ptr).get_parent = get_parent
    (!____ptr).prefix_matches = prefix_matches
    (!____ptr).get_relative_path = get_relative_path
    (!____ptr).resolve_relative_path = resolve_relative_path
    (!____ptr).get_child_for_display_name = get_child_for_display_name
    (!____ptr).enumerate_children = enumerate_children
    (!____ptr).enumerate_children_async = enumerate_children_async
    (!____ptr).enumerate_children_finish = enumerate_children_finish
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr).query_filesystem_info = query_filesystem_info
    (!____ptr).query_filesystem_info_async = query_filesystem_info_async
    (!____ptr).query_filesystem_info_finish = query_filesystem_info_finish
    (!____ptr).find_enclosing_mount = find_enclosing_mount
    (!____ptr).find_enclosing_mount_async = find_enclosing_mount_async
    (!____ptr).find_enclosing_mount_finish = find_enclosing_mount_finish
    (!____ptr).set_display_name = set_display_name
    (!____ptr).set_display_name_async = set_display_name_async
    (!____ptr).set_display_name_finish = set_display_name_finish
    (!____ptr).query_settable_attributes = query_settable_attributes
    (!____ptr)._query_settable_attributes_async = _query_settable_attributes_async
    (!____ptr)._query_settable_attributes_finish = _query_settable_attributes_finish
    (!____ptr).query_writable_namespaces = query_writable_namespaces
    (!____ptr)._query_writable_namespaces_async = _query_writable_namespaces_async
    (!____ptr)._query_writable_namespaces_finish = _query_writable_namespaces_finish
    (!____ptr).set_attribute = set_attribute
    (!____ptr).set_attributes_from_info = set_attributes_from_info
    (!____ptr).set_attributes_async = set_attributes_async
    (!____ptr).set_attributes_finish = set_attributes_finish
    (!____ptr).read_fn = read_fn
    (!____ptr).read_async = read_async
    (!____ptr).read_finish = read_finish
    (!____ptr).append_to = append_to
    (!____ptr).append_to_async = append_to_async
    (!____ptr).append_to_finish = append_to_finish
    (!____ptr).create = create
    (!____ptr).create_async = create_async
    (!____ptr).create_finish = create_finish
    (!____ptr).replace = replace
    (!____ptr).replace_async = replace_async
    (!____ptr).replace_finish = replace_finish
    (!____ptr).delete_file = delete_file
    (!____ptr).delete_file_async = delete_file_async
    (!____ptr).delete_file_finish = delete_file_finish
    (!____ptr).trash = trash
    (!____ptr).trash_async = trash_async
    (!____ptr).trash_finish = trash_finish
    (!____ptr).make_directory = make_directory
    (!____ptr).make_directory_async = make_directory_async
    (!____ptr).make_directory_finish = make_directory_finish
    (!____ptr).make_symbolic_link = make_symbolic_link
    (!____ptr).make_symbolic_link_async = make_symbolic_link_async
    (!____ptr).make_symbolic_link_finish = make_symbolic_link_finish
    (!____ptr).copy = copy
    (!____ptr).copy_async = copy_async
    (!____ptr).copy_finish = copy_finish
    (!____ptr).move = move
    (!____ptr).move_async = move_async
    (!____ptr).move_finish = move_finish
    (!____ptr).mount_mountable = mount_mountable
    (!____ptr).mount_mountable_finish = mount_mountable_finish
    (!____ptr).unmount_mountable = unmount_mountable
    (!____ptr).unmount_mountable_finish = unmount_mountable_finish
    (!____ptr).eject_mountable = eject_mountable
    (!____ptr).eject_mountable_finish = eject_mountable_finish
    (!____ptr).mount_enclosing_volume = mount_enclosing_volume
    (!____ptr).mount_enclosing_volume_finish = mount_enclosing_volume_finish
    (!____ptr).monitor_dir = monitor_dir
    (!____ptr).monitor_file = monitor_file
    (!____ptr).open_readwrite = open_readwrite
    (!____ptr).open_readwrite_async = open_readwrite_async
    (!____ptr).open_readwrite_finish = open_readwrite_finish
    (!____ptr).create_readwrite = create_readwrite
    (!____ptr).create_readwrite_async = create_readwrite_async
    (!____ptr).create_readwrite_finish = create_readwrite_finish
    (!____ptr).replace_readwrite = replace_readwrite
    (!____ptr).replace_readwrite_async = replace_readwrite_async
    (!____ptr).replace_readwrite_finish = replace_readwrite_finish
    (!____ptr).start_mountable = start_mountable
    (!____ptr).start_mountable_finish = start_mountable_finish
    (!____ptr).stop_mountable = stop_mountable
    (!____ptr).stop_mountable_finish = stop_mountable_finish
    (!____ptr).supports_thread_contexts = supports_thread_contexts
    (!____ptr).unmount_mountable_with_operation = unmount_mountable_with_operation
    (!____ptr).unmount_mountable_with_operation_finish = unmount_mountable_with_operation_finish
    (!____ptr).eject_mountable_with_operation = eject_mountable_with_operation
    (!____ptr).eject_mountable_with_operation_finish = eject_mountable_with_operation_finish
    (!____ptr).poll_mountable = poll_mountable
    (!____ptr).poll_mountable_finish = poll_mountable_finish
    (!____ptr).measure_disk_usage = measure_disk_usage
    (!____ptr).measure_disk_usage_async = measure_disk_usage_async
    (!____ptr).measure_disk_usage_finish = measure_disk_usage_finish
    ____ptr
  extension (struct: GFileIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def dup: CFuncPtr1[Ptr[GFile], Ptr[GFile]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]]
    def dup_=(value: CFuncPtr1[Ptr[GFile], Ptr[GFile]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]] = value
    def hash: CFuncPtr1[Ptr[GFile], _root_.glib.guint] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.guint]]]
    def hash_=(value: CFuncPtr1[Ptr[GFile], _root_.glib.guint]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.guint]]] = value
    def equal: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]]
    def equal_=(value: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]] = value
    def is_native: CFuncPtr1[Ptr[GFile], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]]]
    def is_native_=(value: CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]]] = value
    def has_uri_scheme: CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]]]
    def has_uri_scheme_=(value: CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]]] = value
    def get_uri_scheme: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_uri_scheme_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_basename: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_basename_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_path: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_path_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_uri: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_uri_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_parse_name: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_parse_name_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_parent: CFuncPtr1[Ptr[GFile], Ptr[GFile]] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]]
    def get_parent_=(value: CFuncPtr1[Ptr[GFile], Ptr[GFile]]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]] = value
    def prefix_matches: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]]
    def prefix_matches_=(value: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]] = value
    def get_relative_path: CFuncPtr2[Ptr[GFile], Ptr[GFile], CString] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]]]
    def get_relative_path_=(value: CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]]] = value
    def resolve_relative_path: CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]]]
    def resolve_relative_path_=(value: CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]]] = value
    def get_child_for_display_name: CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def get_child_for_display_name_=(value: CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def enumerate_children: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]]
    def enumerate_children_=(value: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]] = value
    def enumerate_children_async: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def enumerate_children_async_=(value: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def enumerate_children_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]]
    def enumerate_children_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]] = value
    def query_info: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_=(value: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_info_async: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_info_async_=(value: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_info_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_filesystem_info: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_filesystem_info_=(value: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_filesystem_info_async: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_filesystem_info_async_=(value: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_filesystem_info_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_filesystem_info_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def find_enclosing_mount: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]]
    def find_enclosing_mount_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]] = value
    def find_enclosing_mount_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def find_enclosing_mount_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def find_enclosing_mount_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]] = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]]
    def find_enclosing_mount_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]): Unit = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]] = value
    def set_display_name: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def set_display_name_=(value: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def set_display_name_async: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def set_display_name_async_=(value: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def set_display_name_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def set_display_name_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def query_settable_attributes: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]] = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]]
    def query_settable_attributes_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]): Unit = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]] = value
    def _query_settable_attributes_async: CFuncPtr0[Unit] = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_settable_attributes_async_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _query_settable_attributes_finish: CFuncPtr0[Unit] = !struct.at(offsets(33)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_settable_attributes_finish_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(33)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def query_writable_namespaces: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]] = !struct.at(offsets(34)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]]
    def query_writable_namespaces_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]): Unit = !struct.at(offsets(34)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]] = value
    def _query_writable_namespaces_async: CFuncPtr0[Unit] = !struct.at(offsets(35)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_writable_namespaces_async_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(35)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _query_writable_namespaces_finish: CFuncPtr0[Unit] = !struct.at(offsets(36)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_writable_namespaces_finish_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(36)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def set_attribute: CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(37)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_attribute_=(value: CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(37)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_attributes_from_info: CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(38)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_attributes_from_info_=(value: CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(38)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_attributes_async: CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(39)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def set_attributes_async_=(value: CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(39)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def set_attributes_finish: CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(40)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_attributes_finish_=(value: CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(40)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def read_fn: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]] = !struct.at(offsets(41)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]]
    def read_fn_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]): Unit = !struct.at(offsets(41)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]] = value
    def read_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(42)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def read_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(42)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def read_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]] = !struct.at(offsets(43)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]]
    def read_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]): Unit = !struct.at(offsets(43)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]] = value
    def append_to: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(44)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def append_to_=(value: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(44)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def append_to_async: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(45)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def append_to_async_=(value: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(45)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def append_to_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(46)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def append_to_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(46)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def create: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(47)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def create_=(value: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(47)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def create_async: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(48)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def create_async_=(value: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(48)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def create_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(49)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def create_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(49)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def replace: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(50)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def replace_=(value: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(50)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def replace_async: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(51)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def replace_async_=(value: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(51)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def replace_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(52)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def replace_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(52)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def delete_file: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(53)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def delete_file_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(53)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def delete_file_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(54)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def delete_file_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(54)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def delete_file_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(55)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def delete_file_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(55)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def trash: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(56)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def trash_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(56)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def trash_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(57)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def trash_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(57)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def trash_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(58)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def trash_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(58)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_directory: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(59)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_directory_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(59)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_directory_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(60)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def make_directory_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(60)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def make_directory_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(61)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_directory_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(61)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_symbolic_link: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(62)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_symbolic_link_=(value: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(62)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_symbolic_link_async: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(63)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def make_symbolic_link_async_=(value: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(63)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def make_symbolic_link_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(64)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_symbolic_link_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(64)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def copy: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(65)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def copy_=(value: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(65)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def copy_async: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(66)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def copy_async_=(value: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(66)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def copy_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(67)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def copy_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(67)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def move: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(68)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def move_=(value: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(68)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def move_async: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(69)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def move_async_=(value: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(69)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def move_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(70)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def move_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(70)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def mount_mountable: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(71)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def mount_mountable_=(value: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(71)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def mount_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(72)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def mount_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(72)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def unmount_mountable: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(73)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_mountable_=(value: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(73)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(74)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(74)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject_mountable: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(75)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_mountable_=(value: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(75)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(76)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(76)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def mount_enclosing_volume: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(77)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def mount_enclosing_volume_=(value: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(77)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def mount_enclosing_volume_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(78)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def mount_enclosing_volume_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(78)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def monitor_dir: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]] = !struct.at(offsets(79)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]]
    def monitor_dir_=(value: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]): Unit = !struct.at(offsets(79)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]] = value
    def monitor_file: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]] = !struct.at(offsets(80)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]]
    def monitor_file_=(value: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]): Unit = !struct.at(offsets(80)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]] = value
    def open_readwrite: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(81)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def open_readwrite_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(81)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def open_readwrite_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(82)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def open_readwrite_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(82)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def open_readwrite_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(83)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def open_readwrite_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(83)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def create_readwrite: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(84)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def create_readwrite_=(value: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(84)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def create_readwrite_async: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(85)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def create_readwrite_async_=(value: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(85)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def create_readwrite_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(86)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def create_readwrite_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(86)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def replace_readwrite: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(87)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def replace_readwrite_=(value: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(87)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def replace_readwrite_async: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(88)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def replace_readwrite_async_=(value: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(88)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def replace_readwrite_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(89)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def replace_readwrite_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(89)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def start_mountable: CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(90)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def start_mountable_=(value: CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(90)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def start_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(91)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def start_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(91)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def stop_mountable: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(92)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def stop_mountable_=(value: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(92)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def stop_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(93)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def stop_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(93)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def supports_thread_contexts: _root_.glib.gboolean = !struct.at(offsets(94)).asInstanceOf[Ptr[_root_.glib.gboolean]]
    def supports_thread_contexts_=(value: _root_.glib.gboolean): Unit = !struct.at(offsets(94)).asInstanceOf[Ptr[_root_.glib.gboolean]] = value
    def unmount_mountable_with_operation: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(95)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_mountable_with_operation_=(value: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(95)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_mountable_with_operation_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(96)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_mountable_with_operation_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(96)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject_mountable_with_operation: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(97)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_mountable_with_operation_=(value: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(97)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_mountable_with_operation_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(98)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_mountable_with_operation_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(98)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def poll_mountable: CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(99)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def poll_mountable_=(value: CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(99)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def poll_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(100)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def poll_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(100)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def measure_disk_usage: CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(101)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def measure_disk_usage_=(value: CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(101)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def measure_disk_usage_async: CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(102)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def measure_disk_usage_async_=(value: CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(102)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def measure_disk_usage_finish: CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(103)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def measure_disk_usage_finish_=(value: CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(103)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](104)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], _root_.glib.guint]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GFile], _root_.glib.guint]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt)
    res(26) = align(res(25) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(27) = align(res(26) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt)
    res(28) = align(res(27) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(29) = align(res(28) + sizeof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(30) = align(res(29) + sizeof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(31) = align(res(30) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt)
    res(32) = align(res(31) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(33) = align(res(32) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(34) = align(res(33) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt)
    res(35) = align(res(34) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(36) = align(res(35) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(37) = align(res(36) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(38) = align(res(37) + sizeof[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(39) = align(res(38) + sizeof[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(40) = align(res(39) + sizeof[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(41) = align(res(40) + sizeof[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt)
    res(42) = align(res(41) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(43) = align(res(42) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt)
    res(44) = align(res(43) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(45) = align(res(44) + sizeof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(46) = align(res(45) + sizeof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(47) = align(res(46) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(48) = align(res(47) + sizeof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(49) = align(res(48) + sizeof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(50) = align(res(49) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(51) = align(res(50) + sizeof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(52) = align(res(51) + sizeof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(53) = align(res(52) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(54) = align(res(53) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(55) = align(res(54) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(56) = align(res(55) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(57) = align(res(56) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(58) = align(res(57) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(59) = align(res(58) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(60) = align(res(59) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(61) = align(res(60) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(62) = align(res(61) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(63) = align(res(62) + sizeof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(64) = align(res(63) + sizeof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(65) = align(res(64) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(66) = align(res(65) + sizeof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(67) = align(res(66) + sizeof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(68) = align(res(67) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(69) = align(res(68) + sizeof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(70) = align(res(69) + sizeof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(71) = align(res(70) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(72) = align(res(71) + sizeof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(73) = align(res(72) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(74) = align(res(73) + sizeof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(75) = align(res(74) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(76) = align(res(75) + sizeof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(77) = align(res(76) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(78) = align(res(77) + sizeof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(79) = align(res(78) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt)
    res(80) = align(res(79) + sizeof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt)
    res(81) = align(res(80) + sizeof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(82) = align(res(81) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(83) = align(res(82) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(84) = align(res(83) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(85) = align(res(84) + sizeof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(86) = align(res(85) + sizeof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(87) = align(res(86) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(88) = align(res(87) + sizeof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(89) = align(res(88) + sizeof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(90) = align(res(89) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(91) = align(res(90) + sizeof[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(92) = align(res(91) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(93) = align(res(92) + sizeof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(94) = align(res(93) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gboolean].toInt)
    res(95) = align(res(94) + sizeof[_root_.glib.gboolean].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(96) = align(res(95) + sizeof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(97) = align(res(96) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(98) = align(res(97) + sizeof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(99) = align(res(98) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(100) = align(res(99) + sizeof[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(101) = align(res(100) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(102) = align(res(101) + sizeof[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(103) = align(res(102) + sizeof[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GFileInfo = CStruct0
object GFileInfo:
  given _tag: Tag[GFileInfo] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinfo.h
*/
opaque type GFileInfoClass = CStruct0
object GFileInfoClass:
  given _tag: Tag[GFileInfoClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinputstream.h
*/
opaque type GFileInputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GFileInputStream:
  given _tag: Tag[GFileInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFileInputStream] = scala.scalanative.unsafe.alloc[GFileInputStream](1)
  def apply(parent_instance : GInputStream, priv : Ptr[GFileInputStreamPrivate])(using Zone): Ptr[GFileInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GFileInputStream)
    def parent_instance: GInputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStream]]
    def parent_instance_=(value: GInputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStream]] = value
    def priv: Ptr[GFileInputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileInputStreamPrivate]]]
    def priv_=(value: Ptr[GFileInputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileInputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInputStream].toInt)
    res(1) = align(res(0) + sizeof[GInputStream].toInt, alignmentof[Ptr[GFileInputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinputstream.h
*/
opaque type GFileInputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]]
object GFileInputStreamClass:
  given _tag: Tag[GFileInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._3, Nat._6](Tag.Nat3, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GFileInputStreamClass] = scala.scalanative.unsafe.alloc[GFileInputStreamClass](1)
  def apply(parent_class : GInputStreamClass, tell : CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], query_info : CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GFileInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GFileInputStreamClass)
    def parent_class: GInputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStreamClass]]
    def parent_class_=(value: GInputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStreamClass]] = value
    def tell: CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset]]]
    def tell_=(value: CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset]]] = value
    def can_seek: CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean]]]
    def can_seek_=(value: CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean]]] = value
    def seek: CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def seek_=(value: CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def query_info: CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_=(value: CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_info_async: CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_info_async_=(value: CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_info_finish: CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](12)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GInputStreamClass].toInt, alignmentof[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset]].toInt, alignmentof[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinputstream.h
*/
opaque type GFileInputStreamPrivate = CStruct0
object GFileInputStreamPrivate:
  given _tag: Tag[GFileInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilemonitor.h
*/
opaque type GFileMonitor = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GFileMonitor:
  given _tag: Tag[GFileMonitor] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GFileMonitor] = scala.scalanative.unsafe.alloc[GFileMonitor](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GFileMonitorPrivate])(using Zone): Ptr[GFileMonitor] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GFileMonitor)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GFileMonitorPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileMonitorPrivate]]]
    def priv_=(value: Ptr[GFileMonitorPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileMonitorPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GFileMonitorPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilemonitor.h
*/
opaque type GFileMonitorClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._9, Nat._2]]
object GFileMonitorClass:
  given _tag: Tag[GFileMonitorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._9, Nat._2]](Tag.Byte, Tag.Digit3[Nat._1, Nat._9, Nat._2](Tag.Nat1, Tag.Nat9, Tag.Nat2))
  def apply()(using Zone): Ptr[GFileMonitorClass] = scala.scalanative.unsafe.alloc[GFileMonitorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, changed : CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit], cancel : CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GFileMonitorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).changed = changed
    (!____ptr).cancel = cancel
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GFileMonitorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def changed: CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit]]]
    def changed_=(value: CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit]]] = value
    def cancel: CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean]]]
    def cancel_=(value: CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilemonitor.h
*/
opaque type GFileMonitorPrivate = CStruct0
object GFileMonitorPrivate:
  given _tag: Tag[GFileMonitorPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileoutputstream.h
*/
opaque type GFileOutputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GFileOutputStream:
  given _tag: Tag[GFileOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFileOutputStream] = scala.scalanative.unsafe.alloc[GFileOutputStream](1)
  def apply(parent_instance : GOutputStream, priv : Ptr[GFileOutputStreamPrivate])(using Zone): Ptr[GFileOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GFileOutputStream)
    def parent_instance: GOutputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStream]]
    def parent_instance_=(value: GOutputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStream]] = value
    def priv: Ptr[GFileOutputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileOutputStreamPrivate]]]
    def priv_=(value: Ptr[GFileOutputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GFileOutputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GOutputStream].toInt)
    res(1) = align(res(0) + sizeof[GOutputStream].toInt, alignmentof[Ptr[GFileOutputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileoutputstream.h
*/
opaque type GFileOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._4, Nat._0, Nat._8]]
object GFileOutputStreamClass:
  given _tag: Tag[GFileOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._4, Nat._0, Nat._8]](Tag.Byte, Tag.Digit3[Nat._4, Nat._0, Nat._8](Tag.Nat4, Tag.Nat0, Tag.Nat8))
  def apply()(using Zone): Ptr[GFileOutputStreamClass] = scala.scalanative.unsafe.alloc[GFileOutputStreamClass](1)
  def apply(parent_class : GOutputStreamClass, tell : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_truncate : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], truncate_fn : CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], query_info : CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], get_etag : CFuncPtr1[Ptr[GFileOutputStream], CString], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GFileOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).can_truncate = can_truncate
    (!____ptr).truncate_fn = truncate_fn
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr).get_etag = get_etag
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GFileOutputStreamClass)
    def parent_class: GOutputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStreamClass]]
    def parent_class_=(value: GOutputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStreamClass]] = value
    def tell: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset]]]
    def tell_=(value: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset]]] = value
    def can_seek: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]]]
    def can_seek_=(value: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]]] = value
    def seek: CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def seek_=(value: CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_truncate: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]]]
    def can_truncate_=(value: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]]] = value
    def truncate_fn: CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def truncate_fn_=(value: CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def query_info: CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_=(value: CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_info_async: CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_info_async_=(value: CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_info_finish: CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def get_etag: CFuncPtr1[Ptr[GFileOutputStream], CString] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], CString]]]
    def get_etag_=(value: CFuncPtr1[Ptr[GFileOutputStream], CString]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFileOutputStream], CString]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](15)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GOutputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GOutputStreamClass].toInt, alignmentof[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset]].toInt, alignmentof[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr1[Ptr[GFileOutputStream], CString]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GFileOutputStream], CString]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileoutputstream.h
*/
opaque type GFileOutputStreamPrivate = CStruct0
object GFileOutputStreamPrivate:
  given _tag: Tag[GFileOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GFilenameCompleter = CStruct0
object GFilenameCompleter:
  given _tag: Tag[GFilenameCompleter] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilenamecompleter.h
*/
opaque type GFilenameCompleterClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._8]]
object GFilenameCompleterClass:
  given _tag: Tag[GFilenameCompleterClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._8]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._8](Tag.Nat1, Tag.Nat6, Tag.Nat8))
  def apply()(using Zone): Ptr[GFilenameCompleterClass] = scala.scalanative.unsafe.alloc[GFilenameCompleterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, got_completion_data : CFuncPtr1[Ptr[GFilenameCompleter], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[GFilenameCompleterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).got_completion_data = got_completion_data
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: GFilenameCompleterClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def got_completion_data: CFuncPtr1[Ptr[GFilenameCompleter], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFilenameCompleter], Unit]]]
    def got_completion_data_=(value: CFuncPtr1[Ptr[GFilenameCompleter], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFilenameCompleter], Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GFilenameCompleter], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GFilenameCompleter], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilterinputstream.h
*/
opaque type GFilterInputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GFilterInputStream:
  given _tag: Tag[GFilterInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFilterInputStream] = scala.scalanative.unsafe.alloc[GFilterInputStream](1)
  def apply(parent_instance : GInputStream, base_stream : Ptr[GInputStream])(using Zone): Ptr[GFilterInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).base_stream = base_stream
    ____ptr
  extension (struct: GFilterInputStream)
    def parent_instance: GInputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStream]]
    def parent_instance_=(value: GInputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStream]] = value
    def base_stream: Ptr[GInputStream] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInputStream]]]
    def base_stream_=(value: Ptr[GInputStream]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInputStream]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInputStream].toInt)
    res(1) = align(res(0) + sizeof[GInputStream].toInt, alignmentof[Ptr[GInputStream]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilterinputstream.h
*/
opaque type GFilterInputStreamClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]]
object GFilterInputStreamClass:
  given _tag: Tag[GFilterInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._7, Nat._2](Tag.Nat2, Tag.Nat7, Tag.Nat2))
  def apply()(using Zone): Ptr[GFilterInputStreamClass] = scala.scalanative.unsafe.alloc[GFilterInputStreamClass](1)
  def apply(parent_class : GInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[GFilterInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: GFilterInputStreamClass)
    def parent_class: GInputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStreamClass]]
    def parent_class_=(value: GInputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GInputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilteroutputstream.h
*/
opaque type GFilterOutputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GFilterOutputStream:
  given _tag: Tag[GFilterOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GFilterOutputStream] = scala.scalanative.unsafe.alloc[GFilterOutputStream](1)
  def apply(parent_instance : GOutputStream, base_stream : Ptr[GOutputStream])(using Zone): Ptr[GFilterOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).base_stream = base_stream
    ____ptr
  extension (struct: GFilterOutputStream)
    def parent_instance: GOutputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStream]]
    def parent_instance_=(value: GOutputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStream]] = value
    def base_stream: Ptr[GOutputStream] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GOutputStream]]]
    def base_stream_=(value: Ptr[GOutputStream]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GOutputStream]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GOutputStream].toInt)
    res(1) = align(res(0) + sizeof[GOutputStream].toInt, alignmentof[Ptr[GOutputStream]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilteroutputstream.h
*/
opaque type GFilterOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._2, Nat._0]]
object GFilterOutputStreamClass:
  given _tag: Tag[GFilterOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._2, Nat._0]](Tag.Byte, Tag.Digit3[Nat._3, Nat._2, Nat._0](Tag.Nat3, Tag.Nat2, Tag.Nat0))
  def apply()(using Zone): Ptr[GFilterOutputStreamClass] = scala.scalanative.unsafe.alloc[GFilterOutputStreamClass](1)
  def apply(parent_class : GOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[GFilterOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: GFilterOutputStreamClass)
    def parent_class: GOutputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStreamClass]]
    def parent_class_=(value: GOutputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GOutputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GOutputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GIOExtension = CStruct0
object GIOExtension:
  given _tag: Tag[GIOExtension] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GIOExtensionPoint = CStruct0
object GIOExtensionPoint:
  given _tag: Tag[GIOExtensionPoint] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GIOModule = CStruct0
object GIOModule:
  given _tag: Tag[GIOModule] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giomodule.h
*/
opaque type GIOModuleClass = CStruct0
object GIOModuleClass:
  given _tag: Tag[GIOModuleClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giomodule.h
*/
opaque type GIOModuleScope = CStruct0
object GIOModuleScope:
  given _tag: Tag[GIOModuleScope] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GIOSchedulerJob = CStruct0
object GIOSchedulerJob:
  given _tag: Tag[GIOSchedulerJob] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giostream.h
*/
opaque type GIOStream = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GIOStream:
  given _tag: Tag[GIOStream] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GIOStream] = scala.scalanative.unsafe.alloc[GIOStream](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GIOStreamPrivate])(using Zone): Ptr[GIOStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GIOStream)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GIOStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GIOStreamPrivate]]]
    def priv_=(value: Ptr[GIOStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GIOStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GIOStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GIOStreamAdapter = CStruct0
object GIOStreamAdapter:
  given _tag: Tag[GIOStreamAdapter] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giostream.h
*/
opaque type GIOStreamClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._5, Nat._6]]
object GIOStreamClass:
  given _tag: Tag[GIOStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._5, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._5, Nat._6](Tag.Nat2, Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GIOStreamClass] = scala.scalanative.unsafe.alloc[GIOStreamClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_input_stream : CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]], get_output_stream : CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]], close_fn : CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], close_async : CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit], _g_reserved9 : CFuncPtr0[Unit], _g_reserved10 : CFuncPtr0[Unit])(using Zone): Ptr[GIOStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_input_stream = get_input_stream
    (!____ptr).get_output_stream = get_output_stream
    (!____ptr).close_fn = close_fn
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    (!____ptr)._g_reserved9 = _g_reserved9
    (!____ptr)._g_reserved10 = _g_reserved10
    ____ptr
  extension (struct: GIOStreamClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_input_stream: CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]]]]
    def get_input_stream_=(value: CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]]]] = value
    def get_output_stream: CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]]]]
    def get_output_stream_=(value: CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]]]] = value
    def close_fn: CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_fn_=(value: CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def close_async: CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def close_async_=(value: CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def close_finish: CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_finish_=(value: CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved7: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved8: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved9: CFuncPtr0[Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved9_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved10: CFuncPtr0[Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved10_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](16)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]]].toInt, alignmentof[CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]]].toInt, alignmentof[CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giostream.h
*/
opaque type GIOStreamPrivate = CStruct0
object GIOStreamPrivate:
  given _tag: Tag[GIOStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GIcon = CStruct0
object GIcon:
  given _tag: Tag[GIcon] = Tag.materializeCStruct0Tag

/**
 * GIconIface: _iface: The parent interface. : A hash for a given #GIcon. : Checks if two #GIcons are equal. _tokens: Serializes a #GIcon into tokens. The tokens must not contain any whitespace. Don't implement if the #GIcon can't be serialized (Since 2.20). _tokens: Constructs a #GIcon from tokens. Set the #GError if the tokens are malformed. Don't implement if the #GIcon can't be serialized (Since 2.20). : Serializes a #GIcon into a #GVariant. Since: 2.38

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gicon.h
*/
opaque type GIconIface = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GIconIface:
  given _tag: Tag[GIconIface] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GIconIface] = scala.scalanative.unsafe.alloc[GIconIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, hash : CFuncPtr1[Ptr[GIcon], _root_.glib.guint], equal : CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean], to_tokens : CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean], from_tokens : CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]], serialize : CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]])(using Zone): Ptr[GIconIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).hash = hash
    (!____ptr).equal = equal
    (!____ptr).to_tokens = to_tokens
    (!____ptr).from_tokens = from_tokens
    (!____ptr).serialize = serialize
    ____ptr
  extension (struct: GIconIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def hash: CFuncPtr1[Ptr[GIcon], _root_.glib.guint] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIcon], _root_.glib.guint]]]
    def hash_=(value: CFuncPtr1[Ptr[GIcon], _root_.glib.guint]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIcon], _root_.glib.guint]]] = value
    def equal: CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean]]]
    def equal_=(value: CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean]]] = value
    def to_tokens: CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean]]]
    def to_tokens_=(value: CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean]]] = value
    def from_tokens: CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]]]]
    def from_tokens_=(value: CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]]]] = value
    def serialize: CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]]]
    def serialize_=(value: CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GIcon], _root_.glib.guint]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GIcon], _root_.glib.guint]].toInt, alignmentof[CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddress.h
*/
opaque type GInetAddress = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GInetAddress:
  given _tag: Tag[GInetAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GInetAddress] = scala.scalanative.unsafe.alloc[GInetAddress](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GInetAddressPrivate])(using Zone): Ptr[GInetAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GInetAddress)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GInetAddressPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInetAddressPrivate]]]
    def priv_=(value: Ptr[GInetAddressPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInetAddressPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GInetAddressPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddress.h
*/
opaque type GInetAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._5, Nat._2]]
object GInetAddressClass:
  given _tag: Tag[GInetAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._5, Nat._2]](Tag.Byte, Tag.Digit3[Nat._1, Nat._5, Nat._2](Tag.Nat1, Tag.Nat5, Tag.Nat2))
  def apply()(using Zone): Ptr[GInetAddressClass] = scala.scalanative.unsafe.alloc[GInetAddressClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, to_string : CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]], to_bytes : CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]])(using Zone): Ptr[GInetAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).to_string = to_string
    (!____ptr).to_bytes = to_bytes
    ____ptr
  extension (struct: GInetAddressClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def to_string: CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]]]]
    def to_string_=(value: CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]]]] = value
    def to_bytes: CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]]]
    def to_bytes_=(value: CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddressmask.h
*/
opaque type GInetAddressMask = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GInetAddressMask:
  given _tag: Tag[GInetAddressMask] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GInetAddressMask] = scala.scalanative.unsafe.alloc[GInetAddressMask](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GInetAddressMaskPrivate])(using Zone): Ptr[GInetAddressMask] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GInetAddressMask)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GInetAddressMaskPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInetAddressMaskPrivate]]]
    def priv_=(value: Ptr[GInetAddressMaskPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInetAddressMaskPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GInetAddressMaskPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddressmask.h
*/
opaque type GInetAddressMaskClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GInetAddressMaskClass:
  given _tag: Tag[GInetAddressMaskClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GInetAddressMaskClass] = scala.scalanative.unsafe.alloc[GInetAddressMaskClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GInetAddressMaskClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GInetAddressMaskClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddressmask.h
*/
opaque type GInetAddressMaskPrivate = CStruct0
object GInetAddressMaskPrivate:
  given _tag: Tag[GInetAddressMaskPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddress.h
*/
opaque type GInetAddressPrivate = CStruct0
object GInetAddressPrivate:
  given _tag: Tag[GInetAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetsocketaddress.h
*/
opaque type GInetSocketAddress = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GInetSocketAddress:
  given _tag: Tag[GInetSocketAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GInetSocketAddress] = scala.scalanative.unsafe.alloc[GInetSocketAddress](1)
  def apply(parent_instance : GSocketAddress, priv : Ptr[GInetSocketAddressPrivate])(using Zone): Ptr[GInetSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GInetSocketAddress)
    def parent_instance: GSocketAddress = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddress]]
    def parent_instance_=(value: GSocketAddress): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddress]] = value
    def priv: Ptr[GInetSocketAddressPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInetSocketAddressPrivate]]]
    def priv_=(value: Ptr[GInetSocketAddressPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInetSocketAddressPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddress].toInt)
    res(1) = align(res(0) + sizeof[GSocketAddress].toInt, alignmentof[Ptr[GInetSocketAddressPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetsocketaddress.h
*/
opaque type GInetSocketAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]]
object GInetSocketAddressClass:
  given _tag: Tag[GInetSocketAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._0](Tag.Nat1, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GInetSocketAddressClass] = scala.scalanative.unsafe.alloc[GInetSocketAddressClass](1)
  def apply(parent_class : GSocketAddressClass)(using Zone): Ptr[GInetSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GInetSocketAddressClass)
    def parent_class: GSocketAddressClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressClass]]
    def parent_class_=(value: GSocketAddressClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddressClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetsocketaddress.h
*/
opaque type GInetSocketAddressPrivate = CStruct0
object GInetSocketAddressPrivate:
  given _tag: Tag[GInetSocketAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GInitable = CStruct0
object GInitable:
  given _tag: Tag[GInitable] = Tag.materializeCStruct0Tag

/**
 * GInitableIface: _iface: The parent interface. : Initializes the object.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginitable.h
*/
opaque type GInitableIface = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GInitableIface:
  given _tag: Tag[GInitableIface] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GInitableIface] = scala.scalanative.unsafe.alloc[GInitableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, init : CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GInitableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).init = init
    ____ptr
  extension (struct: GInitableIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def init: CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def init_=(value: CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GInputMessage = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GInputMessage:
  given _tag: Tag[GInputMessage] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GInputMessage] = scala.scalanative.unsafe.alloc[GInputMessage](1)
  def apply(address : Ptr[Ptr[GSocketAddress]], vectors : Ptr[GInputVector], num_vectors : _root_.glib.guint, bytes_received : _root_.glib.gsize, flags : _root_.glib.gint, control_messages : Ptr[Ptr[Ptr[GSocketControlMessage]]], num_control_messages : Ptr[_root_.glib.guint])(using Zone): Ptr[GInputMessage] = 
    val ____ptr = apply()
    (!____ptr).address = address
    (!____ptr).vectors = vectors
    (!____ptr).num_vectors = num_vectors
    (!____ptr).bytes_received = bytes_received
    (!____ptr).flags = flags
    (!____ptr).control_messages = control_messages
    (!____ptr).num_control_messages = num_control_messages
    ____ptr
  extension (struct: GInputMessage)
    def address: Ptr[Ptr[GSocketAddress]] = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[Ptr[GSocketAddress]]]]
    def address_=(value: Ptr[Ptr[GSocketAddress]]): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[Ptr[GSocketAddress]]]] = value
    def vectors: Ptr[GInputVector] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInputVector]]]
    def vectors_=(value: Ptr[GInputVector]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInputVector]]] = value
    def num_vectors: _root_.glib.guint = !struct.at(offsets(2)).asInstanceOf[Ptr[_root_.glib.guint]]
    def num_vectors_=(value: _root_.glib.guint): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[_root_.glib.guint]] = value
    def bytes_received: _root_.glib.gsize = !struct.at(offsets(3)).asInstanceOf[Ptr[_root_.glib.gsize]]
    def bytes_received_=(value: _root_.glib.gsize): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[_root_.glib.gsize]] = value
    def flags: _root_.glib.gint = !struct.at(offsets(4)).asInstanceOf[Ptr[_root_.glib.gint]]
    def flags_=(value: _root_.glib.gint): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[_root_.glib.gint]] = value
    def control_messages: Ptr[Ptr[Ptr[GSocketControlMessage]]] = !struct.at(offsets(5)).asInstanceOf[Ptr[Ptr[Ptr[Ptr[GSocketControlMessage]]]]]
    def control_messages_=(value: Ptr[Ptr[Ptr[GSocketControlMessage]]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[Ptr[Ptr[Ptr[GSocketControlMessage]]]]] = value
    def num_control_messages: Ptr[_root_.glib.guint] = !struct.at(offsets(6)).asInstanceOf[Ptr[Ptr[_root_.glib.guint]]]
    def num_control_messages_=(value: Ptr[_root_.glib.guint]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[Ptr[_root_.glib.guint]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](7)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[Ptr[Ptr[GSocketAddress]]].toInt)
    res(1) = align(res(0) + sizeof[Ptr[Ptr[GSocketAddress]]].toInt, alignmentof[Ptr[GInputVector]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[GInputVector]].toInt, alignmentof[_root_.glib.guint].toInt)
    res(3) = align(res(2) + sizeof[_root_.glib.guint].toInt, alignmentof[_root_.glib.gsize].toInt)
    res(4) = align(res(3) + sizeof[_root_.glib.gsize].toInt, alignmentof[_root_.glib.gint].toInt)
    res(5) = align(res(4) + sizeof[_root_.glib.gint].toInt, alignmentof[Ptr[Ptr[Ptr[GSocketControlMessage]]]].toInt)
    res(6) = align(res(5) + sizeof[Ptr[Ptr[Ptr[GSocketControlMessage]]]].toInt, alignmentof[Ptr[_root_.glib.guint]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginputstream.h
*/
opaque type GInputStream = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GInputStream:
  given _tag: Tag[GInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GInputStream] = scala.scalanative.unsafe.alloc[GInputStream](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GInputStreamPrivate])(using Zone): Ptr[GInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GInputStream)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GInputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInputStreamPrivate]]]
    def priv_=(value: Ptr[GInputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GInputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GInputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginputstream.h
*/
opaque type GInputStreamClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._8]]
object GInputStreamClass:
  given _tag: Tag[GInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._8]](Tag.Byte, Tag.Digit3[Nat._2, Nat._4, Nat._8](Tag.Nat2, Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GInputStreamClass] = scala.scalanative.unsafe.alloc[GInputStreamClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, read_fn : CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], skip : CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], close_fn : CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], read_async : CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], read_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], skip_async : CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], skip_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], close_async : CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).read_fn = read_fn
    (!____ptr).skip = skip
    (!____ptr).close_fn = close_fn
    (!____ptr).read_async = read_async
    (!____ptr).read_finish = read_finish
    (!____ptr).skip_async = skip_async
    (!____ptr).skip_finish = skip_finish
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GInputStreamClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def read_fn: CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def read_fn_=(value: CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def skip: CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def skip_=(value: CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def close_fn: CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_fn_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def read_async: CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def read_async_=(value: CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def read_finish: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def read_finish_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def skip_async: CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def skip_async_=(value: CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def skip_finish: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def skip_finish_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def close_async: CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def close_async_=(value: CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def close_finish: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_finish_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](15)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginputstream.h
*/
opaque type GInputStreamPrivate = CStruct0
object GInputStreamPrivate:
  given _tag: Tag[GInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GInputVector = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GInputVector:
  given _tag: Tag[GInputVector] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GInputVector] = scala.scalanative.unsafe.alloc[GInputVector](1)
  def apply(buffer : _root_.glib.gpointer, size : _root_.glib.gsize)(using Zone): Ptr[GInputVector] = 
    val ____ptr = apply()
    (!____ptr).buffer = buffer
    (!____ptr).size = size
    ____ptr
  extension (struct: GInputVector)
    def buffer: _root_.glib.gpointer = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gpointer]]
    def buffer_=(value: _root_.glib.gpointer): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gpointer]] = value
    def size: _root_.glib.gsize = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gsize]]
    def size_=(value: _root_.glib.gsize): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gsize]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gpointer].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gpointer].toInt, alignmentof[_root_.glib.gsize].toInt)
    res
  end offsets

opaque type GListModel = CStruct0
object GListModel:
  given _tag: Tag[GListModel] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/glistmodel.h
*/
opaque type GListModelInterface = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GListModelInterface:
  given _tag: Tag[GListModelInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GListModelInterface] = scala.scalanative.unsafe.alloc[GListModelInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, get_item_type : CFuncPtr1[Ptr[GListModel], _root_.gobject.GType], get_n_items : CFuncPtr1[Ptr[GListModel], _root_.glib.guint], get_item : CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer])(using Zone): Ptr[GListModelInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).get_item_type = get_item_type
    (!____ptr).get_n_items = get_n_items
    (!____ptr).get_item = get_item
    ____ptr
  extension (struct: GListModelInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def get_item_type: CFuncPtr1[Ptr[GListModel], _root_.gobject.GType] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GListModel], _root_.gobject.GType]]]
    def get_item_type_=(value: CFuncPtr1[Ptr[GListModel], _root_.gobject.GType]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GListModel], _root_.gobject.GType]]] = value
    def get_n_items: CFuncPtr1[Ptr[GListModel], _root_.glib.guint] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GListModel], _root_.glib.guint]]]
    def get_n_items_=(value: CFuncPtr1[Ptr[GListModel], _root_.glib.guint]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GListModel], _root_.glib.guint]]] = value
    def get_item: CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]]]
    def get_item_=(value: CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GListModel], _root_.gobject.GType]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GListModel], _root_.gobject.GType]].toInt, alignmentof[CFuncPtr1[Ptr[GListModel], _root_.glib.guint]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GListModel], _root_.glib.guint]].toInt, alignmentof[CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]].toInt)
    res
  end offsets

opaque type GListStore = CStruct0
object GListStore:
  given _tag: Tag[GListStore] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GLoadableIcon = CStruct0
object GLoadableIcon:
  given _tag: Tag[GLoadableIcon] = Tag.materializeCStruct0Tag

/**
 * GLoadableIconIface: _iface: The parent interface. : Loads an icon. _async: Loads an icon asynchronously. _finish: Finishes an asynchronous icon load.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gloadableicon.h
*/
opaque type GLoadableIconIface = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GLoadableIconIface:
  given _tag: Tag[GLoadableIconIface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GLoadableIconIface] = scala.scalanative.unsafe.alloc[GLoadableIconIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, load : CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]], load_async : CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], load_finish : CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]])(using Zone): Ptr[GLoadableIconIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).load = load
    (!____ptr).load_async = load_async
    (!____ptr).load_finish = load_finish
    ____ptr
  extension (struct: GLoadableIconIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def load: CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]]]
    def load_=(value: CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]]] = value
    def load_async: CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def load_async_=(value: CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def load_finish: CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]]]
    def load_finish_=(value: CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]].toInt, alignmentof[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryinputstream.h
*/
opaque type GMemoryInputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GMemoryInputStream:
  given _tag: Tag[GMemoryInputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GMemoryInputStream] = scala.scalanative.unsafe.alloc[GMemoryInputStream](1)
  def apply(parent_instance : GInputStream, priv : Ptr[GMemoryInputStreamPrivate])(using Zone): Ptr[GMemoryInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GMemoryInputStream)
    def parent_instance: GInputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStream]]
    def parent_instance_=(value: GInputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStream]] = value
    def priv: Ptr[GMemoryInputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMemoryInputStreamPrivate]]]
    def priv_=(value: Ptr[GMemoryInputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMemoryInputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInputStream].toInt)
    res(1) = align(res(0) + sizeof[GInputStream].toInt, alignmentof[Ptr[GMemoryInputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryinputstream.h
*/
opaque type GMemoryInputStreamClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._8, Nat._8]]
object GMemoryInputStreamClass:
  given _tag: Tag[GMemoryInputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._8, Nat._8]](Tag.Byte, Tag.Digit3[Nat._2, Nat._8, Nat._8](Tag.Nat2, Tag.Nat8, Tag.Nat8))
  def apply()(using Zone): Ptr[GMemoryInputStreamClass] = scala.scalanative.unsafe.alloc[GMemoryInputStreamClass](1)
  def apply(parent_class : GInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GMemoryInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GMemoryInputStreamClass)
    def parent_class: GInputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStreamClass]]
    def parent_class_=(value: GInputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GInputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryinputstream.h
*/
opaque type GMemoryInputStreamPrivate = CStruct0
object GMemoryInputStreamPrivate:
  given _tag: Tag[GMemoryInputStreamPrivate] = Tag.materializeCStruct0Tag

opaque type GMemoryMonitor = CStruct0
object GMemoryMonitor:
  given _tag: Tag[GMemoryMonitor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemorymonitor.h
*/
opaque type GMemoryMonitorInterface = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GMemoryMonitorInterface:
  given _tag: Tag[GMemoryMonitorInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GMemoryMonitorInterface] = scala.scalanative.unsafe.alloc[GMemoryMonitorInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, low_memory_warning : CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit])(using Zone): Ptr[GMemoryMonitorInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).low_memory_warning = low_memory_warning
    ____ptr
  extension (struct: GMemoryMonitorInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def low_memory_warning: CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]]]
    def low_memory_warning_=(value: CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryoutputstream.h
*/
opaque type GMemoryOutputStream = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GMemoryOutputStream:
  given _tag: Tag[GMemoryOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GMemoryOutputStream] = scala.scalanative.unsafe.alloc[GMemoryOutputStream](1)
  def apply(parent_instance : GOutputStream, priv : Ptr[GMemoryOutputStreamPrivate])(using Zone): Ptr[GMemoryOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GMemoryOutputStream)
    def parent_instance: GOutputStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStream]]
    def parent_instance_=(value: GOutputStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStream]] = value
    def priv: Ptr[GMemoryOutputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMemoryOutputStreamPrivate]]]
    def priv_=(value: Ptr[GMemoryOutputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMemoryOutputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GOutputStream].toInt)
    res(1) = align(res(0) + sizeof[GOutputStream].toInt, alignmentof[Ptr[GMemoryOutputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryoutputstream.h
*/
opaque type GMemoryOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]]
object GMemoryOutputStreamClass:
  given _tag: Tag[GMemoryOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._3, Nat._6](Tag.Nat3, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GMemoryOutputStreamClass] = scala.scalanative.unsafe.alloc[GMemoryOutputStreamClass](1)
  def apply(parent_class : GOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GMemoryOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GMemoryOutputStreamClass)
    def parent_class: GOutputStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStreamClass]]
    def parent_class_=(value: GOutputStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GOutputStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GOutputStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GOutputStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryoutputstream.h
*/
opaque type GMemoryOutputStreamPrivate = CStruct0
object GMemoryOutputStreamPrivate:
  given _tag: Tag[GMemoryOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenu.h
*/
opaque type GMenu = CStruct0
object GMenu:
  given _tag: Tag[GMenu] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuAttributeIter = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GMenuAttributeIter:
  given _tag: Tag[GMenuAttributeIter] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GMenuAttributeIter] = scala.scalanative.unsafe.alloc[GMenuAttributeIter](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMenuAttributeIterPrivate])(using Zone): Ptr[GMenuAttributeIter] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GMenuAttributeIter)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GMenuAttributeIterPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMenuAttributeIterPrivate]]]
    def priv_=(value: Ptr[GMenuAttributeIterPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMenuAttributeIterPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GMenuAttributeIterPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuAttributeIterClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._4, Nat._4]]
object GMenuAttributeIterClass:
  given _tag: Tag[GMenuAttributeIterClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._4, Nat._4]](Tag.Byte, Tag.Digit3[Nat._1, Nat._4, Nat._4](Tag.Nat1, Tag.Nat4, Tag.Nat4))
  def apply()(using Zone): Ptr[GMenuAttributeIterClass] = scala.scalanative.unsafe.alloc[GMenuAttributeIterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_next : CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean])(using Zone): Ptr[GMenuAttributeIterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_next = get_next
    ____ptr
  extension (struct: GMenuAttributeIterClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_next: CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]]
    def get_next_=(value: CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuAttributeIterPrivate = CStruct0
object GMenuAttributeIterPrivate:
  given _tag: Tag[GMenuAttributeIterPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenu.h
*/
opaque type GMenuItem = CStruct0
object GMenuItem:
  given _tag: Tag[GMenuItem] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuLinkIter = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GMenuLinkIter:
  given _tag: Tag[GMenuLinkIter] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GMenuLinkIter] = scala.scalanative.unsafe.alloc[GMenuLinkIter](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMenuLinkIterPrivate])(using Zone): Ptr[GMenuLinkIter] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GMenuLinkIter)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GMenuLinkIterPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMenuLinkIterPrivate]]]
    def priv_=(value: Ptr[GMenuLinkIterPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMenuLinkIterPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GMenuLinkIterPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuLinkIterClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._4, Nat._4]]
object GMenuLinkIterClass:
  given _tag: Tag[GMenuLinkIterClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._4, Nat._4]](Tag.Byte, Tag.Digit3[Nat._1, Nat._4, Nat._4](Tag.Nat1, Tag.Nat4, Tag.Nat4))
  def apply()(using Zone): Ptr[GMenuLinkIterClass] = scala.scalanative.unsafe.alloc[GMenuLinkIterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_next : CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean])(using Zone): Ptr[GMenuLinkIterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_next = get_next
    ____ptr
  extension (struct: GMenuLinkIterClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_next: CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]]]
    def get_next_=(value: CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuLinkIterPrivate = CStruct0
object GMenuLinkIterPrivate:
  given _tag: Tag[GMenuLinkIterPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuModel = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GMenuModel:
  given _tag: Tag[GMenuModel] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GMenuModel] = scala.scalanative.unsafe.alloc[GMenuModel](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMenuModelPrivate])(using Zone): Ptr[GMenuModel] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GMenuModel)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GMenuModelPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMenuModelPrivate]]]
    def priv_=(value: Ptr[GMenuModelPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMenuModelPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GMenuModelPrivate]].toInt)
    res
  end offsets

/**
 * GMenuModelClass::get_item_attributes: : the #GMenuModel to query _index: The #GMenuItem to query : (out) (element-type utf8 GLib.Variant): Attributes on the item

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuModelClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]]
object GMenuModelClass:
  given _tag: Tag[GMenuModelClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._0]](Tag.Byte, Tag.Digit3[Nat._2, Nat._0, Nat._0](Tag.Nat2, Tag.Nat0, Tag.Nat0))
  def apply()(using Zone): Ptr[GMenuModelClass] = scala.scalanative.unsafe.alloc[GMenuModelClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, is_mutable : CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean], get_n_items : CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint], get_item_attributes : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], iterate_item_attributes : CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]], get_item_attribute_value : CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]], get_item_links : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], iterate_item_links : CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]], get_item_link : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]])(using Zone): Ptr[GMenuModelClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).is_mutable = is_mutable
    (!____ptr).get_n_items = get_n_items
    (!____ptr).get_item_attributes = get_item_attributes
    (!____ptr).iterate_item_attributes = iterate_item_attributes
    (!____ptr).get_item_attribute_value = get_item_attribute_value
    (!____ptr).get_item_links = get_item_links
    (!____ptr).iterate_item_links = iterate_item_links
    (!____ptr).get_item_link = get_item_link
    ____ptr
  extension (struct: GMenuModelClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def is_mutable: CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean]]]
    def is_mutable_=(value: CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean]]] = value
    def get_n_items: CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint]]]
    def get_n_items_=(value: CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint]]] = value
    def get_item_attributes: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]]]
    def get_item_attributes_=(value: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]]] = value
    def iterate_item_attributes: CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]]]]
    def iterate_item_attributes_=(value: CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]]]] = value
    def get_item_attribute_value: CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]]]]
    def get_item_attribute_value_=(value: CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]]]] = value
    def get_item_links: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]]]
    def get_item_links_=(value: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]]] = value
    def iterate_item_links: CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]]]]
    def iterate_item_links_=(value: CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]]]] = value
    def get_item_link: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]]]
    def get_item_link_=(value: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](9)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint]].toInt, alignmentof[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]]].toInt, alignmentof[CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]]].toInt, alignmentof[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]]].toInt, alignmentof[CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type GMenuModelPrivate = CStruct0
object GMenuModelPrivate:
  given _tag: Tag[GMenuModelPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GMount = CStruct0
object GMount:
  given _tag: Tag[GMount] = Tag.materializeCStruct0Tag

/**
 * GMountIface: _iface: The parent interface. : Changed signal that is emitted when the mount's state has changed. : The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmount.h
*/
opaque type GMountIface = CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]]
object GMountIface:
  given _tag: Tag[GMountIface] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._3, Nat._2](Tag.Nat2, Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GMountIface] = scala.scalanative.unsafe.alloc[GMountIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, changed : CFuncPtr1[Ptr[GMount], Unit], unmounted : CFuncPtr1[Ptr[GMount], Unit], get_root : CFuncPtr1[Ptr[GMount], Ptr[GFile]], get_name : CFuncPtr1[Ptr[GMount], CString], get_icon : CFuncPtr1[Ptr[GMount], Ptr[GIcon]], get_uuid : CFuncPtr1[Ptr[GMount], CString], get_volume : CFuncPtr1[Ptr[GMount], Ptr[GVolume]], get_drive : CFuncPtr1[Ptr[GMount], Ptr[GDrive]], can_unmount : CFuncPtr1[Ptr[GMount], _root_.glib.gboolean], can_eject : CFuncPtr1[Ptr[GMount], _root_.glib.gboolean], unmount : CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject : CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], remount : CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], remount_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], guess_content_type : CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], guess_content_type_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], guess_content_type_sync : CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], pre_unmount : CFuncPtr1[Ptr[GMount], Unit], unmount_with_operation : CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_with_operation_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject_with_operation : CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_with_operation_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_default_location : CFuncPtr1[Ptr[GMount], Ptr[GFile]], get_sort_key : CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]], get_symbolic_icon : CFuncPtr1[Ptr[GMount], Ptr[GIcon]])(using Zone): Ptr[GMountIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).changed = changed
    (!____ptr).unmounted = unmounted
    (!____ptr).get_root = get_root
    (!____ptr).get_name = get_name
    (!____ptr).get_icon = get_icon
    (!____ptr).get_uuid = get_uuid
    (!____ptr).get_volume = get_volume
    (!____ptr).get_drive = get_drive
    (!____ptr).can_unmount = can_unmount
    (!____ptr).can_eject = can_eject
    (!____ptr).unmount = unmount
    (!____ptr).unmount_finish = unmount_finish
    (!____ptr).eject = eject
    (!____ptr).eject_finish = eject_finish
    (!____ptr).remount = remount
    (!____ptr).remount_finish = remount_finish
    (!____ptr).guess_content_type = guess_content_type
    (!____ptr).guess_content_type_finish = guess_content_type_finish
    (!____ptr).guess_content_type_sync = guess_content_type_sync
    (!____ptr).pre_unmount = pre_unmount
    (!____ptr).unmount_with_operation = unmount_with_operation
    (!____ptr).unmount_with_operation_finish = unmount_with_operation_finish
    (!____ptr).eject_with_operation = eject_with_operation
    (!____ptr).eject_with_operation_finish = eject_with_operation_finish
    (!____ptr).get_default_location = get_default_location
    (!____ptr).get_sort_key = get_sort_key
    (!____ptr).get_symbolic_icon = get_symbolic_icon
    ____ptr
  extension (struct: GMountIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def changed: CFuncPtr1[Ptr[GMount], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]]
    def changed_=(value: CFuncPtr1[Ptr[GMount], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]] = value
    def unmounted: CFuncPtr1[Ptr[GMount], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]]
    def unmounted_=(value: CFuncPtr1[Ptr[GMount], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]] = value
    def get_root: CFuncPtr1[Ptr[GMount], Ptr[GFile]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]]
    def get_root_=(value: CFuncPtr1[Ptr[GMount], Ptr[GFile]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]] = value
    def get_name: CFuncPtr1[Ptr[GMount], CString] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GMount], CString]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GMount], Ptr[GIcon]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GMount], Ptr[GIcon]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]] = value
    def get_uuid: CFuncPtr1[Ptr[GMount], CString] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]]
    def get_uuid_=(value: CFuncPtr1[Ptr[GMount], CString]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]] = value
    def get_volume: CFuncPtr1[Ptr[GMount], Ptr[GVolume]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]]]
    def get_volume_=(value: CFuncPtr1[Ptr[GMount], Ptr[GVolume]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]]] = value
    def get_drive: CFuncPtr1[Ptr[GMount], Ptr[GDrive]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]]]
    def get_drive_=(value: CFuncPtr1[Ptr[GMount], Ptr[GDrive]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]]] = value
    def can_unmount: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]]
    def can_unmount_=(value: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]] = value
    def can_eject: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]]
    def can_eject_=(value: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]] = value
    def unmount: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_=(value: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_=(value: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def remount: CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def remount_=(value: CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def remount_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def remount_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def guess_content_type: CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def guess_content_type_=(value: CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def guess_content_type_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]]
    def guess_content_type_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def guess_content_type_sync: CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]]
    def guess_content_type_sync_=(value: CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def pre_unmount: CFuncPtr1[Ptr[GMount], Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]]
    def pre_unmount_=(value: CFuncPtr1[Ptr[GMount], Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]] = value
    def unmount_with_operation: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_with_operation_=(value: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_with_operation_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_with_operation_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject_with_operation: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_with_operation_=(value: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_with_operation_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_with_operation_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_default_location: CFuncPtr1[Ptr[GMount], Ptr[GFile]] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]]
    def get_default_location_=(value: CFuncPtr1[Ptr[GMount], Ptr[GFile]]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]] = value
    def get_sort_key: CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]] = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]]]
    def get_sort_key_=(value: CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]]] = value
    def get_symbolic_icon: CFuncPtr1[Ptr[GMount], Ptr[GIcon]] = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]]
    def get_symbolic_icon_=(value: CFuncPtr1[Ptr[GMount], Ptr[GIcon]]): Unit = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](28)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], CString]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GMount], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], CString]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GMount], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Unit]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt)
    res(26) = align(res(25) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]].toInt)
    res(27) = align(res(26) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmountoperation.h
*/
opaque type GMountOperation = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GMountOperation:
  given _tag: Tag[GMountOperation] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GMountOperation] = scala.scalanative.unsafe.alloc[GMountOperation](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMountOperationPrivate])(using Zone): Ptr[GMountOperation] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GMountOperation)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GMountOperationPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMountOperationPrivate]]]
    def priv_=(value: Ptr[GMountOperationPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GMountOperationPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GMountOperationPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmountoperation.h
*/
opaque type GMountOperationClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._5, Nat._6]]
object GMountOperationClass:
  given _tag: Tag[GMountOperationClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._5, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._5, Nat._6](Tag.Nat2, Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GMountOperationClass] = scala.scalanative.unsafe.alloc[GMountOperationClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, ask_password : CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit], ask_question : CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit], reply : CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit], aborted : CFuncPtr1[Ptr[GMountOperation], Unit], show_processes : CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit], show_unmount_progress : CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit], _g_reserved9 : CFuncPtr0[Unit])(using Zone): Ptr[GMountOperationClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).ask_password = ask_password
    (!____ptr).ask_question = ask_question
    (!____ptr).reply = reply
    (!____ptr).aborted = aborted
    (!____ptr).show_processes = show_processes
    (!____ptr).show_unmount_progress = show_unmount_progress
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    (!____ptr)._g_reserved9 = _g_reserved9
    ____ptr
  extension (struct: GMountOperationClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def ask_password: CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit]]]
    def ask_password_=(value: CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit]]] = value
    def ask_question: CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit]]]
    def ask_question_=(value: CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit]]] = value
    def reply: CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit]]]
    def reply_=(value: CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit]]] = value
    def aborted: CFuncPtr1[Ptr[GMountOperation], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMountOperation], Unit]]]
    def aborted_=(value: CFuncPtr1[Ptr[GMountOperation], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMountOperation], Unit]]] = value
    def show_processes: CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit]]]
    def show_processes_=(value: CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit]]] = value
    def show_unmount_progress: CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit]]]
    def show_unmount_progress_=(value: CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved7: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved8: CFuncPtr0[Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved9: CFuncPtr0[Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved9_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](16)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GMountOperation], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GMountOperation], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmountoperation.h
*/
opaque type GMountOperationPrivate = CStruct0
object GMountOperationPrivate:
  given _tag: Tag[GMountOperationPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativesocketaddress.h
*/
opaque type GNativeSocketAddress = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GNativeSocketAddress:
  given _tag: Tag[GNativeSocketAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GNativeSocketAddress] = scala.scalanative.unsafe.alloc[GNativeSocketAddress](1)
  def apply(parent_instance : GSocketAddress, priv : Ptr[GNativeSocketAddressPrivate])(using Zone): Ptr[GNativeSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GNativeSocketAddress)
    def parent_instance: GSocketAddress = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddress]]
    def parent_instance_=(value: GSocketAddress): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddress]] = value
    def priv: Ptr[GNativeSocketAddressPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GNativeSocketAddressPrivate]]]
    def priv_=(value: Ptr[GNativeSocketAddressPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GNativeSocketAddressPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddress].toInt)
    res(1) = align(res(0) + sizeof[GSocketAddress].toInt, alignmentof[Ptr[GNativeSocketAddressPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativesocketaddress.h
*/
opaque type GNativeSocketAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]]
object GNativeSocketAddressClass:
  given _tag: Tag[GNativeSocketAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._0](Tag.Nat1, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GNativeSocketAddressClass] = scala.scalanative.unsafe.alloc[GNativeSocketAddressClass](1)
  def apply(parent_class : GSocketAddressClass)(using Zone): Ptr[GNativeSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GNativeSocketAddressClass)
    def parent_class: GSocketAddressClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressClass]]
    def parent_class_=(value: GSocketAddressClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddressClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativesocketaddress.h
*/
opaque type GNativeSocketAddressPrivate = CStruct0
object GNativeSocketAddressPrivate:
  given _tag: Tag[GNativeSocketAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativevolumemonitor.h
*/
opaque type GNativeVolumeMonitor = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GNativeVolumeMonitor:
  given _tag: Tag[GNativeVolumeMonitor] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GNativeVolumeMonitor] = scala.scalanative.unsafe.alloc[GNativeVolumeMonitor](1)
  def apply(parent_instance : GVolumeMonitor)(using Zone): Ptr[GNativeVolumeMonitor] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: GNativeVolumeMonitor)
    def parent_instance: GVolumeMonitor = !struct.at(offsets(0)).asInstanceOf[Ptr[GVolumeMonitor]]
    def parent_instance_=(value: GVolumeMonitor): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GVolumeMonitor]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GVolumeMonitor].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativevolumemonitor.h
*/
opaque type GNativeVolumeMonitorClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._4, Nat._4]]
object GNativeVolumeMonitorClass:
  given _tag: Tag[GNativeVolumeMonitorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._4, Nat._4]](Tag.Byte, Tag.Digit3[Nat._3, Nat._4, Nat._4](Tag.Nat3, Tag.Nat4, Tag.Nat4))
  def apply()(using Zone): Ptr[GNativeVolumeMonitorClass] = scala.scalanative.unsafe.alloc[GNativeVolumeMonitorClass](1)
  def apply(parent_class : GVolumeMonitorClass, get_mount_for_mount_path : CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]])(using Zone): Ptr[GNativeVolumeMonitorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_mount_for_mount_path = get_mount_for_mount_path
    ____ptr
  extension (struct: GNativeVolumeMonitorClass)
    def parent_class: GVolumeMonitorClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GVolumeMonitorClass]]
    def parent_class_=(value: GVolumeMonitorClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GVolumeMonitorClass]] = value
    def get_mount_for_mount_path: CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]]]
    def get_mount_for_mount_path_=(value: CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GVolumeMonitorClass].toInt)
    res(1) = align(res(0) + sizeof[GVolumeMonitorClass].toInt, alignmentof[CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkaddress.h
*/
opaque type GNetworkAddress = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GNetworkAddress:
  given _tag: Tag[GNetworkAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GNetworkAddress] = scala.scalanative.unsafe.alloc[GNetworkAddress](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GNetworkAddressPrivate])(using Zone): Ptr[GNetworkAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GNetworkAddress)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GNetworkAddressPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GNetworkAddressPrivate]]]
    def priv_=(value: Ptr[GNetworkAddressPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GNetworkAddressPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GNetworkAddressPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkaddress.h
*/
opaque type GNetworkAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GNetworkAddressClass:
  given _tag: Tag[GNetworkAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GNetworkAddressClass] = scala.scalanative.unsafe.alloc[GNetworkAddressClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GNetworkAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GNetworkAddressClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkaddress.h
*/
opaque type GNetworkAddressPrivate = CStruct0
object GNetworkAddressPrivate:
  given _tag: Tag[GNetworkAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GNetworkMonitor = CStruct0
object GNetworkMonitor:
  given _tag: Tag[GNetworkMonitor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkmonitor.h
*/
opaque type GNetworkMonitorInterface = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GNetworkMonitorInterface:
  given _tag: Tag[GNetworkMonitorInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GNetworkMonitorInterface] = scala.scalanative.unsafe.alloc[GNetworkMonitorInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, network_changed : CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit], can_reach : CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_reach_async : CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], can_reach_finish : CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GNetworkMonitorInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).network_changed = network_changed
    (!____ptr).can_reach = can_reach
    (!____ptr).can_reach_async = can_reach_async
    (!____ptr).can_reach_finish = can_reach_finish
    ____ptr
  extension (struct: GNetworkMonitorInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def network_changed: CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit]]]
    def network_changed_=(value: CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit]]] = value
    def can_reach: CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def can_reach_=(value: CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_reach_async: CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def can_reach_async_=(value: CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def can_reach_finish: CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def can_reach_finish_=(value: CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkservice.h
*/
opaque type GNetworkService = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GNetworkService:
  given _tag: Tag[GNetworkService] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GNetworkService] = scala.scalanative.unsafe.alloc[GNetworkService](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GNetworkServicePrivate])(using Zone): Ptr[GNetworkService] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GNetworkService)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GNetworkServicePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GNetworkServicePrivate]]]
    def priv_=(value: Ptr[GNetworkServicePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GNetworkServicePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GNetworkServicePrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkservice.h
*/
opaque type GNetworkServiceClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GNetworkServiceClass:
  given _tag: Tag[GNetworkServiceClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GNetworkServiceClass] = scala.scalanative.unsafe.alloc[GNetworkServiceClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GNetworkServiceClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GNetworkServiceClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkservice.h
*/
opaque type GNetworkServicePrivate = CStruct0
object GNetworkServicePrivate:
  given _tag: Tag[GNetworkServicePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GNotification = CStruct0
object GNotification:
  given _tag: Tag[GNotification] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GOutputMessage = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GOutputMessage:
  given _tag: Tag[GOutputMessage] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GOutputMessage] = scala.scalanative.unsafe.alloc[GOutputMessage](1)
  def apply(address : Ptr[GSocketAddress], vectors : Ptr[GOutputVector], num_vectors : _root_.glib.guint, bytes_sent : _root_.glib.guint, control_messages : Ptr[Ptr[GSocketControlMessage]], num_control_messages : _root_.glib.guint)(using Zone): Ptr[GOutputMessage] = 
    val ____ptr = apply()
    (!____ptr).address = address
    (!____ptr).vectors = vectors
    (!____ptr).num_vectors = num_vectors
    (!____ptr).bytes_sent = bytes_sent
    (!____ptr).control_messages = control_messages
    (!____ptr).num_control_messages = num_control_messages
    ____ptr
  extension (struct: GOutputMessage)
    def address: Ptr[GSocketAddress] = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[GSocketAddress]]]
    def address_=(value: Ptr[GSocketAddress]): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[GSocketAddress]]] = value
    def vectors: Ptr[GOutputVector] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GOutputVector]]]
    def vectors_=(value: Ptr[GOutputVector]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GOutputVector]]] = value
    def num_vectors: _root_.glib.guint = !struct.at(offsets(2)).asInstanceOf[Ptr[_root_.glib.guint]]
    def num_vectors_=(value: _root_.glib.guint): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[_root_.glib.guint]] = value
    def bytes_sent: _root_.glib.guint = !struct.at(offsets(3)).asInstanceOf[Ptr[_root_.glib.guint]]
    def bytes_sent_=(value: _root_.glib.guint): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[_root_.glib.guint]] = value
    def control_messages: Ptr[Ptr[GSocketControlMessage]] = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GSocketControlMessage]]]]
    def control_messages_=(value: Ptr[Ptr[GSocketControlMessage]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[Ptr[Ptr[GSocketControlMessage]]]] = value
    def num_control_messages: _root_.glib.guint = !struct.at(offsets(5)).asInstanceOf[Ptr[_root_.glib.guint]]
    def num_control_messages_=(value: _root_.glib.guint): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[_root_.glib.guint]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[Ptr[GSocketAddress]].toInt)
    res(1) = align(res(0) + sizeof[Ptr[GSocketAddress]].toInt, alignmentof[Ptr[GOutputVector]].toInt)
    res(2) = align(res(1) + sizeof[Ptr[GOutputVector]].toInt, alignmentof[_root_.glib.guint].toInt)
    res(3) = align(res(2) + sizeof[_root_.glib.guint].toInt, alignmentof[_root_.glib.guint].toInt)
    res(4) = align(res(3) + sizeof[_root_.glib.guint].toInt, alignmentof[Ptr[Ptr[GSocketControlMessage]]].toInt)
    res(5) = align(res(4) + sizeof[Ptr[Ptr[GSocketControlMessage]]].toInt, alignmentof[_root_.glib.guint].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/goutputstream.h
*/
opaque type GOutputStream = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GOutputStream:
  given _tag: Tag[GOutputStream] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GOutputStream] = scala.scalanative.unsafe.alloc[GOutputStream](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GOutputStreamPrivate])(using Zone): Ptr[GOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GOutputStream)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GOutputStreamPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GOutputStreamPrivate]]]
    def priv_=(value: Ptr[GOutputStreamPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GOutputStreamPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GOutputStreamPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/goutputstream.h
*/
opaque type GOutputStreamClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._9, Nat._6]]
object GOutputStreamClass:
  given _tag: Tag[GOutputStreamClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._9, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._9, Nat._6](Tag.Nat2, Tag.Nat9, Tag.Nat6))
  def apply()(using Zone): Ptr[GOutputStreamClass] = scala.scalanative.unsafe.alloc[GOutputStreamClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, write_fn : CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], splice : CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], flush : CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], close_fn : CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], write_async : CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], write_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], splice_async : CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], splice_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], flush_async : CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], flush_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], close_async : CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], writev_fn : CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], writev_async : CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], writev_finish : CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit])(using Zone): Ptr[GOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).write_fn = write_fn
    (!____ptr).splice = splice
    (!____ptr).flush = flush
    (!____ptr).close_fn = close_fn
    (!____ptr).write_async = write_async
    (!____ptr).write_finish = write_finish
    (!____ptr).splice_async = splice_async
    (!____ptr).splice_finish = splice_finish
    (!____ptr).flush_async = flush_async
    (!____ptr).flush_finish = flush_finish
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr).writev_fn = writev_fn
    (!____ptr).writev_async = writev_async
    (!____ptr).writev_finish = writev_finish
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    ____ptr
  extension (struct: GOutputStreamClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def write_fn: CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def write_fn_=(value: CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def splice: CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def splice_=(value: CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def flush: CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def flush_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def close_fn: CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_fn_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def write_async: CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def write_async_=(value: CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def write_finish: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def write_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def splice_async: CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def splice_async_=(value: CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def splice_finish: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def splice_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def flush_async: CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def flush_async_=(value: CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def flush_finish: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def flush_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def close_async: CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def close_async_=(value: CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def close_finish: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def close_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def writev_fn: CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def writev_fn_=(value: CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def writev_async: CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def writev_async_=(value: CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def writev_finish: CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def writev_finish_=(value: CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved7: CFuncPtr0[Unit] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved8: CFuncPtr0[Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](21)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/goutputstream.h
*/
opaque type GOutputStreamPrivate = CStruct0
object GOutputStreamPrivate:
  given _tag: Tag[GOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GOutputVector = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GOutputVector:
  given _tag: Tag[GOutputVector] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GOutputVector] = scala.scalanative.unsafe.alloc[GOutputVector](1)
  def apply(buffer : _root_.glib.gconstpointer, size : _root_.glib.gsize)(using Zone): Ptr[GOutputVector] = 
    val ____ptr = apply()
    (!____ptr).buffer = buffer
    (!____ptr).size = size
    ____ptr
  extension (struct: GOutputVector)
    def buffer: _root_.glib.gconstpointer = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gconstpointer]]
    def buffer_=(value: _root_.glib.gconstpointer): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.glib.gconstpointer]] = value
    def size: _root_.glib.gsize = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gsize]]
    def size_=(value: _root_.glib.gsize): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gsize]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.glib.gconstpointer].toInt)
    res(1) = align(res(0) + sizeof[_root_.glib.gconstpointer].toInt, alignmentof[_root_.glib.gsize].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpermission.h
*/
opaque type GPermission = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GPermission:
  given _tag: Tag[GPermission] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GPermission] = scala.scalanative.unsafe.alloc[GPermission](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GPermissionPrivate])(using Zone): Ptr[GPermission] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GPermission)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GPermissionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GPermissionPrivate]]]
    def priv_=(value: Ptr[GPermissionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GPermissionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GPermissionPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpermission.h
*/
opaque type GPermissionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._1, Nat._2]]
object GPermissionClass:
  given _tag: Tag[GPermissionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._1, Nat._2]](Tag.Byte, Tag.Digit3[Nat._3, Nat._1, Nat._2](Tag.Nat3, Tag.Nat1, Tag.Nat2))
  def apply()(using Zone): Ptr[GPermissionClass] = scala.scalanative.unsafe.alloc[GPermissionClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, acquire : CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], acquire_async : CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], acquire_finish : CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], release : CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], release_async : CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], release_finish : CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], reserved : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]])(using Zone): Ptr[GPermissionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).acquire = acquire
    (!____ptr).acquire_async = acquire_async
    (!____ptr).acquire_finish = acquire_finish
    (!____ptr).release = release
    (!____ptr).release_async = release_async
    (!____ptr).release_finish = release_finish
    (!____ptr).reserved = reserved
    ____ptr
  extension (struct: GPermissionClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def acquire: CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def acquire_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def acquire_async: CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def acquire_async_=(value: CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def acquire_finish: CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def acquire_finish_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def release: CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def release_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def release_async: CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def release_async_=(value: CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def release_finish: CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def release_finish_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def reserved: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]]
    def reserved_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpermission.h
*/
opaque type GPermissionPrivate = CStruct0
object GPermissionPrivate:
  given _tag: Tag[GPermissionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GPollableInputStream = CStruct0
object GPollableInputStream:
  given _tag: Tag[GPollableInputStream] = Tag.materializeCStruct0Tag

/**
 * GPollableInputStreamInterface: _iface: The parent interface. _poll: Checks if the #GPollableInputStream instance is actually pollable _source: Creates a #GSource to poll the stream _nonblocking: Does a non-blocking read or returns %G_IO_ERROR_WOULD_BLOCK

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpollableinputstream.h
*/
opaque type GPollableInputStreamInterface = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GPollableInputStreamInterface:
  given _tag: Tag[GPollableInputStreamInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GPollableInputStreamInterface] = scala.scalanative.unsafe.alloc[GPollableInputStreamInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, can_poll : CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], is_readable : CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], create_source : CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]], read_nonblocking : CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize])(using Zone): Ptr[GPollableInputStreamInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).can_poll = can_poll
    (!____ptr).is_readable = is_readable
    (!____ptr).create_source = create_source
    (!____ptr).read_nonblocking = read_nonblocking
    ____ptr
  extension (struct: GPollableInputStreamInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def can_poll: CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]]]
    def can_poll_=(value: CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]]] = value
    def is_readable: CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]]]
    def is_readable_=(value: CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]]] = value
    def create_source: CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]]]
    def create_source_=(value: CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]]] = value
    def read_nonblocking: CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def read_nonblocking_=(value: CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]].toInt, alignmentof[CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GPollableOutputStream = CStruct0
object GPollableOutputStream:
  given _tag: Tag[GPollableOutputStream] = Tag.materializeCStruct0Tag

/**
 * GPollableOutputStreamInterface: _iface: The parent interface. _poll: Checks if the #GPollableOutputStream instance is actually pollable _source: Creates a #GSource to poll the stream _nonblocking: Does a non-blocking write or returns %G_IO_ERROR_WOULD_BLOCK _nonblocking: Does a vectored non-blocking write, or returns %G_POLLABLE_RETURN_WOULD_BLOCK

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpollableoutputstream.h
*/
opaque type GPollableOutputStreamInterface = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GPollableOutputStreamInterface:
  given _tag: Tag[GPollableOutputStreamInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GPollableOutputStreamInterface] = scala.scalanative.unsafe.alloc[GPollableOutputStreamInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, can_poll : CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], is_writable : CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], create_source : CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]], write_nonblocking : CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], writev_nonblocking : CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn])(using Zone): Ptr[GPollableOutputStreamInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).can_poll = can_poll
    (!____ptr).is_writable = is_writable
    (!____ptr).create_source = create_source
    (!____ptr).write_nonblocking = write_nonblocking
    (!____ptr).writev_nonblocking = writev_nonblocking
    ____ptr
  extension (struct: GPollableOutputStreamInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def can_poll: CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]]]
    def can_poll_=(value: CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]]] = value
    def is_writable: CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]]]
    def is_writable_=(value: CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]]] = value
    def create_source: CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]]]
    def create_source_=(value: CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]]] = value
    def write_nonblocking: CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]]
    def write_nonblocking_=(value: CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]] = value
    def writev_nonblocking: CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]]]
    def writev_nonblocking_=(value: CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]].toInt, alignmentof[CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]].toInt)
    res
  end offsets

opaque type GPowerProfileMonitor = CStruct0
object GPowerProfileMonitor:
  given _tag: Tag[GPowerProfileMonitor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpowerprofilemonitor.h
*/
opaque type GPowerProfileMonitorInterface = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GPowerProfileMonitorInterface:
  given _tag: Tag[GPowerProfileMonitorInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GPowerProfileMonitorInterface] = scala.scalanative.unsafe.alloc[GPowerProfileMonitorInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[GPowerProfileMonitorInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: GPowerProfileMonitorInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GPropertyAction = CStruct0
object GPropertyAction:
  given _tag: Tag[GPropertyAction] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GProxy = CStruct0
object GProxy:
  given _tag: Tag[GProxy] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddress.h
*/
opaque type GProxyAddress = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GProxyAddress:
  given _tag: Tag[GProxyAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GProxyAddress] = scala.scalanative.unsafe.alloc[GProxyAddress](1)
  def apply(parent_instance : GInetSocketAddress, priv : Ptr[GProxyAddressPrivate])(using Zone): Ptr[GProxyAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GProxyAddress)
    def parent_instance: GInetSocketAddress = !struct.at(offsets(0)).asInstanceOf[Ptr[GInetSocketAddress]]
    def parent_instance_=(value: GInetSocketAddress): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInetSocketAddress]] = value
    def priv: Ptr[GProxyAddressPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GProxyAddressPrivate]]]
    def priv_=(value: Ptr[GProxyAddressPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GProxyAddressPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInetSocketAddress].toInt)
    res(1) = align(res(0) + sizeof[GInetSocketAddress].toInt, alignmentof[Ptr[GProxyAddressPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddress.h
*/
opaque type GProxyAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]]
object GProxyAddressClass:
  given _tag: Tag[GProxyAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._0](Tag.Nat1, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GProxyAddressClass] = scala.scalanative.unsafe.alloc[GProxyAddressClass](1)
  def apply(parent_class : GInetSocketAddressClass)(using Zone): Ptr[GProxyAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GProxyAddressClass)
    def parent_class: GInetSocketAddressClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GInetSocketAddressClass]]
    def parent_class_=(value: GInetSocketAddressClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GInetSocketAddressClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GInetSocketAddressClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddressenumerator.h
*/
opaque type GProxyAddressEnumerator = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GProxyAddressEnumerator:
  given _tag: Tag[GProxyAddressEnumerator] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GProxyAddressEnumerator] = scala.scalanative.unsafe.alloc[GProxyAddressEnumerator](1)
  def apply(parent_instance : GSocketAddressEnumerator, priv : Ptr[GProxyAddressEnumeratorPrivate])(using Zone): Ptr[GProxyAddressEnumerator] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GProxyAddressEnumerator)
    def parent_instance: GSocketAddressEnumerator = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressEnumerator]]
    def parent_instance_=(value: GSocketAddressEnumerator): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressEnumerator]] = value
    def priv: Ptr[GProxyAddressEnumeratorPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GProxyAddressEnumeratorPrivate]]]
    def priv_=(value: Ptr[GProxyAddressEnumeratorPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GProxyAddressEnumeratorPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddressEnumerator].toInt)
    res(1) = align(res(0) + sizeof[GSocketAddressEnumerator].toInt, alignmentof[Ptr[GProxyAddressEnumeratorPrivate]].toInt)
    res
  end offsets

/**
 * GProxyAddressEnumeratorClass:

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddressenumerator.h
*/
opaque type GProxyAddressEnumeratorClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]]
object GProxyAddressEnumeratorClass:
  given _tag: Tag[GProxyAddressEnumeratorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._1, Nat._6](Tag.Nat2, Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GProxyAddressEnumeratorClass] = scala.scalanative.unsafe.alloc[GProxyAddressEnumeratorClass](1)
  def apply(parent_class : GSocketAddressEnumeratorClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit])(using Zone): Ptr[GProxyAddressEnumeratorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    ____ptr
  extension (struct: GProxyAddressEnumeratorClass)
    def parent_class: GSocketAddressEnumeratorClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressEnumeratorClass]]
    def parent_class_=(value: GSocketAddressEnumeratorClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressEnumeratorClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved7: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddressEnumeratorClass].toInt)
    res(1) = align(res(0) + sizeof[GSocketAddressEnumeratorClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddressenumerator.h
*/
opaque type GProxyAddressEnumeratorPrivate = CStruct0
object GProxyAddressEnumeratorPrivate:
  given _tag: Tag[GProxyAddressEnumeratorPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddress.h
*/
opaque type GProxyAddressPrivate = CStruct0
object GProxyAddressPrivate:
  given _tag: Tag[GProxyAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * GProxyInterface: _iface: The parent interface. : Connect to proxy server and wrap (if required) the #connection to handle payload. _async: Same as connect() but asynchronous. _finish: Returns the result of connect_async() _hostname: Returns whether the proxy supports hostname lookups.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxy.h
*/
opaque type GProxyInterface = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GProxyInterface:
  given _tag: Tag[GProxyInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GProxyInterface] = scala.scalanative.unsafe.alloc[GProxyInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, connect : CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], connect_async : CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], connect_finish : CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], supports_hostname : CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean])(using Zone): Ptr[GProxyInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).connect = connect
    (!____ptr).connect_async = connect_async
    (!____ptr).connect_finish = connect_finish
    (!____ptr).supports_hostname = supports_hostname
    ____ptr
  extension (struct: GProxyInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def connect: CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]]]
    def connect_=(value: CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]]] = value
    def connect_async: CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def connect_async_=(value: CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def connect_finish: CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]]]
    def connect_finish_=(value: CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]]] = value
    def supports_hostname: CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]]]
    def supports_hostname_=(value: CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]].toInt, alignmentof[CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GProxyResolver = CStruct0
object GProxyResolver:
  given _tag: Tag[GProxyResolver] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyresolver.h
*/
opaque type GProxyResolverInterface = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GProxyResolverInterface:
  given _tag: Tag[GProxyResolverInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GProxyResolverInterface] = scala.scalanative.unsafe.alloc[GProxyResolverInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, is_supported : CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean], lookup : CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], lookup_async : CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_finish : CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]])(using Zone): Ptr[GProxyResolverInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).is_supported = is_supported
    (!____ptr).lookup = lookup
    (!____ptr).lookup_async = lookup_async
    (!____ptr).lookup_finish = lookup_finish
    ____ptr
  extension (struct: GProxyResolverInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def is_supported: CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean]]]
    def is_supported_=(value: CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean]]] = value
    def lookup: CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]]
    def lookup_=(value: CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def lookup_async: CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_async_=(value: CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_finish: CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]]
    def lookup_finish_=(value: CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GRemoteActionGroup = CStruct0
object GRemoteActionGroup:
  given _tag: Tag[GRemoteActionGroup] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gremoteactiongroup.h
*/
opaque type GRemoteActionGroupInterface = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GRemoteActionGroupInterface:
  given _tag: Tag[GRemoteActionGroupInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GRemoteActionGroupInterface] = scala.scalanative.unsafe.alloc[GRemoteActionGroupInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, activate_action_full : CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit], change_action_state_full : CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit])(using Zone): Ptr[GRemoteActionGroupInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).activate_action_full = activate_action_full
    (!____ptr).change_action_state_full = change_action_state_full
    ____ptr
  extension (struct: GRemoteActionGroupInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def activate_action_full: CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]]]
    def activate_action_full_=(value: CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]]] = value
    def change_action_state_full: CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]]]
    def change_action_state_full_=(value: CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresolver.h
*/
opaque type GResolver = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GResolver:
  given _tag: Tag[GResolver] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GResolver] = scala.scalanative.unsafe.alloc[GResolver](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GResolverPrivate])(using Zone): Ptr[GResolver] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GResolver)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GResolverPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GResolverPrivate]]]
    def priv_=(value: Ptr[GResolverPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GResolverPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GResolverPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresolver.h
*/
opaque type GResolverClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._6, Nat._4]]
object GResolverClass:
  given _tag: Tag[GResolverClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._6, Nat._4]](Tag.Byte, Tag.Digit3[Nat._2, Nat._6, Nat._4](Tag.Nat2, Tag.Nat6, Tag.Nat4))
  def apply()(using Zone): Ptr[GResolverClass] = scala.scalanative.unsafe.alloc[GResolverClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, reload : CFuncPtr1[Ptr[GResolver], Unit], lookup_by_name : CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_name_async : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_by_name_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_address : CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], lookup_by_address_async : CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_by_address_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], lookup_service : CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_service_async : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_service_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_records : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_records_async : CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_records_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_name_with_flags_async : CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_by_name_with_flags_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_name_with_flags : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]])(using Zone): Ptr[GResolverClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).reload = reload
    (!____ptr).lookup_by_name = lookup_by_name
    (!____ptr).lookup_by_name_async = lookup_by_name_async
    (!____ptr).lookup_by_name_finish = lookup_by_name_finish
    (!____ptr).lookup_by_address = lookup_by_address
    (!____ptr).lookup_by_address_async = lookup_by_address_async
    (!____ptr).lookup_by_address_finish = lookup_by_address_finish
    (!____ptr).lookup_service = lookup_service
    (!____ptr).lookup_service_async = lookup_service_async
    (!____ptr).lookup_service_finish = lookup_service_finish
    (!____ptr).lookup_records = lookup_records
    (!____ptr).lookup_records_async = lookup_records_async
    (!____ptr).lookup_records_finish = lookup_records_finish
    (!____ptr).lookup_by_name_with_flags_async = lookup_by_name_with_flags_async
    (!____ptr).lookup_by_name_with_flags_finish = lookup_by_name_with_flags_finish
    (!____ptr).lookup_by_name_with_flags = lookup_by_name_with_flags
    ____ptr
  extension (struct: GResolverClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def reload: CFuncPtr1[Ptr[GResolver], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GResolver], Unit]]]
    def reload_=(value: CFuncPtr1[Ptr[GResolver], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GResolver], Unit]]] = value
    def lookup_by_name: CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_by_name_=(value: CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_by_name_async: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_by_name_async_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_by_name_finish: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_by_name_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_by_address: CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]]]
    def lookup_by_address_=(value: CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]]] = value
    def lookup_by_address_async: CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_by_address_async_=(value: CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_by_address_finish: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]]]
    def lookup_by_address_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]]] = value
    def lookup_service: CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_service_=(value: CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_service_async: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_service_async_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_service_finish: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_service_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_records: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_records_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_records_async: CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_records_async_=(value: CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_records_finish: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_records_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_by_name_with_flags_async: CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_by_name_with_flags_async_=(value: CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_by_name_with_flags_finish: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_by_name_with_flags_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_by_name_with_flags: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_by_name_with_flags_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](17)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GResolver], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GResolver], Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresolver.h
*/
opaque type GResolverPrivate = CStruct0
object GResolverPrivate:
  given _tag: Tag[GResolverPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GResource = CStruct0
object GResource:
  given _tag: Tag[GResource] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSeekable = CStruct0
object GSeekable:
  given _tag: Tag[GSeekable] = Tag.materializeCStruct0Tag

/**
 * GSeekableIface: _iface: The parent interface. : Tells the current location within a stream. _seek: Checks if seeking is supported by the stream.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gseekable.h
*/
opaque type GSeekableIface = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GSeekableIface:
  given _tag: Tag[GSeekableIface] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GSeekableIface] = scala.scalanative.unsafe.alloc[GSeekableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, tell : CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_truncate : CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], truncate_fn : CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GSeekableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).can_truncate = can_truncate
    (!____ptr).truncate_fn = truncate_fn
    ____ptr
  extension (struct: GSeekableIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def tell: CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset]]]
    def tell_=(value: CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset]]] = value
    def can_seek: CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]]]
    def can_seek_=(value: CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]]] = value
    def seek: CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def seek_=(value: CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_truncate: CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]]]
    def can_truncate_=(value: CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]]] = value
    def truncate_fn: CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def truncate_fn_=(value: CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset]].toInt, alignmentof[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettings.h
*/
opaque type GSettings = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSettings:
  given _tag: Tag[GSettings] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSettings] = scala.scalanative.unsafe.alloc[GSettings](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSettingsPrivate])(using Zone): Ptr[GSettings] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSettings)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSettingsPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSettingsPrivate]]]
    def priv_=(value: Ptr[GSettingsPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSettingsPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSettingsPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSettingsBackend = CStruct0
object GSettingsBackend:
  given _tag: Tag[GSettingsBackend] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettings.h
*/
opaque type GSettingsClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._2, Nat._8]]
object GSettingsClass:
  given _tag: Tag[GSettingsClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._2, Nat._8]](Tag.Byte, Tag.Digit3[Nat._3, Nat._2, Nat._8](Tag.Nat3, Tag.Nat2, Tag.Nat8))
  def apply()(using Zone): Ptr[GSettingsClass] = scala.scalanative.unsafe.alloc[GSettingsClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, writable_changed : CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], changed : CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], writable_change_event : CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean], change_event : CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]])(using Zone): Ptr[GSettingsClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).writable_changed = writable_changed
    (!____ptr).changed = changed
    (!____ptr).writable_change_event = writable_change_event
    (!____ptr).change_event = change_event
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GSettingsClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def writable_changed: CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]]]
    def writable_changed_=(value: CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]]] = value
    def changed: CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]]]
    def changed_=(value: CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]]] = value
    def writable_change_event: CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean]]]
    def writable_change_event_=(value: CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean]]] = value
    def change_event: CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean]]]
    def change_event_=(value: CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettings.h
*/
opaque type GSettingsPrivate = CStruct0
object GSettingsPrivate:
  given _tag: Tag[GSettingsPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettingsschema.h
*/
opaque type GSettingsSchema = CStruct0
object GSettingsSchema:
  given _tag: Tag[GSettingsSchema] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettingsschema.h
*/
opaque type GSettingsSchemaKey = CStruct0
object GSettingsSchemaKey:
  given _tag: Tag[GSettingsSchemaKey] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettingsschema.h
*/
opaque type GSettingsSchemaSource = CStruct0
object GSettingsSchemaSource:
  given _tag: Tag[GSettingsSchemaSource] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSimpleAction = CStruct0
object GSimpleAction:
  given _tag: Tag[GSimpleAction] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleactiongroup.h
*/
opaque type GSimpleActionGroup = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSimpleActionGroup:
  given _tag: Tag[GSimpleActionGroup] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSimpleActionGroup] = scala.scalanative.unsafe.alloc[GSimpleActionGroup](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSimpleActionGroupPrivate])(using Zone): Ptr[GSimpleActionGroup] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSimpleActionGroup)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSimpleActionGroupPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSimpleActionGroupPrivate]]]
    def priv_=(value: Ptr[GSimpleActionGroupPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSimpleActionGroupPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSimpleActionGroupPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleactiongroup.h
*/
opaque type GSimpleActionGroupClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]]
object GSimpleActionGroupClass:
  given _tag: Tag[GSimpleActionGroupClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._3, Nat._2](Tag.Nat2, Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSimpleActionGroupClass] = scala.scalanative.unsafe.alloc[GSimpleActionGroupClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]])(using Zone): Ptr[GSimpleActionGroupClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GSimpleActionGroupClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleactiongroup.h
*/
opaque type GSimpleActionGroupPrivate = CStruct0
object GSimpleActionGroupPrivate:
  given _tag: Tag[GSimpleActionGroupPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSimpleAsyncResult = CStruct0
object GSimpleAsyncResult:
  given _tag: Tag[GSimpleAsyncResult] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleasyncresult.h
*/
opaque type GSimpleAsyncResultClass = CStruct0
object GSimpleAsyncResultClass:
  given _tag: Tag[GSimpleAsyncResultClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSimpleIOStream = CStruct0
object GSimpleIOStream:
  given _tag: Tag[GSimpleIOStream] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSimplePermission = CStruct0
object GSimplePermission:
  given _tag: Tag[GSimplePermission] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleproxyresolver.h
*/
opaque type GSimpleProxyResolver = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSimpleProxyResolver:
  given _tag: Tag[GSimpleProxyResolver] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSimpleProxyResolver] = scala.scalanative.unsafe.alloc[GSimpleProxyResolver](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSimpleProxyResolverPrivate])(using Zone): Ptr[GSimpleProxyResolver] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSimpleProxyResolver)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSimpleProxyResolverPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSimpleProxyResolverPrivate]]]
    def priv_=(value: Ptr[GSimpleProxyResolverPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSimpleProxyResolverPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSimpleProxyResolverPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleproxyresolver.h
*/
opaque type GSimpleProxyResolverClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._7, Nat._6]]
object GSimpleProxyResolverClass:
  given _tag: Tag[GSimpleProxyResolverClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._7, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._7, Nat._6](Tag.Nat1, Tag.Nat7, Tag.Nat6))
  def apply()(using Zone): Ptr[GSimpleProxyResolverClass] = scala.scalanative.unsafe.alloc[GSimpleProxyResolverClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GSimpleProxyResolverClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GSimpleProxyResolverClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleproxyresolver.h
*/
opaque type GSimpleProxyResolverPrivate = CStruct0
object GSimpleProxyResolverPrivate:
  given _tag: Tag[GSimpleProxyResolverPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocket.h
*/
opaque type GSocket = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSocket:
  given _tag: Tag[GSocket] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSocket] = scala.scalanative.unsafe.alloc[GSocket](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketPrivate])(using Zone): Ptr[GSocket] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSocket)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSocketPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketPrivate]]]
    def priv_=(value: Ptr[GSocketPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSocketPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddress.h
*/
opaque type GSocketAddress = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GSocketAddress:
  given _tag: Tag[GSocketAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GSocketAddress] = scala.scalanative.unsafe.alloc[GSocketAddress](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[GSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: GSocketAddress)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddress.h
*/
opaque type GSocketAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]]
object GSocketAddressClass:
  given _tag: Tag[GSocketAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._0](Tag.Nat1, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GSocketAddressClass] = scala.scalanative.unsafe.alloc[GSocketAddressClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_family : CFuncPtr1[Ptr[GSocketAddress], GSocketFamily], get_native_size : CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize], to_native : CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[GSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_family = get_family
    (!____ptr).get_native_size = get_native_size
    (!____ptr).to_native = to_native
    ____ptr
  extension (struct: GSocketAddressClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_family: CFuncPtr1[Ptr[GSocketAddress], GSocketFamily] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketAddress], GSocketFamily]]]
    def get_family_=(value: CFuncPtr1[Ptr[GSocketAddress], GSocketFamily]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketAddress], GSocketFamily]]] = value
    def get_native_size: CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize]]]
    def get_native_size_=(value: CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize]]] = value
    def to_native: CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def to_native_=(value: CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GSocketAddress], GSocketFamily]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GSocketAddress], GSocketFamily]].toInt, alignmentof[CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize]].toInt, alignmentof[CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddressenumerator.h
*/
opaque type GSocketAddressEnumerator = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GSocketAddressEnumerator:
  given _tag: Tag[GSocketAddressEnumerator] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GSocketAddressEnumerator] = scala.scalanative.unsafe.alloc[GSocketAddressEnumerator](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[GSocketAddressEnumerator] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: GSocketAddressEnumerator)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res
  end offsets

/**
 * GSocketAddressEnumeratorClass: : Virtual method for g_socket_address_enumerator_next(). _async: Virtual method for g_socket_address_enumerator_next_async(). _finish: Virtual method for g_socket_address_enumerator_next_finish().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddressenumerator.h
*/
opaque type GSocketAddressEnumeratorClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]]
object GSocketAddressEnumeratorClass:
  given _tag: Tag[GSocketAddressEnumeratorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._0](Tag.Nat1, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GSocketAddressEnumeratorClass] = scala.scalanative.unsafe.alloc[GSocketAddressEnumeratorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, next : CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]], next_async : CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], next_finish : CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]])(using Zone): Ptr[GSocketAddressEnumeratorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).next = next
    (!____ptr).next_async = next_async
    (!____ptr).next_finish = next_finish
    ____ptr
  extension (struct: GSocketAddressEnumeratorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def next: CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]]]
    def next_=(value: CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]]] = value
    def next_async: CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def next_async_=(value: CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def next_finish: CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]]]
    def next_finish_=(value: CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]].toInt, alignmentof[CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocket.h
*/
opaque type GSocketClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]]
object GSocketClass:
  given _tag: Tag[GSocketClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._1, Nat._6](Tag.Nat2, Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GSocketClass] = scala.scalanative.unsafe.alloc[GSocketClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit], _g_reserved9 : CFuncPtr0[Unit], _g_reserved10 : CFuncPtr0[Unit])(using Zone): Ptr[GSocketClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    (!____ptr)._g_reserved9 = _g_reserved9
    (!____ptr)._g_reserved10 = _g_reserved10
    ____ptr
  extension (struct: GSocketClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved7: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved8: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved9: CFuncPtr0[Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved9_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved10: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved10_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](11)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketclient.h
*/
opaque type GSocketClient = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSocketClient:
  given _tag: Tag[GSocketClient] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSocketClient] = scala.scalanative.unsafe.alloc[GSocketClient](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketClientPrivate])(using Zone): Ptr[GSocketClient] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSocketClient)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSocketClientPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketClientPrivate]]]
    def priv_=(value: Ptr[GSocketClientPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketClientPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSocketClientPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketclient.h
*/
opaque type GSocketClientClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._7, Nat._6]]
object GSocketClientClass:
  given _tag: Tag[GSocketClientClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._7, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._7, Nat._6](Tag.Nat1, Tag.Nat7, Tag.Nat6))
  def apply()(using Zone): Ptr[GSocketClientClass] = scala.scalanative.unsafe.alloc[GSocketClientClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, event : CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit])(using Zone): Ptr[GSocketClientClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).event = event
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    ____ptr
  extension (struct: GSocketClientClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def event: CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit]]]
    def event_=(value: CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketclient.h
*/
opaque type GSocketClientPrivate = CStruct0
object GSocketClientPrivate:
  given _tag: Tag[GSocketClientPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSocketConnectable = CStruct0
object GSocketConnectable:
  given _tag: Tag[GSocketConnectable] = Tag.materializeCStruct0Tag

/**
 * GSocketConnectableIface: _iface: The parent interface. : Creates a #GSocketAddressEnumerator _enumerate: Creates a #GProxyAddressEnumerator _string: Format the connectable’s address as a string for debugging. Implementing this is optional. (Since: 2.48)

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnectable.h
*/
opaque type GSocketConnectableIface = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GSocketConnectableIface:
  given _tag: Tag[GSocketConnectableIface] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GSocketConnectableIface] = scala.scalanative.unsafe.alloc[GSocketConnectableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, enumerate : CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], proxy_enumerate : CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], to_string : CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]])(using Zone): Ptr[GSocketConnectableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).enumerate = enumerate
    (!____ptr).proxy_enumerate = proxy_enumerate
    (!____ptr).to_string = to_string
    ____ptr
  extension (struct: GSocketConnectableIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def enumerate: CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]]]
    def enumerate_=(value: CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]]] = value
    def proxy_enumerate: CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]]]
    def proxy_enumerate_=(value: CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]]] = value
    def to_string: CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]]]
    def to_string_=(value: CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](4)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]].toInt, alignmentof[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]].toInt, alignmentof[CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnection.h
*/
opaque type GSocketConnection = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GSocketConnection:
  given _tag: Tag[GSocketConnection] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GSocketConnection] = scala.scalanative.unsafe.alloc[GSocketConnection](1)
  def apply(parent_instance : GIOStream, priv : Ptr[GSocketConnectionPrivate])(using Zone): Ptr[GSocketConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSocketConnection)
    def parent_instance: GIOStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStream]]
    def parent_instance_=(value: GIOStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStream]] = value
    def priv: Ptr[GSocketConnectionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketConnectionPrivate]]]
    def priv_=(value: Ptr[GSocketConnectionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketConnectionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GIOStream].toInt)
    res(1) = align(res(0) + sizeof[GIOStream].toInt, alignmentof[Ptr[GSocketConnectionPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnection.h
*/
opaque type GSocketConnectionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]]
object GSocketConnectionClass:
  given _tag: Tag[GSocketConnectionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]](Tag.Byte, Tag.Digit3[Nat._3, Nat._0, Nat._4](Tag.Nat3, Tag.Nat0, Tag.Nat4))
  def apply()(using Zone): Ptr[GSocketConnectionClass] = scala.scalanative.unsafe.alloc[GSocketConnectionClass](1)
  def apply(parent_class : GIOStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[GSocketConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: GSocketConnectionClass)
    def parent_class: GIOStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStreamClass]]
    def parent_class_=(value: GIOStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStreamClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](7)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GIOStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GIOStreamClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnection.h
*/
opaque type GSocketConnectionPrivate = CStruct0
object GSocketConnectionPrivate:
  given _tag: Tag[GSocketConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketcontrolmessage.h
*/
opaque type GSocketControlMessage = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSocketControlMessage:
  given _tag: Tag[GSocketControlMessage] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSocketControlMessage] = scala.scalanative.unsafe.alloc[GSocketControlMessage](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketControlMessagePrivate])(using Zone): Ptr[GSocketControlMessage] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSocketControlMessage)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSocketControlMessagePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketControlMessagePrivate]]]
    def priv_=(value: Ptr[GSocketControlMessagePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketControlMessagePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSocketControlMessagePrivate]].toInt)
    res
  end offsets

/**
 * GSocketControlMessageClass: _size: gets the size of the message. _level: gets the protocol of the message. _type: gets the protocol specific type of the message. : Writes out the message data. : Tries to deserialize a message.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketcontrolmessage.h
*/
opaque type GSocketControlMessageClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]]
object GSocketControlMessageClass:
  given _tag: Tag[GSocketControlMessageClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._1, Nat._6](Tag.Nat2, Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GSocketControlMessageClass] = scala.scalanative.unsafe.alloc[GSocketControlMessageClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_size : CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize], get_level : CFuncPtr1[Ptr[GSocketControlMessage], CInt], get_type : CFuncPtr1[Ptr[GSocketControlMessage], CInt], serialize : CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit], deserialize : CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GSocketControlMessageClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_size = get_size
    (!____ptr).get_level = get_level
    (!____ptr).get_type = get_type
    (!____ptr).serialize = serialize
    (!____ptr).deserialize = deserialize
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GSocketControlMessageClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_size: CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize]]]
    def get_size_=(value: CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize]]] = value
    def get_level: CFuncPtr1[Ptr[GSocketControlMessage], CInt] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketControlMessage], CInt]]]
    def get_level_=(value: CFuncPtr1[Ptr[GSocketControlMessage], CInt]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketControlMessage], CInt]]] = value
    def get_type: CFuncPtr1[Ptr[GSocketControlMessage], CInt] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketControlMessage], CInt]]]
    def get_type_=(value: CFuncPtr1[Ptr[GSocketControlMessage], CInt]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketControlMessage], CInt]]] = value
    def serialize: CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit]]]
    def serialize_=(value: CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit]]] = value
    def deserialize: CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]]]]
    def deserialize_=(value: CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](11)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize]].toInt, alignmentof[CFuncPtr1[Ptr[GSocketControlMessage], CInt]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GSocketControlMessage], CInt]].toInt, alignmentof[CFuncPtr1[Ptr[GSocketControlMessage], CInt]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GSocketControlMessage], CInt]].toInt, alignmentof[CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketcontrolmessage.h
*/
opaque type GSocketControlMessagePrivate = CStruct0
object GSocketControlMessagePrivate:
  given _tag: Tag[GSocketControlMessagePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketlistener.h
*/
opaque type GSocketListener = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GSocketListener:
  given _tag: Tag[GSocketListener] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GSocketListener] = scala.scalanative.unsafe.alloc[GSocketListener](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketListenerPrivate])(using Zone): Ptr[GSocketListener] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSocketListener)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GSocketListenerPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketListenerPrivate]]]
    def priv_=(value: Ptr[GSocketListenerPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketListenerPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GSocketListenerPrivate]].toInt)
    res
  end offsets

/**
 * GSocketListenerClass: : virtual method called when the set of socket listened to changes

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketlistener.h
*/
opaque type GSocketListenerClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._9, Nat._2]]
object GSocketListenerClass:
  given _tag: Tag[GSocketListenerClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._9, Nat._2]](Tag.Byte, Tag.Digit3[Nat._1, Nat._9, Nat._2](Tag.Nat1, Tag.Nat9, Tag.Nat2))
  def apply()(using Zone): Ptr[GSocketListenerClass] = scala.scalanative.unsafe.alloc[GSocketListenerClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, changed : CFuncPtr1[Ptr[GSocketListener], Unit], event : CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[GSocketListenerClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).changed = changed
    (!____ptr).event = event
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: GSocketListenerClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def changed: CFuncPtr1[Ptr[GSocketListener], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketListener], Unit]]]
    def changed_=(value: CFuncPtr1[Ptr[GSocketListener], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GSocketListener], Unit]]] = value
    def event: CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit]]]
    def event_=(value: CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GSocketListener], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GSocketListener], Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketlistener.h
*/
opaque type GSocketListenerPrivate = CStruct0
object GSocketListenerPrivate:
  given _tag: Tag[GSocketListenerPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocket.h
*/
opaque type GSocketPrivate = CStruct0
object GSocketPrivate:
  given _tag: Tag[GSocketPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketservice.h
*/
opaque type GSocketService = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GSocketService:
  given _tag: Tag[GSocketService] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GSocketService] = scala.scalanative.unsafe.alloc[GSocketService](1)
  def apply(parent_instance : GSocketListener, priv : Ptr[GSocketServicePrivate])(using Zone): Ptr[GSocketService] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GSocketService)
    def parent_instance: GSocketListener = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketListener]]
    def parent_instance_=(value: GSocketListener): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketListener]] = value
    def priv: Ptr[GSocketServicePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketServicePrivate]]]
    def priv_=(value: Ptr[GSocketServicePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GSocketServicePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketListener].toInt)
    res(1) = align(res(0) + sizeof[GSocketListener].toInt, alignmentof[Ptr[GSocketServicePrivate]].toInt)
    res
  end offsets

/**
 * GSocketServiceClass: : signal emitted when new connections are accepted

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketservice.h
*/
opaque type GSocketServiceClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._8]]
object GSocketServiceClass:
  given _tag: Tag[GSocketServiceClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._4, Nat._8]](Tag.Byte, Tag.Digit3[Nat._2, Nat._4, Nat._8](Tag.Nat2, Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GSocketServiceClass] = scala.scalanative.unsafe.alloc[GSocketServiceClass](1)
  def apply(parent_class : GSocketListenerClass, incoming : CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[GSocketServiceClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).incoming = incoming
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: GSocketServiceClass)
    def parent_class: GSocketListenerClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketListenerClass]]
    def parent_class_=(value: GSocketListenerClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketListenerClass]] = value
    def incoming: CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]]]
    def incoming_=(value: CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketListenerClass].toInt)
    res(1) = align(res(0) + sizeof[GSocketListenerClass].toInt, alignmentof[CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketservice.h
*/
opaque type GSocketServicePrivate = CStruct0
object GSocketServicePrivate:
  given _tag: Tag[GSocketServicePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSrvTarget = CStruct0
object GSrvTarget:
  given _tag: Tag[GSrvTarget] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresource.h
*/
opaque type GStaticResource = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GStaticResource:
  given _tag: Tag[GStaticResource] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GStaticResource] = scala.scalanative.unsafe.alloc[GStaticResource](1)
  def apply(data : Ptr[_root_.glib.guint8], data_len : _root_.glib.gsize, resource : Ptr[GResource], next : Ptr[GStaticResource], padding : _root_.glib.gpointer)(using Zone): Ptr[GStaticResource] = 
    val ____ptr = apply()
    (!____ptr).data = data
    (!____ptr).data_len = data_len
    (!____ptr).resource = resource
    (!____ptr).next = next
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GStaticResource)
    def data: Ptr[_root_.glib.guint8] = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[_root_.glib.guint8]]]
    def data_=(value: Ptr[_root_.glib.guint8]): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[Ptr[_root_.glib.guint8]]] = value
    def data_len: _root_.glib.gsize = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gsize]]
    def data_len_=(value: _root_.glib.gsize): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gsize]] = value
    def resource: Ptr[GResource] = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[GResource]]]
    def resource_=(value: Ptr[GResource]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[Ptr[GResource]]] = value
    def next: Ptr[GStaticResource] = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[GStaticResource]]]
    def next_=(value: Ptr[GStaticResource]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[Ptr[GStaticResource]]] = value
    def padding: _root_.glib.gpointer = !struct.at(offsets(4)).asInstanceOf[Ptr[_root_.glib.gpointer]]
    def padding_=(value: _root_.glib.gpointer): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[_root_.glib.gpointer]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[Ptr[_root_.glib.guint8]].toInt)
    res(1) = align(res(0) + sizeof[Ptr[_root_.glib.guint8]].toInt, alignmentof[_root_.glib.gsize].toInt)
    res(2) = align(res(1) + sizeof[_root_.glib.gsize].toInt, alignmentof[Ptr[GResource]].toInt)
    res(3) = align(res(2) + sizeof[Ptr[GResource]].toInt, alignmentof[Ptr[GStaticResource]].toInt)
    res(4) = align(res(3) + sizeof[Ptr[GStaticResource]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSubprocess = CStruct0
object GSubprocess:
  given _tag: Tag[GSubprocess] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GSubprocessLauncher = CStruct0
object GSubprocessLauncher:
  given _tag: Tag[GSubprocessLauncher] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GTask = CStruct0
object GTask:
  given _tag: Tag[GTask] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtask.h
*/
opaque type GTaskClass = CStruct0
object GTaskClass:
  given _tag: Tag[GTaskClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpconnection.h
*/
opaque type GTcpConnection = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GTcpConnection:
  given _tag: Tag[GTcpConnection] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GTcpConnection] = scala.scalanative.unsafe.alloc[GTcpConnection](1)
  def apply(parent_instance : GSocketConnection, priv : Ptr[GTcpConnectionPrivate])(using Zone): Ptr[GTcpConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTcpConnection)
    def parent_instance: GSocketConnection = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnection]]
    def parent_instance_=(value: GSocketConnection): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnection]] = value
    def priv: Ptr[GTcpConnectionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTcpConnectionPrivate]]]
    def priv_=(value: Ptr[GTcpConnectionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTcpConnectionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketConnection].toInt)
    res(1) = align(res(0) + sizeof[GSocketConnection].toInt, alignmentof[Ptr[GTcpConnectionPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpconnection.h
*/
opaque type GTcpConnectionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]]
object GTcpConnectionClass:
  given _tag: Tag[GTcpConnectionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]](Tag.Byte, Tag.Digit3[Nat._3, Nat._0, Nat._4](Tag.Nat3, Tag.Nat0, Tag.Nat4))
  def apply()(using Zone): Ptr[GTcpConnectionClass] = scala.scalanative.unsafe.alloc[GTcpConnectionClass](1)
  def apply(parent_class : GSocketConnectionClass)(using Zone): Ptr[GTcpConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GTcpConnectionClass)
    def parent_class: GSocketConnectionClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnectionClass]]
    def parent_class_=(value: GSocketConnectionClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnectionClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketConnectionClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpconnection.h
*/
opaque type GTcpConnectionPrivate = CStruct0
object GTcpConnectionPrivate:
  given _tag: Tag[GTcpConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpwrapperconnection.h
*/
opaque type GTcpWrapperConnection = CArray[CChar, Nat.Digit2[Nat._5, Nat._6]]
object GTcpWrapperConnection:
  given _tag: Tag[GTcpWrapperConnection] = Tag.CArray[CChar, Nat.Digit2[Nat._5, Nat._6]](Tag.Byte, Tag.Digit2[Nat._5, Nat._6](Tag.Nat5, Tag.Nat6))
  def apply()(using Zone): Ptr[GTcpWrapperConnection] = scala.scalanative.unsafe.alloc[GTcpWrapperConnection](1)
  def apply(parent_instance : GTcpConnection, priv : Ptr[GTcpWrapperConnectionPrivate])(using Zone): Ptr[GTcpWrapperConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTcpWrapperConnection)
    def parent_instance: GTcpConnection = !struct.at(offsets(0)).asInstanceOf[Ptr[GTcpConnection]]
    def parent_instance_=(value: GTcpConnection): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GTcpConnection]] = value
    def priv: Ptr[GTcpWrapperConnectionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTcpWrapperConnectionPrivate]]]
    def priv_=(value: Ptr[GTcpWrapperConnectionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTcpWrapperConnectionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GTcpConnection].toInt)
    res(1) = align(res(0) + sizeof[GTcpConnection].toInt, alignmentof[Ptr[GTcpWrapperConnectionPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpwrapperconnection.h
*/
opaque type GTcpWrapperConnectionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]]
object GTcpWrapperConnectionClass:
  given _tag: Tag[GTcpWrapperConnectionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]](Tag.Byte, Tag.Digit3[Nat._3, Nat._0, Nat._4](Tag.Nat3, Tag.Nat0, Tag.Nat4))
  def apply()(using Zone): Ptr[GTcpWrapperConnectionClass] = scala.scalanative.unsafe.alloc[GTcpWrapperConnectionClass](1)
  def apply(parent_class : GTcpConnectionClass)(using Zone): Ptr[GTcpWrapperConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GTcpWrapperConnectionClass)
    def parent_class: GTcpConnectionClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GTcpConnectionClass]]
    def parent_class_=(value: GTcpConnectionClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GTcpConnectionClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GTcpConnectionClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpwrapperconnection.h
*/
opaque type GTcpWrapperConnectionPrivate = CStruct0
object GTcpWrapperConnectionPrivate:
  given _tag: Tag[GTcpWrapperConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GTestDBus = CStruct0
object GTestDBus:
  given _tag: Tag[GTestDBus] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GThemedIcon = CStruct0
object GThemedIcon:
  given _tag: Tag[GThemedIcon] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthemedicon.h
*/
opaque type GThemedIconClass = CStruct0
object GThemedIconClass:
  given _tag: Tag[GThemedIconClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthreadedsocketservice.h
*/
opaque type GThreadedSocketService = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GThreadedSocketService:
  given _tag: Tag[GThreadedSocketService] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GThreadedSocketService] = scala.scalanative.unsafe.alloc[GThreadedSocketService](1)
  def apply(parent_instance : GSocketService, priv : Ptr[GThreadedSocketServicePrivate])(using Zone): Ptr[GThreadedSocketService] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GThreadedSocketService)
    def parent_instance: GSocketService = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketService]]
    def parent_instance_=(value: GSocketService): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketService]] = value
    def priv: Ptr[GThreadedSocketServicePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GThreadedSocketServicePrivate]]]
    def priv_=(value: Ptr[GThreadedSocketServicePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GThreadedSocketServicePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketService].toInt)
    res(1) = align(res(0) + sizeof[GSocketService].toInt, alignmentof[Ptr[GThreadedSocketServicePrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthreadedsocketservice.h
*/
opaque type GThreadedSocketServiceClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._9, Nat._6]]
object GThreadedSocketServiceClass:
  given _tag: Tag[GThreadedSocketServiceClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._9, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._9, Nat._6](Tag.Nat2, Tag.Nat9, Tag.Nat6))
  def apply()(using Zone): Ptr[GThreadedSocketServiceClass] = scala.scalanative.unsafe.alloc[GThreadedSocketServiceClass](1)
  def apply(parent_class : GSocketServiceClass, run : CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GThreadedSocketServiceClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).run = run
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GThreadedSocketServiceClass)
    def parent_class: GSocketServiceClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketServiceClass]]
    def parent_class_=(value: GSocketServiceClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketServiceClass]] = value
    def run: CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]]]
    def run_=(value: CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](7)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketServiceClass].toInt)
    res(1) = align(res(0) + sizeof[GSocketServiceClass].toInt, alignmentof[CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthreadedsocketservice.h
*/
opaque type GThreadedSocketServicePrivate = CStruct0
object GThreadedSocketServicePrivate:
  given _tag: Tag[GThreadedSocketServicePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsbackend.h
*/
opaque type GTlsBackend = CStruct0
object GTlsBackend:
  given _tag: Tag[GTlsBackend] = Tag.materializeCStruct0Tag

/**
 * GTlsBackendInterface: _iface: The parent interface. _tls: returns whether the backend supports TLS. _dtls: returns whether the backend supports DTLS _default_database: returns a default #GTlsDatabase instance. _certificate_type: returns the #GTlsCertificate implementation type _client_connection_type: returns the #GTlsClientConnection implementation type _server_connection_type: returns the #GTlsServerConnection implementation type _file_database_type: returns the #GTlsFileDatabase implementation type. _dtls_client_connection_type: returns the #GDtlsClientConnection implementation type _dtls_server_connection_type: returns the #GDtlsServerConnection implementation type

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsbackend.h
*/
opaque type GTlsBackendInterface = CArray[CChar, Nat.Digit2[Nat._8, Nat._8]]
object GTlsBackendInterface:
  given _tag: Tag[GTlsBackendInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._8, Nat._8]](Tag.Byte, Tag.Digit2[Nat._8, Nat._8](Tag.Nat8, Tag.Nat8))
  def apply()(using Zone): Ptr[GTlsBackendInterface] = scala.scalanative.unsafe.alloc[GTlsBackendInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, supports_tls : CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], get_certificate_type : CFuncPtr0[_root_.gobject.GType], get_client_connection_type : CFuncPtr0[_root_.gobject.GType], get_server_connection_type : CFuncPtr0[_root_.gobject.GType], get_file_database_type : CFuncPtr0[_root_.gobject.GType], get_default_database : CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]], supports_dtls : CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], get_dtls_client_connection_type : CFuncPtr0[_root_.gobject.GType], get_dtls_server_connection_type : CFuncPtr0[_root_.gobject.GType])(using Zone): Ptr[GTlsBackendInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).supports_tls = supports_tls
    (!____ptr).get_certificate_type = get_certificate_type
    (!____ptr).get_client_connection_type = get_client_connection_type
    (!____ptr).get_server_connection_type = get_server_connection_type
    (!____ptr).get_file_database_type = get_file_database_type
    (!____ptr).get_default_database = get_default_database
    (!____ptr).supports_dtls = supports_dtls
    (!____ptr).get_dtls_client_connection_type = get_dtls_client_connection_type
    (!____ptr).get_dtls_server_connection_type = get_dtls_server_connection_type
    ____ptr
  extension (struct: GTlsBackendInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def supports_tls: CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]]]
    def supports_tls_=(value: CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]]] = value
    def get_certificate_type: CFuncPtr0[_root_.gobject.GType] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]]
    def get_certificate_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]] = value
    def get_client_connection_type: CFuncPtr0[_root_.gobject.GType] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]]
    def get_client_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]] = value
    def get_server_connection_type: CFuncPtr0[_root_.gobject.GType] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]]
    def get_server_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]] = value
    def get_file_database_type: CFuncPtr0[_root_.gobject.GType] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]]
    def get_file_database_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]] = value
    def get_default_database: CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]]]]
    def get_default_database_=(value: CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]]]] = value
    def supports_dtls: CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]]]
    def supports_dtls_=(value: CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]]] = value
    def get_dtls_client_connection_type: CFuncPtr0[_root_.gobject.GType] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]]
    def get_dtls_client_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]] = value
    def get_dtls_server_connection_type: CFuncPtr0[_root_.gobject.GType] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]]
    def get_dtls_server_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr0[_root_.gobject.GType]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](10)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[_root_.gobject.GType]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[_root_.gobject.GType]].toInt, alignmentof[CFuncPtr0[_root_.gobject.GType]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[_root_.gobject.GType]].toInt, alignmentof[CFuncPtr0[_root_.gobject.GType]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[_root_.gobject.GType]].toInt, alignmentof[CFuncPtr0[_root_.gobject.GType]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr0[_root_.gobject.GType]].toInt, alignmentof[CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]]].toInt, alignmentof[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr0[_root_.gobject.GType]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr0[_root_.gobject.GType]].toInt, alignmentof[CFuncPtr0[_root_.gobject.GType]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlscertificate.h
*/
opaque type GTlsCertificate = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GTlsCertificate:
  given _tag: Tag[GTlsCertificate] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsCertificate] = scala.scalanative.unsafe.alloc[GTlsCertificate](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsCertificatePrivate])(using Zone): Ptr[GTlsCertificate] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTlsCertificate)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GTlsCertificatePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsCertificatePrivate]]]
    def priv_=(value: Ptr[GTlsCertificatePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsCertificatePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GTlsCertificatePrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlscertificate.h
*/
opaque type GTlsCertificateClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._8]]
object GTlsCertificateClass:
  given _tag: Tag[GTlsCertificateClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._0, Nat._8]](Tag.Byte, Tag.Digit3[Nat._2, Nat._0, Nat._8](Tag.Nat2, Tag.Nat0, Tag.Nat8))
  def apply()(using Zone): Ptr[GTlsCertificateClass] = scala.scalanative.unsafe.alloc[GTlsCertificateClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, verify : CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags], padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GTlsCertificateClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).verify = verify
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GTlsCertificateClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def verify: CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags]]]
    def verify_=(value: CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(2)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlscertificate.h
*/
opaque type GTlsCertificatePrivate = CStruct0
object GTlsCertificatePrivate:
  given _tag: Tag[GTlsCertificatePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GTlsClientConnection = CStruct0
object GTlsClientConnection:
  given _tag: Tag[GTlsClientConnection] = Tag.materializeCStruct0Tag

/**
 * GTlsClientConnectionInterface: _iface: The parent interface. _session_state: Copies session state from one #GTlsClientConnection to another.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsclientconnection.h
*/
opaque type GTlsClientConnectionInterface = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GTlsClientConnectionInterface:
  given _tag: Tag[GTlsClientConnectionInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GTlsClientConnectionInterface] = scala.scalanative.unsafe.alloc[GTlsClientConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, copy_session_state : CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit])(using Zone): Ptr[GTlsClientConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).copy_session_state = copy_session_state
    ____ptr
  extension (struct: GTlsClientConnectionInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def copy_session_state: CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]]]
    def copy_session_state_=(value: CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsconnection.h
*/
opaque type GTlsConnection = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GTlsConnection:
  given _tag: Tag[GTlsConnection] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GTlsConnection] = scala.scalanative.unsafe.alloc[GTlsConnection](1)
  def apply(parent_instance : GIOStream, priv : Ptr[GTlsConnectionPrivate])(using Zone): Ptr[GTlsConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTlsConnection)
    def parent_instance: GIOStream = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStream]]
    def parent_instance_=(value: GIOStream): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStream]] = value
    def priv: Ptr[GTlsConnectionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsConnectionPrivate]]]
    def priv_=(value: Ptr[GTlsConnectionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsConnectionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GIOStream].toInt)
    res(1) = align(res(0) + sizeof[GIOStream].toInt, alignmentof[Ptr[GTlsConnectionPrivate]].toInt)
    res
  end offsets

/**
 * GTlsConnectionClass: _class: The parent class. _certificate: Check whether to accept a certificate. : Perform a handshake operation. _async: Start an asynchronous handshake operation. _finish: Finish an asynchronous handshake operation. _binding_data: Retrieve TLS channel binding data (Since: 2.66) _negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsconnection.h
*/
opaque type GTlsConnectionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._5, Nat._2]]
object GTlsConnectionClass:
  given _tag: Tag[GTlsConnectionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._5, Nat._2]](Tag.Byte, Tag.Digit3[Nat._3, Nat._5, Nat._2](Tag.Nat3, Tag.Nat5, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsConnectionClass] = scala.scalanative.unsafe.alloc[GTlsConnectionClass](1)
  def apply(parent_class : GIOStreamClass, accept_certificate : CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], handshake : CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], handshake_async : CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], handshake_finish : CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_binding_data : CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_negotiated_protocol : CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]], padding : CArray[_root_.glib.gpointer, Nat._6])(using Zone): Ptr[GTlsConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).accept_certificate = accept_certificate
    (!____ptr).handshake = handshake
    (!____ptr).handshake_async = handshake_async
    (!____ptr).handshake_finish = handshake_finish
    (!____ptr).get_binding_data = get_binding_data
    (!____ptr).get_negotiated_protocol = get_negotiated_protocol
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GTlsConnectionClass)
    def parent_class: GIOStreamClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStreamClass]]
    def parent_class_=(value: GIOStreamClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GIOStreamClass]] = value
    def accept_certificate: CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]]]
    def accept_certificate_=(value: CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]]] = value
    def handshake: CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def handshake_=(value: CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def handshake_async: CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def handshake_async_=(value: CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def handshake_finish: CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def handshake_finish_=(value: CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_binding_data: CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def get_binding_data_=(value: CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_negotiated_protocol: CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]]]]
    def get_negotiated_protocol_=(value: CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._6] = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._6]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._6]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._6]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GIOStreamClass].toInt)
    res(1) = align(res(0) + sizeof[GIOStreamClass].toInt, alignmentof[CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsconnection.h
*/
opaque type GTlsConnectionPrivate = CStruct0
object GTlsConnectionPrivate:
  given _tag: Tag[GTlsConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsdatabase.h
*/
opaque type GTlsDatabase = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GTlsDatabase:
  given _tag: Tag[GTlsDatabase] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsDatabase] = scala.scalanative.unsafe.alloc[GTlsDatabase](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsDatabasePrivate])(using Zone): Ptr[GTlsDatabase] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTlsDatabase)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GTlsDatabasePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsDatabasePrivate]]]
    def priv_=(value: Ptr[GTlsDatabasePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsDatabasePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GTlsDatabasePrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsdatabase.h
*/
opaque type GTlsDatabaseClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._8]]
object GTlsDatabaseClass:
  given _tag: Tag[GTlsDatabaseClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._6, Nat._8]](Tag.Byte, Tag.Digit3[Nat._3, Nat._6, Nat._8](Tag.Nat3, Tag.Nat6, Tag.Nat8))
  def apply()(using Zone): Ptr[GTlsDatabaseClass] = scala.scalanative.unsafe.alloc[GTlsDatabaseClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, verify_chain : CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], verify_chain_async : CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], verify_chain_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], create_certificate_handle : CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]], lookup_certificate_for_handle : CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificate_for_handle_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_certificate_for_handle_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificate_issuer : CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificate_issuer_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_certificate_issuer_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificates_issued_by : CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_certificates_issued_by_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_certificates_issued_by_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]])(using Zone): Ptr[GTlsDatabaseClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).verify_chain = verify_chain
    (!____ptr).verify_chain_async = verify_chain_async
    (!____ptr).verify_chain_finish = verify_chain_finish
    (!____ptr).create_certificate_handle = create_certificate_handle
    (!____ptr).lookup_certificate_for_handle = lookup_certificate_for_handle
    (!____ptr).lookup_certificate_for_handle_async = lookup_certificate_for_handle_async
    (!____ptr).lookup_certificate_for_handle_finish = lookup_certificate_for_handle_finish
    (!____ptr).lookup_certificate_issuer = lookup_certificate_issuer
    (!____ptr).lookup_certificate_issuer_async = lookup_certificate_issuer_async
    (!____ptr).lookup_certificate_issuer_finish = lookup_certificate_issuer_finish
    (!____ptr).lookup_certificates_issued_by = lookup_certificates_issued_by
    (!____ptr).lookup_certificates_issued_by_async = lookup_certificates_issued_by_async
    (!____ptr).lookup_certificates_issued_by_finish = lookup_certificates_issued_by_finish
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GTlsDatabaseClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def verify_chain: CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]]]
    def verify_chain_=(value: CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]]] = value
    def verify_chain_async: CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def verify_chain_async_=(value: CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def verify_chain_finish: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]]]
    def verify_chain_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]]] = value
    def create_certificate_handle: CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]]]]
    def create_certificate_handle_=(value: CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]]]] = value
    def lookup_certificate_for_handle: CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]]
    def lookup_certificate_for_handle_=(value: CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]] = value
    def lookup_certificate_for_handle_async: CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_certificate_for_handle_async_=(value: CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_certificate_for_handle_finish: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]]
    def lookup_certificate_for_handle_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]] = value
    def lookup_certificate_issuer: CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]]
    def lookup_certificate_issuer_=(value: CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]] = value
    def lookup_certificate_issuer_async: CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_certificate_issuer_async_=(value: CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_certificate_issuer_finish: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]]
    def lookup_certificate_issuer_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]]] = value
    def lookup_certificates_issued_by: CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_certificates_issued_by_=(value: CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def lookup_certificates_issued_by_async: CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def lookup_certificates_issued_by_async_=(value: CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def lookup_certificates_issued_by_finish: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]]
    def lookup_certificates_issued_by_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]] = !struct.at(offsets(14)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](15)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]].toInt, alignmentof[CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]].toInt, alignmentof[CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt, alignmentof[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt, alignmentof[CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt, alignmentof[CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]].toInt, alignmentof[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsdatabase.h
*/
opaque type GTlsDatabasePrivate = CStruct0
object GTlsDatabasePrivate:
  given _tag: Tag[GTlsDatabasePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GTlsFileDatabase = CStruct0
object GTlsFileDatabase:
  given _tag: Tag[GTlsFileDatabase] = Tag.materializeCStruct0Tag

/**
 * GTlsFileDatabaseInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsfiledatabase.h
*/
opaque type GTlsFileDatabaseInterface = CArray[CChar, Nat.Digit2[Nat._8, Nat._0]]
object GTlsFileDatabaseInterface:
  given _tag: Tag[GTlsFileDatabaseInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._8, Nat._0]](Tag.Byte, Tag.Digit2[Nat._8, Nat._0](Tag.Nat8, Tag.Nat0))
  def apply()(using Zone): Ptr[GTlsFileDatabaseInterface] = scala.scalanative.unsafe.alloc[GTlsFileDatabaseInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[GTlsFileDatabaseInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GTlsFileDatabaseInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._8] = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._8]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsinteraction.h
*/
opaque type GTlsInteraction = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GTlsInteraction:
  given _tag: Tag[GTlsInteraction] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsInteraction] = scala.scalanative.unsafe.alloc[GTlsInteraction](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsInteractionPrivate])(using Zone): Ptr[GTlsInteraction] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTlsInteraction)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GTlsInteractionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsInteractionPrivate]]]
    def priv_=(value: Ptr[GTlsInteractionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsInteractionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GTlsInteractionPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsinteraction.h
*/
opaque type GTlsInteractionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._5, Nat._2]]
object GTlsInteractionClass:
  given _tag: Tag[GTlsInteractionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._5, Nat._2]](Tag.Byte, Tag.Digit3[Nat._3, Nat._5, Nat._2](Tag.Nat3, Tag.Nat5, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsInteractionClass] = scala.scalanative.unsafe.alloc[GTlsInteractionClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, ask_password : CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], ask_password_async : CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], ask_password_finish : CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], request_certificate : CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], request_certificate_async : CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], request_certificate_finish : CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]])(using Zone): Ptr[GTlsInteractionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).ask_password = ask_password
    (!____ptr).ask_password_async = ask_password_async
    (!____ptr).ask_password_finish = ask_password_finish
    (!____ptr).request_certificate = request_certificate
    (!____ptr).request_certificate_async = request_certificate_async
    (!____ptr).request_certificate_finish = request_certificate_finish
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GTlsInteractionClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def ask_password: CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]]
    def ask_password_=(value: CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]] = value
    def ask_password_async: CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def ask_password_async_=(value: CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def ask_password_finish: CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]]
    def ask_password_finish_=(value: CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]] = value
    def request_certificate: CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]]
    def request_certificate_=(value: CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]] = value
    def request_certificate_async: CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def request_certificate_async_=(value: CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def request_certificate_finish: CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]]
    def request_certificate_finish_=(value: CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](8)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt, alignmentof[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt, alignmentof[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt, alignmentof[CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsinteraction.h
*/
opaque type GTlsInteractionPrivate = CStruct0
object GTlsInteractionPrivate:
  given _tag: Tag[GTlsInteractionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlspassword.h
*/
opaque type GTlsPassword = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GTlsPassword:
  given _tag: Tag[GTlsPassword] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsPassword] = scala.scalanative.unsafe.alloc[GTlsPassword](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsPasswordPrivate])(using Zone): Ptr[GTlsPassword] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GTlsPassword)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GTlsPasswordPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsPasswordPrivate]]]
    def priv_=(value: Ptr[GTlsPasswordPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GTlsPasswordPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GTlsPasswordPrivate]].toInt)
    res
  end offsets

/**
 * GTlsPasswordClass: _value: virtual method for g_tls_password_get_value()

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlspassword.h
*/
opaque type GTlsPasswordClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._9, Nat._2]]
object GTlsPasswordClass:
  given _tag: Tag[GTlsPasswordClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._9, Nat._2]](Tag.Byte, Tag.Digit3[Nat._1, Nat._9, Nat._2](Tag.Nat1, Tag.Nat9, Tag.Nat2))
  def apply()(using Zone): Ptr[GTlsPasswordClass] = scala.scalanative.unsafe.alloc[GTlsPasswordClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_value : CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]], set_value : CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit], get_default_warning : CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]], padding : CArray[_root_.glib.gpointer, Nat._4])(using Zone): Ptr[GTlsPasswordClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_value = get_value
    (!____ptr).set_value = set_value
    (!____ptr).get_default_warning = get_default_warning
    (!____ptr).padding = padding
    ____ptr
  extension (struct: GTlsPasswordClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def get_value: CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]]]]
    def get_value_=(value: CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]]]] = value
    def set_value: CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit]]]
    def set_value_=(value: CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit]]] = value
    def get_default_warning: CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]]]]
    def get_default_warning_=(value: CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]]]] = value
    def padding: CArray[_root_.glib.gpointer, Nat._4] = !struct.at(offsets(4)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._4]]]
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._4]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CArray[_root_.glib.gpointer, Nat._4]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](5)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]]].toInt, alignmentof[CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]]].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlspassword.h
*/
opaque type GTlsPasswordPrivate = CStruct0
object GTlsPasswordPrivate:
  given _tag: Tag[GTlsPasswordPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GTlsServerConnection = CStruct0
object GTlsServerConnection:
  given _tag: Tag[GTlsServerConnection] = Tag.materializeCStruct0Tag

/**
 * GTlsServerConnectionInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsserverconnection.h
*/
opaque type GTlsServerConnectionInterface = CArray[CChar, Nat.Digit2[Nat._1, Nat._6]]
object GTlsServerConnectionInterface:
  given _tag: Tag[GTlsServerConnectionInterface] = Tag.CArray[CChar, Nat.Digit2[Nat._1, Nat._6]](Tag.Byte, Tag.Digit2[Nat._1, Nat._6](Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[GTlsServerConnectionInterface] = scala.scalanative.unsafe.alloc[GTlsServerConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[GTlsServerConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: GTlsServerConnectionInterface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixconnection.h
*/
opaque type GUnixConnection = CArray[CChar, Nat.Digit2[Nat._4, Nat._8]]
object GUnixConnection:
  given _tag: Tag[GUnixConnection] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._8]](Tag.Byte, Tag.Digit2[Nat._4, Nat._8](Tag.Nat4, Tag.Nat8))
  def apply()(using Zone): Ptr[GUnixConnection] = scala.scalanative.unsafe.alloc[GUnixConnection](1)
  def apply(parent_instance : GSocketConnection, priv : Ptr[GUnixConnectionPrivate])(using Zone): Ptr[GUnixConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GUnixConnection)
    def parent_instance: GSocketConnection = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnection]]
    def parent_instance_=(value: GSocketConnection): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnection]] = value
    def priv: Ptr[GUnixConnectionPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixConnectionPrivate]]]
    def priv_=(value: Ptr[GUnixConnectionPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixConnectionPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketConnection].toInt)
    res(1) = align(res(0) + sizeof[GSocketConnection].toInt, alignmentof[Ptr[GUnixConnectionPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixconnection.h
*/
opaque type GUnixConnectionClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]]
object GUnixConnectionClass:
  given _tag: Tag[GUnixConnectionClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._0, Nat._4]](Tag.Byte, Tag.Digit3[Nat._3, Nat._0, Nat._4](Tag.Nat3, Tag.Nat0, Tag.Nat4))
  def apply()(using Zone): Ptr[GUnixConnectionClass] = scala.scalanative.unsafe.alloc[GUnixConnectionClass](1)
  def apply(parent_class : GSocketConnectionClass)(using Zone): Ptr[GUnixConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GUnixConnectionClass)
    def parent_class: GSocketConnectionClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnectionClass]]
    def parent_class_=(value: GSocketConnectionClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketConnectionClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketConnectionClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixconnection.h
*/
opaque type GUnixConnectionPrivate = CStruct0
object GUnixConnectionPrivate:
  given _tag: Tag[GUnixConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixcredentialsmessage.h
*/
opaque type GUnixCredentialsMessage = CArray[CChar, Nat.Digit2[Nat._4, Nat._0]]
object GUnixCredentialsMessage:
  given _tag: Tag[GUnixCredentialsMessage] = Tag.CArray[CChar, Nat.Digit2[Nat._4, Nat._0]](Tag.Byte, Tag.Digit2[Nat._4, Nat._0](Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[GUnixCredentialsMessage] = scala.scalanative.unsafe.alloc[GUnixCredentialsMessage](1)
  def apply(parent_instance : GSocketControlMessage, priv : Ptr[GUnixCredentialsMessagePrivate])(using Zone): Ptr[GUnixCredentialsMessage] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GUnixCredentialsMessage)
    def parent_instance: GSocketControlMessage = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketControlMessage]]
    def parent_instance_=(value: GSocketControlMessage): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketControlMessage]] = value
    def priv: Ptr[GUnixCredentialsMessagePrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixCredentialsMessagePrivate]]]
    def priv_=(value: Ptr[GUnixCredentialsMessagePrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixCredentialsMessagePrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketControlMessage].toInt)
    res(1) = align(res(0) + sizeof[GSocketControlMessage].toInt, alignmentof[Ptr[GUnixCredentialsMessagePrivate]].toInt)
    res
  end offsets

/**
 * GUnixCredentialsMessageClass:

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixcredentialsmessage.h
*/
opaque type GUnixCredentialsMessageClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]]
object GUnixCredentialsMessageClass:
  given _tag: Tag[GUnixCredentialsMessageClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._3, Nat._2](Tag.Nat2, Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GUnixCredentialsMessageClass] = scala.scalanative.unsafe.alloc[GUnixCredentialsMessageClass](1)
  def apply(parent_class : GSocketControlMessageClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit])(using Zone): Ptr[GUnixCredentialsMessageClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    ____ptr
  extension (struct: GUnixCredentialsMessageClass)
    def parent_class: GSocketControlMessageClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketControlMessageClass]]
    def parent_class_=(value: GSocketControlMessageClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketControlMessageClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](3)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketControlMessageClass].toInt)
    res(1) = align(res(0) + sizeof[GSocketControlMessageClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixcredentialsmessage.h
*/
opaque type GUnixCredentialsMessagePrivate = CStruct0
object GUnixCredentialsMessagePrivate:
  given _tag: Tag[GUnixCredentialsMessagePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixfdlist.h
*/
opaque type GUnixFDList = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GUnixFDList:
  given _tag: Tag[GUnixFDList] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GUnixFDList] = scala.scalanative.unsafe.alloc[GUnixFDList](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GUnixFDListPrivate])(using Zone): Ptr[GUnixFDList] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GUnixFDList)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: Ptr[GUnixFDListPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixFDListPrivate]]]
    def priv_=(value: Ptr[GUnixFDListPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixFDListPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[Ptr[GUnixFDListPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixfdlist.h
*/
opaque type GUnixFDListClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._7, Nat._6]]
object GUnixFDListClass:
  given _tag: Tag[GUnixFDListClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._7, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._7, Nat._6](Tag.Nat1, Tag.Nat7, Tag.Nat6))
  def apply()(using Zone): Ptr[GUnixFDListClass] = scala.scalanative.unsafe.alloc[GUnixFDListClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[GUnixFDListClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: GUnixFDListClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](6)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixfdlist.h
*/
opaque type GUnixFDListPrivate = CStruct0
object GUnixFDListPrivate:
  given _tag: Tag[GUnixFDListPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixsocketaddress.h
*/
opaque type GUnixSocketAddress = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GUnixSocketAddress:
  given _tag: Tag[GUnixSocketAddress] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GUnixSocketAddress] = scala.scalanative.unsafe.alloc[GUnixSocketAddress](1)
  def apply(parent_instance : GSocketAddress, priv : Ptr[GUnixSocketAddressPrivate])(using Zone): Ptr[GUnixSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GUnixSocketAddress)
    def parent_instance: GSocketAddress = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddress]]
    def parent_instance_=(value: GSocketAddress): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddress]] = value
    def priv: Ptr[GUnixSocketAddressPrivate] = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixSocketAddressPrivate]]]
    def priv_=(value: Ptr[GUnixSocketAddressPrivate]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[Ptr[GUnixSocketAddressPrivate]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddress].toInt)
    res(1) = align(res(0) + sizeof[GSocketAddress].toInt, alignmentof[Ptr[GUnixSocketAddressPrivate]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixsocketaddress.h
*/
opaque type GUnixSocketAddressClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]]
object GUnixSocketAddressClass:
  given _tag: Tag[GUnixSocketAddressClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._6, Nat._0]](Tag.Byte, Tag.Digit3[Nat._1, Nat._6, Nat._0](Tag.Nat1, Tag.Nat6, Tag.Nat0))
  def apply()(using Zone): Ptr[GUnixSocketAddressClass] = scala.scalanative.unsafe.alloc[GUnixSocketAddressClass](1)
  def apply(parent_class : GSocketAddressClass)(using Zone): Ptr[GUnixSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GUnixSocketAddressClass)
    def parent_class: GSocketAddressClass = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressClass]]
    def parent_class_=(value: GSocketAddressClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[GSocketAddressClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[GSocketAddressClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixsocketaddress.h
*/
opaque type GUnixSocketAddressPrivate = CStruct0
object GUnixSocketAddressPrivate:
  given _tag: Tag[GUnixSocketAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvfs.h
*/
opaque type GVfs = CArray[CChar, Nat.Digit2[Nat._2, Nat._4]]
object GVfs:
  given _tag: Tag[GVfs] = Tag.CArray[CChar, Nat.Digit2[Nat._2, Nat._4]](Tag.Byte, Tag.Digit2[Nat._2, Nat._4](Tag.Nat2, Tag.Nat4))
  def apply()(using Zone): Ptr[GVfs] = scala.scalanative.unsafe.alloc[GVfs](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[GVfs] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: GVfs)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvfs.h
*/
opaque type GVfsClass = CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]]
object GVfsClass:
  given _tag: Tag[GVfsClass] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._7, Nat._2](Tag.Nat2, Tag.Nat7, Tag.Nat2))
  def apply()(using Zone): Ptr[GVfsClass] = scala.scalanative.unsafe.alloc[GVfsClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, is_active : CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean], get_file_for_path : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], get_file_for_uri : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], get_supported_uri_schemes : CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]], parse_name : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], local_file_add_info : CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit], add_writable_namespaces : CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit], local_file_set_attributes : CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], local_file_removed : CFuncPtr2[Ptr[GVfs], CString, Unit], local_file_moved : CFuncPtr3[Ptr[GVfs], CString, CString, Unit], deserialize_icon : CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[GVfsClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).is_active = is_active
    (!____ptr).get_file_for_path = get_file_for_path
    (!____ptr).get_file_for_uri = get_file_for_uri
    (!____ptr).get_supported_uri_schemes = get_supported_uri_schemes
    (!____ptr).parse_name = parse_name
    (!____ptr).local_file_add_info = local_file_add_info
    (!____ptr).add_writable_namespaces = add_writable_namespaces
    (!____ptr).local_file_set_attributes = local_file_set_attributes
    (!____ptr).local_file_removed = local_file_removed
    (!____ptr).local_file_moved = local_file_moved
    (!____ptr).deserialize_icon = deserialize_icon
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: GVfsClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def is_active: CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean]]]
    def is_active_=(value: CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean]]] = value
    def get_file_for_path: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]]]
    def get_file_for_path_=(value: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]]] = value
    def get_file_for_uri: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]]]
    def get_file_for_uri_=(value: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]]] = value
    def get_supported_uri_schemes: CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]]]]
    def get_supported_uri_schemes_=(value: CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def parse_name: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]]]
    def parse_name_=(value: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]]] = value
    def local_file_add_info: CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit]]]
    def local_file_add_info_=(value: CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit]]] = value
    def add_writable_namespaces: CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit]]]
    def add_writable_namespaces_=(value: CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit]]] = value
    def local_file_set_attributes: CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def local_file_set_attributes_=(value: CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def local_file_removed: CFuncPtr2[Ptr[GVfs], CString, Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Unit]]]
    def local_file_removed_=(value: CFuncPtr2[Ptr[GVfs], CString, Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], CString, Unit]]] = value
    def local_file_moved: CFuncPtr3[Ptr[GVfs], CString, CString, Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVfs], CString, CString, Unit]]]
    def local_file_moved_=(value: CFuncPtr3[Ptr[GVfs], CString, CString, Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVfs], CString, CString, Unit]]] = value
    def deserialize_icon: CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]]]]
    def deserialize_icon_=(value: CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](18)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]].toInt, alignmentof[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]].toInt, alignmentof[CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GVfs], CString, Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr2[Ptr[GVfs], CString, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GVfs], CString, CString, Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr3[Ptr[GVfs], CString, CString, Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GVolume = CStruct0
object GVolume:
  given _tag: Tag[GVolume] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvolume.h
*/
opaque type GVolumeIface = CArray[CChar, Nat.Digit3[Nat._1, Nat._8, Nat._4]]
object GVolumeIface:
  given _tag: Tag[GVolumeIface] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._8, Nat._4]](Tag.Byte, Tag.Digit3[Nat._1, Nat._8, Nat._4](Tag.Nat1, Tag.Nat8, Tag.Nat4))
  def apply()(using Zone): Ptr[GVolumeIface] = scala.scalanative.unsafe.alloc[GVolumeIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, changed : CFuncPtr1[Ptr[GVolume], Unit], removed : CFuncPtr1[Ptr[GVolume], Unit], get_name : CFuncPtr1[Ptr[GVolume], CString], get_icon : CFuncPtr1[Ptr[GVolume], Ptr[GIcon]], get_uuid : CFuncPtr1[Ptr[GVolume], CString], get_drive : CFuncPtr1[Ptr[GVolume], Ptr[GDrive]], get_mount : CFuncPtr1[Ptr[GVolume], Ptr[GMount]], can_mount : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], can_eject : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], mount_fn : CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], mount_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject : CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_identifier : CFuncPtr2[Ptr[GVolume], CString, CString], enumerate_identifiers : CFuncPtr1[Ptr[GVolume], Ptr[CString]], should_automount : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], get_activation_root : CFuncPtr1[Ptr[GVolume], Ptr[GFile]], eject_with_operation : CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_with_operation_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_sort_key : CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]], get_symbolic_icon : CFuncPtr1[Ptr[GVolume], Ptr[GIcon]])(using Zone): Ptr[GVolumeIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).changed = changed
    (!____ptr).removed = removed
    (!____ptr).get_name = get_name
    (!____ptr).get_icon = get_icon
    (!____ptr).get_uuid = get_uuid
    (!____ptr).get_drive = get_drive
    (!____ptr).get_mount = get_mount
    (!____ptr).can_mount = can_mount
    (!____ptr).can_eject = can_eject
    (!____ptr).mount_fn = mount_fn
    (!____ptr).mount_finish = mount_finish
    (!____ptr).eject = eject
    (!____ptr).eject_finish = eject_finish
    (!____ptr).get_identifier = get_identifier
    (!____ptr).enumerate_identifiers = enumerate_identifiers
    (!____ptr).should_automount = should_automount
    (!____ptr).get_activation_root = get_activation_root
    (!____ptr).eject_with_operation = eject_with_operation
    (!____ptr).eject_with_operation_finish = eject_with_operation_finish
    (!____ptr).get_sort_key = get_sort_key
    (!____ptr).get_symbolic_icon = get_symbolic_icon
    ____ptr
  extension (struct: GVolumeIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def changed: CFuncPtr1[Ptr[GVolume], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Unit]]]
    def changed_=(value: CFuncPtr1[Ptr[GVolume], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Unit]]] = value
    def removed: CFuncPtr1[Ptr[GVolume], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Unit]]]
    def removed_=(value: CFuncPtr1[Ptr[GVolume], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Unit]]] = value
    def get_name: CFuncPtr1[Ptr[GVolume], CString] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GVolume], CString]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GVolume], Ptr[GIcon]] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]]] = value
    def get_uuid: CFuncPtr1[Ptr[GVolume], CString] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], CString]]]
    def get_uuid_=(value: CFuncPtr1[Ptr[GVolume], CString]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], CString]]] = value
    def get_drive: CFuncPtr1[Ptr[GVolume], Ptr[GDrive]] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GDrive]]]]
    def get_drive_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GDrive]]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GDrive]]]] = value
    def get_mount: CFuncPtr1[Ptr[GVolume], Ptr[GMount]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GMount]]]]
    def get_mount_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GMount]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GMount]]]] = value
    def can_mount: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]]]
    def can_mount_=(value: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]]] = value
    def can_eject: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]]]
    def can_eject_=(value: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]]] = value
    def mount_fn: CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def mount_fn_=(value: CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def mount_finish: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def mount_finish_=(value: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject: CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_=(value: CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_finish: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_finish_=(value: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_identifier: CFuncPtr2[Ptr[GVolume], CString, CString] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolume], CString, CString]]]
    def get_identifier_=(value: CFuncPtr2[Ptr[GVolume], CString, CString]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolume], CString, CString]]] = value
    def enumerate_identifiers: CFuncPtr1[Ptr[GVolume], Ptr[CString]] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[CString]]]]
    def enumerate_identifiers_=(value: CFuncPtr1[Ptr[GVolume], Ptr[CString]]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[CString]]]] = value
    def should_automount: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]]]
    def should_automount_=(value: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]]] = value
    def get_activation_root: CFuncPtr1[Ptr[GVolume], Ptr[GFile]] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GFile]]]]
    def get_activation_root_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GFile]]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GFile]]]] = value
    def eject_with_operation: CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_with_operation_=(value: CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_with_operation_finish: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_with_operation_finish_=(value: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_sort_key: CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]]]]
    def get_sort_key_=(value: CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]]]] = value
    def get_symbolic_icon: CFuncPtr1[Ptr[GVolume], Ptr[GIcon]] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]]]
    def get_symbolic_icon_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](22)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], CString]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GVolume], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], CString]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GVolume], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[GDrive]]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GVolume], Ptr[GDrive]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[GMount]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GVolume], Ptr[GMount]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GVolume], CString, CString]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr2[Ptr[GVolume], CString, CString]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[CString]]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr1[Ptr[GVolume], Ptr[CString]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[GFile]]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr1[Ptr[GVolume], Ptr[GFile]]].toInt, alignmentof[CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvolumemonitor.h
*/
opaque type GVolumeMonitor = CArray[CChar, Nat.Digit2[Nat._3, Nat._2]]
object GVolumeMonitor:
  given _tag: Tag[GVolumeMonitor] = Tag.CArray[CChar, Nat.Digit2[Nat._3, Nat._2]](Tag.Byte, Tag.Digit2[Nat._3, Nat._2](Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[GVolumeMonitor] = scala.scalanative.unsafe.alloc[GVolumeMonitor](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : _root_.glib.gpointer)(using Zone): Ptr[GVolumeMonitor] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: GVolumeMonitor)
    def parent_instance: _root_.gobject.GObject = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]]
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObject]] = value
    def priv: _root_.glib.gpointer = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gpointer]]
    def priv_=(value: _root_.glib.gpointer): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[_root_.glib.gpointer]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](2)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObject].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObject].toInt, alignmentof[_root_.glib.gpointer].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvolumemonitor.h
*/
opaque type GVolumeMonitorClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]]
object GVolumeMonitorClass:
  given _tag: Tag[GVolumeMonitorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._3, Nat._6](Tag.Nat3, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GVolumeMonitorClass] = scala.scalanative.unsafe.alloc[GVolumeMonitorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, volume_added : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit], volume_removed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit], volume_changed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit], mount_added : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], mount_removed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], mount_pre_unmount : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], mount_changed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], drive_connected : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], drive_disconnected : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], drive_changed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], is_supported : CFuncPtr0[_root_.glib.gboolean], get_connected_drives : CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]], get_volumes : CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]], get_mounts : CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]], get_volume_for_uuid : CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]], get_mount_for_uuid : CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]], adopt_orphan_mount : CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]], drive_eject_button : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], drive_stop_button : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[GVolumeMonitorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).volume_added = volume_added
    (!____ptr).volume_removed = volume_removed
    (!____ptr).volume_changed = volume_changed
    (!____ptr).mount_added = mount_added
    (!____ptr).mount_removed = mount_removed
    (!____ptr).mount_pre_unmount = mount_pre_unmount
    (!____ptr).mount_changed = mount_changed
    (!____ptr).drive_connected = drive_connected
    (!____ptr).drive_disconnected = drive_disconnected
    (!____ptr).drive_changed = drive_changed
    (!____ptr).is_supported = is_supported
    (!____ptr).get_connected_drives = get_connected_drives
    (!____ptr).get_volumes = get_volumes
    (!____ptr).get_mounts = get_mounts
    (!____ptr).get_volume_for_uuid = get_volume_for_uuid
    (!____ptr).get_mount_for_uuid = get_mount_for_uuid
    (!____ptr).adopt_orphan_mount = adopt_orphan_mount
    (!____ptr).drive_eject_button = drive_eject_button
    (!____ptr).drive_stop_button = drive_stop_button
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: GVolumeMonitorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def volume_added: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]]
    def volume_added_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]] = value
    def volume_removed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]]
    def volume_removed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]] = value
    def volume_changed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]]
    def volume_changed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]] = value
    def mount_added: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_added_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def mount_removed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_removed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def mount_pre_unmount: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_pre_unmount_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def mount_changed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_changed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def drive_connected: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_connected_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def drive_disconnected: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_disconnected_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def drive_changed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_changed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def is_supported: CFuncPtr0[_root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[_root_.glib.gboolean]]]
    def is_supported_=(value: CFuncPtr0[_root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[_root_.glib.gboolean]]] = value
    def get_connected_drives: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]]
    def get_connected_drives_=(value: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]] = value
    def get_volumes: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]]
    def get_volumes_=(value: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]] = value
    def get_mounts: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]]
    def get_mounts_=(value: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]] = value
    def get_volume_for_uuid: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]]]
    def get_volume_for_uuid_=(value: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]]] = value
    def get_mount_for_uuid: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]]]
    def get_mount_for_uuid_=(value: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]]] = value
    def adopt_orphan_mount: CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]]]
    def adopt_orphan_mount_=(value: CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]]] = value
    def drive_eject_button: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_eject_button_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def drive_stop_button: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_stop_button_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](26)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr0[_root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[_root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]].toInt, alignmentof[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GZlibCompressor = CStruct0
object GZlibCompressor:
  given _tag: Tag[GZlibCompressor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gzlibcompressor.h
*/
opaque type GZlibCompressorClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GZlibCompressorClass:
  given _tag: Tag[GZlibCompressorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GZlibCompressorClass] = scala.scalanative.unsafe.alloc[GZlibCompressorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GZlibCompressorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GZlibCompressorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type GZlibDecompressor = CStruct0
object GZlibDecompressor:
  given _tag: Tag[GZlibDecompressor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gzlibdecompressor.h
*/
opaque type GZlibDecompressorClass = CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]]
object GZlibDecompressorClass:
  given _tag: Tag[GZlibDecompressorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._1, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._1, Nat._3, Nat._6](Tag.Nat1, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[GZlibDecompressorClass] = scala.scalanative.unsafe.alloc[GZlibDecompressorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[GZlibDecompressorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: GZlibDecompressorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](1)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GAction = CStruct0
object _GAction:
  given _tag: Tag[_GAction] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gactionmap.h
*/
opaque type _GActionEntry = CStruct6[Ptr[_root_.glib.gchar], CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], CArray[_root_.glib.gsize, Nat._3]]
object _GActionEntry:
  given _tag: Tag[_GActionEntry] = Tag.materializeCStruct6Tag[Ptr[_root_.glib.gchar], CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], CArray[_root_.glib.gsize, Nat._3]]
  def apply()(using Zone): Ptr[_GActionEntry] = scala.scalanative.unsafe.alloc[_GActionEntry](1)
  def apply(name : Ptr[_root_.glib.gchar], activate : CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], parameter_type : Ptr[_root_.glib.gchar], state : Ptr[_root_.glib.gchar], change_state : CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit], padding : CArray[_root_.glib.gsize, Nat._3])(using Zone): Ptr[_GActionEntry] = 
    val ____ptr = apply()
    (!____ptr).name = name
    (!____ptr).activate = activate
    (!____ptr).parameter_type = parameter_type
    (!____ptr).state = state
    (!____ptr).change_state = change_state
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GActionEntry)
    def name : Ptr[_root_.glib.gchar] = struct._1
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at1 = value
    def activate : CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit] = struct._2
    def activate_=(value: CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]): Unit = !struct.at2 = value
    def parameter_type : Ptr[_root_.glib.gchar] = struct._3
    def parameter_type_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at3 = value
    def state : Ptr[_root_.glib.gchar] = struct._4
    def state_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at4 = value
    def change_state : CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit] = struct._5
    def change_state_=(value: CFuncPtr3[Ptr[GSimpleAction], Ptr[_root_.glib.GVariant], _root_.glib.gpointer, Unit]): Unit = !struct.at5 = value
    def padding : CArray[_root_.glib.gsize, Nat._3] = struct._6
    def padding_=(value: CArray[_root_.glib.gsize, Nat._3]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GActionGroup = CStruct0
object _GActionGroup:
  given _tag: Tag[_GActionGroup] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gactiongroup.h
*/
opaque type _GActionGroupInterface = CStruct15[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]
object _GActionGroupInterface:
  given _tag: Tag[_GActionGroupInterface] = Tag.materializeCStruct15Tag[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit], CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GActionGroupInterface] = scala.scalanative.unsafe.alloc[_GActionGroupInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, has_action : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], list_actions : CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]], get_action_enabled : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean], get_action_parameter_type : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], get_action_state_type : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]], get_action_state_hint : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], get_action_state : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]], change_action_state : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], activate_action : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], action_added : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], action_removed : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit], action_enabled_changed : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit], action_state_changed : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], query_action : CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean])(using Zone): Ptr[_GActionGroupInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).has_action = has_action
    (!____ptr).list_actions = list_actions
    (!____ptr).get_action_enabled = get_action_enabled
    (!____ptr).get_action_parameter_type = get_action_parameter_type
    (!____ptr).get_action_state_type = get_action_state_type
    (!____ptr).get_action_state_hint = get_action_state_hint
    (!____ptr).get_action_state = get_action_state
    (!____ptr).change_action_state = change_action_state
    (!____ptr).activate_action = activate_action
    (!____ptr).action_added = action_added
    (!____ptr).action_removed = action_removed
    (!____ptr).action_enabled_changed = action_enabled_changed
    (!____ptr).action_state_changed = action_state_changed
    (!____ptr).query_action = query_action
    ____ptr
  extension (struct: _GActionGroupInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def has_action : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean] = struct._2
    def has_action_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def list_actions : CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]] = struct._3
    def list_actions_=(value: CFuncPtr1[Ptr[GActionGroup], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at3 = value
    def get_action_enabled : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean] = struct._4
    def get_action_enabled_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def get_action_parameter_type : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]] = struct._5
    def get_action_parameter_type_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at5 = value
    def get_action_state_type : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]] = struct._6
    def get_action_state_type_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at6 = value
    def get_action_state_hint : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]] = struct._7
    def get_action_state_hint_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]): Unit = !struct.at7 = value
    def get_action_state : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]] = struct._8
    def get_action_state_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant]]): Unit = !struct.at8 = value
    def change_action_state : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = struct._9
    def change_action_state_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at9 = value
    def activate_action : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = struct._10
    def activate_action_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at10 = value
    def action_added : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit] = struct._11
    def action_added_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at11 = value
    def action_removed : CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit] = struct._12
    def action_removed_=(value: CFuncPtr2[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at12 = value
    def action_enabled_changed : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit] = struct._13
    def action_enabled_changed_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], _root_.glib.gboolean, Unit]): Unit = !struct.at13 = value
    def action_state_changed : CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = struct._14
    def action_state_changed_=(value: CFuncPtr3[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at14 = value
    def query_action : CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean] = struct._15
    def query_action_=(value: CFuncPtr7[Ptr[GActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gboolean], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariantType]], Ptr[Ptr[_root_.glib.GVariant]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]): Unit = !struct.at15 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gaction.h
*/
opaque type _GActionInterface = CStruct9[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], CFuncPtr1[Ptr[GAction], _root_.glib.gboolean], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]]
object _GActionInterface:
  given _tag: Tag[_GActionInterface] = Tag.materializeCStruct9Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], CFuncPtr1[Ptr[GAction], _root_.glib.gboolean], CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]]
  def apply()(using Zone): Ptr[_GActionInterface] = scala.scalanative.unsafe.alloc[_GActionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, get_name : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]], get_parameter_type : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], get_state_type : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]], get_state_hint : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], get_enabled : CFuncPtr1[Ptr[GAction], _root_.glib.gboolean], get_state : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]], change_state : CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit], activate : CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit])(using Zone): Ptr[_GActionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).get_name = get_name
    (!____ptr).get_parameter_type = get_parameter_type
    (!____ptr).get_state_type = get_state_type
    (!____ptr).get_state_hint = get_state_hint
    (!____ptr).get_enabled = get_enabled
    (!____ptr).get_state = get_state
    (!____ptr).change_state = change_state
    (!____ptr).activate = activate
    ____ptr
  extension (struct: _GActionInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def get_name : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]] = struct._2
    def get_name_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.gchar]]): Unit = !struct.at2 = value
    def get_parameter_type : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]] = struct._3
    def get_parameter_type_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at3 = value
    def get_state_type : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]] = struct._4
    def get_state_type_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariantType]]): Unit = !struct.at4 = value
    def get_state_hint : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]] = struct._5
    def get_state_hint_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]): Unit = !struct.at5 = value
    def get_enabled : CFuncPtr1[Ptr[GAction], _root_.glib.gboolean] = struct._6
    def get_enabled_=(value: CFuncPtr1[Ptr[GAction], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def get_state : CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]] = struct._7
    def get_state_=(value: CFuncPtr1[Ptr[GAction], Ptr[_root_.glib.GVariant]]): Unit = !struct.at7 = value
    def change_state : CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit] = struct._8
    def change_state_=(value: CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at8 = value
    def activate : CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit] = struct._9
    def activate_=(value: CFuncPtr2[Ptr[GAction], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at9 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GActionMap = CStruct0
object _GActionMap:
  given _tag: Tag[_GActionMap] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gactionmap.h
*/
opaque type _GActionMapInterface = CStruct4[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]], CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit], CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]]
object _GActionMapInterface:
  given _tag: Tag[_GActionMapInterface] = Tag.materializeCStruct4Tag[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]], CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit], CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]]
  def apply()(using Zone): Ptr[_GActionMapInterface] = scala.scalanative.unsafe.alloc[_GActionMapInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, lookup_action : CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]], add_action : CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit], remove_action : CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit])(using Zone): Ptr[_GActionMapInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).lookup_action = lookup_action
    (!____ptr).add_action = add_action
    (!____ptr).remove_action = remove_action
    ____ptr
  extension (struct: _GActionMapInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def lookup_action : CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]] = struct._2
    def lookup_action_=(value: CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Ptr[GAction]]): Unit = !struct.at2 = value
    def add_action : CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit] = struct._3
    def add_action_=(value: CFuncPtr2[Ptr[GActionMap], Ptr[GAction], Unit]): Unit = !struct.at3 = value
    def remove_action : CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit] = struct._4
    def remove_action_=(value: CFuncPtr2[Ptr[GActionMap], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GAppInfo = CStruct0
object _GAppInfo:
  given _tag: Tag[_GAppInfo] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type _GAppInfoIface = CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]]
object _GAppInfoIface:
  given _tag: Tag[_GAppInfoIface] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._1, Nat._6]](Tag.Byte, Tag.Digit3[Nat._2, Nat._1, Nat._6](Tag.Nat2, Tag.Nat1, Tag.Nat6))
  def apply()(using Zone): Ptr[_GAppInfoIface] = scala.scalanative.unsafe.alloc[_GAppInfoIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, dup : CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]], equal : CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean], get_id : CFuncPtr1[Ptr[GAppInfo], CString], get_name : CFuncPtr1[Ptr[GAppInfo], CString], get_description : CFuncPtr1[Ptr[GAppInfo], CString], get_executable : CFuncPtr1[Ptr[GAppInfo], CString], get_icon : CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]], launch : CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], supports_uris : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], supports_files : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], launch_uris : CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], should_show : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], set_as_default_for_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_as_default_for_extension : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], add_supports_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_remove_supports_type : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], remove_supports_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_delete : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], do_delete : CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean], get_commandline : CFuncPtr1[Ptr[GAppInfo], CString], get_display_name : CFuncPtr1[Ptr[GAppInfo], CString], set_as_last_used_for_type : CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_supported_types : CFuncPtr1[Ptr[GAppInfo], Ptr[CString]], launch_uris_async : CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], launch_uris_finish : CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GAppInfoIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).dup = dup
    (!____ptr).equal = equal
    (!____ptr).get_id = get_id
    (!____ptr).get_name = get_name
    (!____ptr).get_description = get_description
    (!____ptr).get_executable = get_executable
    (!____ptr).get_icon = get_icon
    (!____ptr).launch = launch
    (!____ptr).supports_uris = supports_uris
    (!____ptr).supports_files = supports_files
    (!____ptr).launch_uris = launch_uris
    (!____ptr).should_show = should_show
    (!____ptr).set_as_default_for_type = set_as_default_for_type
    (!____ptr).set_as_default_for_extension = set_as_default_for_extension
    (!____ptr).add_supports_type = add_supports_type
    (!____ptr).can_remove_supports_type = can_remove_supports_type
    (!____ptr).remove_supports_type = remove_supports_type
    (!____ptr).can_delete = can_delete
    (!____ptr).do_delete = do_delete
    (!____ptr).get_commandline = get_commandline
    (!____ptr).get_display_name = get_display_name
    (!____ptr).set_as_last_used_for_type = set_as_last_used_for_type
    (!____ptr).get_supported_types = get_supported_types
    (!____ptr).launch_uris_async = launch_uris_async
    (!____ptr).launch_uris_finish = launch_uris_finish
    ____ptr
  extension (struct: _GAppInfoIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def dup: CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]]]
    def dup_=(value: CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]]] = value
    def equal: CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]]]
    def equal_=(value: CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def get_id: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_id_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_name: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_description: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_description_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_executable: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_executable_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]]] = value
    def launch: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def launch_=(value: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def supports_uris: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def supports_uris_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def supports_files: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def supports_files_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def launch_uris: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def launch_uris_=(value: CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def should_show: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def should_show_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def set_as_default_for_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_as_default_for_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_as_default_for_extension: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_as_default_for_extension_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def add_supports_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def add_supports_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_remove_supports_type: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def can_remove_supports_type_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def remove_supports_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def remove_supports_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_delete: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def can_delete_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def do_delete: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]]
    def do_delete_=(value: CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]]] = value
    def get_commandline: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_commandline_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def get_display_name: CFuncPtr1[Ptr[GAppInfo], CString] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]]
    def get_display_name_=(value: CFuncPtr1[Ptr[GAppInfo], CString]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], CString]]] = value
    def set_as_last_used_for_type: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_as_last_used_for_type_=(value: CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_supported_types: CFuncPtr1[Ptr[GAppInfo], Ptr[CString]] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]]]
    def get_supported_types_=(value: CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]]] = value
    def launch_uris_async: CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def launch_uris_async_=(value: CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def launch_uris_finish: CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def launch_uris_finish_=(value: CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](26)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GAppInfo], Ptr[GAppInfo]]].toInt, alignmentof[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GAppInfo], Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GAppInfo], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr4[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr1[Ptr[GAppInfo], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr1[Ptr[GAppInfo], CString]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr3[Ptr[GAppInfo], CString, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr1[Ptr[GAppInfo], Ptr[CString]]].toInt, alignmentof[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr6[Ptr[GAppInfo], Ptr[_root_.glib.GList], Ptr[GAppLaunchContext], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GAppInfo], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type _GAppInfoMonitor = CStruct0
object _GAppInfoMonitor:
  given _tag: Tag[_GAppInfoMonitor] = Tag.materializeCStruct0Tag

/**
 * GAppLaunchContext:

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type _GAppLaunchContext = CStruct2[_root_.gobject.GObject, Ptr[GAppLaunchContextPrivate]]
object _GAppLaunchContext:
  given _tag: Tag[_GAppLaunchContext] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GAppLaunchContextPrivate]]
  def apply()(using Zone): Ptr[_GAppLaunchContext] = scala.scalanative.unsafe.alloc[_GAppLaunchContext](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GAppLaunchContextPrivate])(using Zone): Ptr[_GAppLaunchContext] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GAppLaunchContext)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GAppLaunchContextPrivate] = struct._2
    def priv_=(value: Ptr[GAppLaunchContextPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type _GAppLaunchContextClass = CStruct9[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[Byte], CString], CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[Byte], CString], CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit], CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GAppLaunchContextClass:
  given _tag: Tag[_GAppLaunchContextClass] = Tag.materializeCStruct9Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[Byte], CString], CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[Byte], CString], CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit], CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GAppLaunchContextClass] = scala.scalanative.unsafe.alloc[_GAppLaunchContextClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_display : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString], get_startup_notify_id : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString], launch_failed : CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit], launched : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], launch_started : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[_GAppLaunchContextClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_display = get_display
    (!____ptr).get_startup_notify_id = get_startup_notify_id
    (!____ptr).launch_failed = launch_failed
    (!____ptr).launched = launched
    (!____ptr).launch_started = launch_started
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: _GAppLaunchContextClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_display : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString] = struct._2.asInstanceOf[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]]
    def get_display_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]): Unit = !struct.at2 = value.asInstanceOf[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[Byte], CString]]
    def get_startup_notify_id : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString] = struct._3.asInstanceOf[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]]
    def get_startup_notify_id_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GList], CString]): Unit = !struct.at3 = value.asInstanceOf[CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[Byte], CString]]
    def launch_failed : CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit] = struct._4
    def launch_failed_=(value: CFuncPtr2[Ptr[GAppLaunchContext], CString, Unit]): Unit = !struct.at4 = value
    def launched : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit] = struct._5
    def launched_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at5 = value
    def launch_started : CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit] = struct._6
    def launch_started_=(value: CFuncPtr3[Ptr[GAppLaunchContext], Ptr[GAppInfo], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at6 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._7
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._8
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._9
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gappinfo.h
*/
opaque type _GAppLaunchContextPrivate = CStruct0
object _GAppLaunchContextPrivate:
  given _tag: Tag[_GAppLaunchContextPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplication.h
*/
opaque type _GApplication = CStruct2[_root_.gobject.GObject, Ptr[GApplicationPrivate]]
object _GApplication:
  given _tag: Tag[_GApplication] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GApplicationPrivate]]
  def apply()(using Zone): Ptr[_GApplication] = scala.scalanative.unsafe.alloc[_GApplication](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GApplicationPrivate])(using Zone): Ptr[_GApplication] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GApplication)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GApplicationPrivate] = struct._2
    def priv_=(value: Ptr[GApplicationPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplication.h
*/
opaque type _GApplicationClass = CStruct17[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt], CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint], CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat._7]]
object _GApplicationClass:
  given _tag: Tag[_GApplicationClass] = Tag.materializeCStruct17Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt], CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr1[Ptr[GApplication], Unit], CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint], CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat._7]]
  def apply()(using Zone): Ptr[_GApplicationClass] = scala.scalanative.unsafe.alloc[_GApplicationClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, startup : CFuncPtr1[Ptr[GApplication], Unit], activate : CFuncPtr1[Ptr[GApplication], Unit], open : CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit], command_line : CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt], local_command_line : CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean], before_emit : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], after_emit : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit], add_platform_data : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit], quit_mainloop : CFuncPtr1[Ptr[GApplication], Unit], run_mainloop : CFuncPtr1[Ptr[GApplication], Unit], shutdown : CFuncPtr1[Ptr[GApplication], Unit], dbus_register : CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], dbus_unregister : CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit], handle_local_options : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint], name_lost : CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat._7])(using Zone): Ptr[_GApplicationClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).startup = startup
    (!____ptr).activate = activate
    (!____ptr).open = open
    (!____ptr).command_line = command_line
    (!____ptr).local_command_line = local_command_line
    (!____ptr).before_emit = before_emit
    (!____ptr).after_emit = after_emit
    (!____ptr).add_platform_data = add_platform_data
    (!____ptr).quit_mainloop = quit_mainloop
    (!____ptr).run_mainloop = run_mainloop
    (!____ptr).shutdown = shutdown
    (!____ptr).dbus_register = dbus_register
    (!____ptr).dbus_unregister = dbus_unregister
    (!____ptr).handle_local_options = handle_local_options
    (!____ptr).name_lost = name_lost
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GApplicationClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def startup : CFuncPtr1[Ptr[GApplication], Unit] = struct._2
    def startup_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at2 = value
    def activate : CFuncPtr1[Ptr[GApplication], Unit] = struct._3
    def activate_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at3 = value
    def open : CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit] = struct._4
    def open_=(value: CFuncPtr4[Ptr[GApplication], Ptr[Ptr[GFile]], _root_.glib.gint, Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at4 = value
    def command_line : CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt] = struct._5
    def command_line_=(value: CFuncPtr2[Ptr[GApplication], Ptr[GApplicationCommandLine], CInt]): Unit = !struct.at5 = value
    def local_command_line : CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean] = struct._6
    def local_command_line_=(value: CFuncPtr3[Ptr[GApplication], Ptr[Ptr[Ptr[_root_.glib.gchar]]], Ptr[CInt], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def before_emit : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit] = struct._7
    def before_emit_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at7 = value
    def after_emit : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit] = struct._8
    def after_emit_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at8 = value
    def add_platform_data : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit] = struct._9
    def add_platform_data_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantBuilder], Unit]): Unit = !struct.at9 = value
    def quit_mainloop : CFuncPtr1[Ptr[GApplication], Unit] = struct._10
    def quit_mainloop_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at10 = value
    def run_mainloop : CFuncPtr1[Ptr[GApplication], Unit] = struct._11
    def run_mainloop_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at11 = value
    def shutdown : CFuncPtr1[Ptr[GApplication], Unit] = struct._12
    def shutdown_=(value: CFuncPtr1[Ptr[GApplication], Unit]): Unit = !struct.at12 = value
    def dbus_register : CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._13
    def dbus_register_=(value: CFuncPtr4[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at13 = value
    def dbus_unregister : CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit] = struct._14
    def dbus_unregister_=(value: CFuncPtr3[Ptr[GApplication], Ptr[GDBusConnection], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at14 = value
    def handle_local_options : CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint] = struct._15
    def handle_local_options_=(value: CFuncPtr2[Ptr[GApplication], Ptr[_root_.glib.GVariantDict], _root_.glib.gint]): Unit = !struct.at15 = value
    def name_lost : CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean] = struct._16
    def name_lost_=(value: CFuncPtr1[Ptr[GApplication], _root_.glib.gboolean]): Unit = !struct.at16 = value
    def padding : CArray[_root_.glib.gpointer, Nat._7] = struct._17
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._7]): Unit = !struct.at17 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplicationcommandline.h
*/
opaque type _GApplicationCommandLine = CStruct2[_root_.gobject.GObject, Ptr[GApplicationCommandLinePrivate]]
object _GApplicationCommandLine:
  given _tag: Tag[_GApplicationCommandLine] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GApplicationCommandLinePrivate]]
  def apply()(using Zone): Ptr[_GApplicationCommandLine] = scala.scalanative.unsafe.alloc[_GApplicationCommandLine](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GApplicationCommandLinePrivate])(using Zone): Ptr[_GApplicationCommandLine] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GApplicationCommandLine)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GApplicationCommandLinePrivate] = struct._2
    def priv_=(value: Ptr[GApplicationCommandLinePrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplicationcommandline.h
*/
opaque type _GApplicationCommandLineClass = CStruct6[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]], CFuncPtr1[Ptr[GApplicationCommandLine], Unit], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]]]
object _GApplicationCommandLineClass:
  given _tag: Tag[_GApplicationCommandLineClass] = Tag.materializeCStruct6Tag[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]], CFuncPtr1[Ptr[GApplicationCommandLine], Unit], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]]]
  def apply()(using Zone): Ptr[_GApplicationCommandLineClass] = scala.scalanative.unsafe.alloc[_GApplicationCommandLineClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, print_literal : CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], printerr_literal : CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit], get_stdin : CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]], done : CFuncPtr1[Ptr[GApplicationCommandLine], Unit], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]])(using Zone): Ptr[_GApplicationCommandLineClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).print_literal = print_literal
    (!____ptr).printerr_literal = printerr_literal
    (!____ptr).get_stdin = get_stdin
    (!____ptr).done = done
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GApplicationCommandLineClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def print_literal : CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit] = struct._2
    def print_literal_=(value: CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at2 = value
    def printerr_literal : CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit] = struct._3
    def printerr_literal_=(value: CFuncPtr2[Ptr[GApplicationCommandLine], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at3 = value
    def get_stdin : CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]] = struct._4
    def get_stdin_=(value: CFuncPtr1[Ptr[GApplicationCommandLine], Ptr[GInputStream]]): Unit = !struct.at4 = value
    def done : CFuncPtr1[Ptr[GApplicationCommandLine], Unit] = struct._5
    def done_=(value: CFuncPtr1[Ptr[GApplicationCommandLine], Unit]): Unit = !struct.at5 = value
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]] = struct._6
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._0]]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplicationcommandline.h
*/
opaque type _GApplicationCommandLinePrivate = CStruct0
object _GApplicationCommandLinePrivate:
  given _tag: Tag[_GApplicationCommandLinePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gapplication.h
*/
opaque type _GApplicationPrivate = CStruct0
object _GApplicationPrivate:
  given _tag: Tag[_GApplicationPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GAsyncInitable = CStruct0
object _GAsyncInitable:
  given _tag: Tag[_GAsyncInitable] = Tag.materializeCStruct0Tag

/**
 * GAsyncInitableIface: _iface: The parent interface. _async: Starts initialization of the object. _finish: Finishes initialization of the object.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gasyncinitable.h
*/
opaque type _GAsyncInitableIface = CStruct3[_root_.gobject.GTypeInterface, CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GAsyncInitableIface:
  given _tag: Tag[_GAsyncInitableIface] = Tag.materializeCStruct3Tag[_root_.gobject.GTypeInterface, CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GAsyncInitableIface] = scala.scalanative.unsafe.alloc[_GAsyncInitableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, init_async : CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], init_finish : CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GAsyncInitableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).init_async = init_async
    (!____ptr).init_finish = init_finish
    ____ptr
  extension (struct: _GAsyncInitableIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def init_async : CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._2
    def init_async_=(value: CFuncPtr5[Ptr[GAsyncInitable], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at2 = value
    def init_finish : CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._3
    def init_finish_=(value: CFuncPtr3[Ptr[GAsyncInitable], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GAsyncResult = CStruct0
object _GAsyncResult:
  given _tag: Tag[_GAsyncResult] = Tag.materializeCStruct0Tag

/**
 * GAsyncResultIface: _iface: The parent interface. _user_data: Gets the user data passed to the callback. _source_object: Gets the source object that issued the asynchronous operation.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gasyncresult.h
*/
opaque type _GAsyncResultIface = CStruct4[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer], CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]], CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]]
object _GAsyncResultIface:
  given _tag: Tag[_GAsyncResultIface] = Tag.materializeCStruct4Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer], CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]], CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GAsyncResultIface] = scala.scalanative.unsafe.alloc[_GAsyncResultIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, get_user_data : CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer], get_source_object : CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]], is_tagged : CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean])(using Zone): Ptr[_GAsyncResultIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).get_user_data = get_user_data
    (!____ptr).get_source_object = get_source_object
    (!____ptr).is_tagged = is_tagged
    ____ptr
  extension (struct: _GAsyncResultIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def get_user_data : CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer] = struct._2
    def get_user_data_=(value: CFuncPtr1[Ptr[GAsyncResult], _root_.glib.gpointer]): Unit = !struct.at2 = value
    def get_source_object : CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]] = struct._3
    def get_source_object_=(value: CFuncPtr1[Ptr[GAsyncResult], Ptr[_root_.gobject.GObject]]): Unit = !struct.at3 = value
    def is_tagged : CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean] = struct._4
    def is_tagged_=(value: CFuncPtr2[Ptr[GAsyncResult], _root_.glib.gpointer, _root_.glib.gboolean]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedinputstream.h
*/
opaque type _GBufferedInputStream = CStruct2[GFilterInputStream, Ptr[GBufferedInputStreamPrivate]]
object _GBufferedInputStream:
  given _tag: Tag[_GBufferedInputStream] = Tag.materializeCStruct2Tag[GFilterInputStream, Ptr[GBufferedInputStreamPrivate]]
  def apply()(using Zone): Ptr[_GBufferedInputStream] = scala.scalanative.unsafe.alloc[_GBufferedInputStream](1)
  def apply(parent_instance : GFilterInputStream, priv : Ptr[GBufferedInputStreamPrivate])(using Zone): Ptr[_GBufferedInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GBufferedInputStream)
    def parent_instance : GFilterInputStream = struct._1
    def parent_instance_=(value: GFilterInputStream): Unit = !struct.at1 = value
    def priv : Ptr[GBufferedInputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GBufferedInputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedinputstream.h
*/
opaque type _GBufferedInputStreamClass = CStruct9[GFilterInputStreamClass, CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GBufferedInputStreamClass:
  given _tag: Tag[_GBufferedInputStreamClass] = Tag.materializeCStruct9Tag[GFilterInputStreamClass, CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GBufferedInputStreamClass] = scala.scalanative.unsafe.alloc[_GBufferedInputStreamClass](1)
  def apply(parent_class : GFilterInputStreamClass, fill : CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], fill_async : CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], fill_finish : CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GBufferedInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).fill = fill
    (!____ptr).fill_async = fill_async
    (!____ptr).fill_finish = fill_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GBufferedInputStreamClass)
    def parent_class : GFilterInputStreamClass = struct._1
    def parent_class_=(value: GFilterInputStreamClass): Unit = !struct.at1 = value
    def fill : CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._2
    def fill_=(value: CFuncPtr4[Ptr[GBufferedInputStream], _root_.glib.gssize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at2 = value
    def fill_async : CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def fill_async_=(value: CFuncPtr6[Ptr[GBufferedInputStream], _root_.glib.gssize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def fill_finish : CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._4
    def fill_finish_=(value: CFuncPtr3[Ptr[GBufferedInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at4 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._5
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._6
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._7
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._8
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._9
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedinputstream.h
*/
opaque type _GBufferedInputStreamPrivate = CStruct0
object _GBufferedInputStreamPrivate:
  given _tag: Tag[_GBufferedInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedoutputstream.h
*/
opaque type _GBufferedOutputStream = CStruct2[GFilterOutputStream, Ptr[GBufferedOutputStreamPrivate]]
object _GBufferedOutputStream:
  given _tag: Tag[_GBufferedOutputStream] = Tag.materializeCStruct2Tag[GFilterOutputStream, Ptr[GBufferedOutputStreamPrivate]]
  def apply()(using Zone): Ptr[_GBufferedOutputStream] = scala.scalanative.unsafe.alloc[_GBufferedOutputStream](1)
  def apply(parent_instance : GFilterOutputStream, priv : Ptr[GBufferedOutputStreamPrivate])(using Zone): Ptr[_GBufferedOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GBufferedOutputStream)
    def parent_instance : GFilterOutputStream = struct._1
    def parent_instance_=(value: GFilterOutputStream): Unit = !struct.at1 = value
    def priv : Ptr[GBufferedOutputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GBufferedOutputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedoutputstream.h
*/
opaque type _GBufferedOutputStreamClass = CStruct3[GFilterOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GBufferedOutputStreamClass:
  given _tag: Tag[_GBufferedOutputStreamClass] = Tag.materializeCStruct3Tag[GFilterOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GBufferedOutputStreamClass] = scala.scalanative.unsafe.alloc[_GBufferedOutputStreamClass](1)
  def apply(parent_class : GFilterOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit])(using Zone): Ptr[_GBufferedOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    ____ptr
  extension (struct: _GBufferedOutputStreamClass)
    def parent_class : GFilterOutputStreamClass = struct._1
    def parent_class_=(value: GFilterOutputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gbufferedoutputstream.h
*/
opaque type _GBufferedOutputStreamPrivate = CStruct0
object _GBufferedOutputStreamPrivate:
  given _tag: Tag[_GBufferedOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GBytesIcon = CStruct0
object _GBytesIcon:
  given _tag: Tag[_GBytesIcon] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcancellable.h
*/
opaque type _GCancellable = CStruct2[_root_.gobject.GObject, Ptr[GCancellablePrivate]]
object _GCancellable:
  given _tag: Tag[_GCancellable] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GCancellablePrivate]]
  def apply()(using Zone): Ptr[_GCancellable] = scala.scalanative.unsafe.alloc[_GCancellable](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GCancellablePrivate])(using Zone): Ptr[_GCancellable] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GCancellable)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GCancellablePrivate] = struct._2
    def priv_=(value: Ptr[GCancellablePrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcancellable.h
*/
opaque type _GCancellableClass = CStruct7[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GCancellable], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GCancellableClass:
  given _tag: Tag[_GCancellableClass] = Tag.materializeCStruct7Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GCancellable], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GCancellableClass] = scala.scalanative.unsafe.alloc[_GCancellableClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, cancelled : CFuncPtr1[Ptr[GCancellable], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GCancellableClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).cancelled = cancelled
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GCancellableClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def cancelled : CFuncPtr1[Ptr[GCancellable], Unit] = struct._2
    def cancelled_=(value: CFuncPtr1[Ptr[GCancellable], Unit]): Unit = !struct.at2 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._3
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._4
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._5
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._6
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._7
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcancellable.h
*/
opaque type _GCancellablePrivate = CStruct0
object _GCancellablePrivate:
  given _tag: Tag[_GCancellablePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GCharsetConverter = CStruct0
object _GCharsetConverter:
  given _tag: Tag[_GCharsetConverter] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcharsetconverter.h
*/
opaque type _GCharsetConverterClass = CStruct1[_root_.gobject.GObjectClass]
object _GCharsetConverterClass:
  given _tag: Tag[_GCharsetConverterClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GCharsetConverterClass] = scala.scalanative.unsafe.alloc[_GCharsetConverterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GCharsetConverterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GCharsetConverterClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GConverter = CStruct0
object _GConverter:
  given _tag: Tag[_GConverter] = Tag.materializeCStruct0Tag

/**
 * GConverterIface: _iface: The parent interface. : Converts data. : Reverts the internal state of the converter to its initial state.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverter.h
*/
opaque type _GConverterIface = CStruct3[_root_.gobject.GTypeInterface, CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult], CFuncPtr1[Ptr[GConverter], Unit]]
object _GConverterIface:
  given _tag: Tag[_GConverterIface] = Tag.materializeCStruct3Tag[_root_.gobject.GTypeInterface, CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult], CFuncPtr1[Ptr[GConverter], Unit]]
  def apply()(using Zone): Ptr[_GConverterIface] = scala.scalanative.unsafe.alloc[_GConverterIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, convert : CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult], reset : CFuncPtr1[Ptr[GConverter], Unit])(using Zone): Ptr[_GConverterIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).convert = convert
    (!____ptr).reset = reset
    ____ptr
  extension (struct: _GConverterIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def convert : CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult] = struct._2
    def convert_=(value: CFuncPtr9[Ptr[GConverter], Ptr[Byte], _root_.glib.gsize, Ptr[Byte], _root_.glib.gsize, GConverterFlags, Ptr[_root_.glib.gsize], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GConverterResult]): Unit = !struct.at2 = value
    def reset : CFuncPtr1[Ptr[GConverter], Unit] = struct._3
    def reset_=(value: CFuncPtr1[Ptr[GConverter], Unit]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverterinputstream.h
*/
opaque type _GConverterInputStream = CStruct2[GFilterInputStream, Ptr[GConverterInputStreamPrivate]]
object _GConverterInputStream:
  given _tag: Tag[_GConverterInputStream] = Tag.materializeCStruct2Tag[GFilterInputStream, Ptr[GConverterInputStreamPrivate]]
  def apply()(using Zone): Ptr[_GConverterInputStream] = scala.scalanative.unsafe.alloc[_GConverterInputStream](1)
  def apply(parent_instance : GFilterInputStream, priv : Ptr[GConverterInputStreamPrivate])(using Zone): Ptr[_GConverterInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GConverterInputStream)
    def parent_instance : GFilterInputStream = struct._1
    def parent_instance_=(value: GFilterInputStream): Unit = !struct.at1 = value
    def priv : Ptr[GConverterInputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GConverterInputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverterinputstream.h
*/
opaque type _GConverterInputStreamClass = CStruct6[GFilterInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GConverterInputStreamClass:
  given _tag: Tag[_GConverterInputStreamClass] = Tag.materializeCStruct6Tag[GFilterInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GConverterInputStreamClass] = scala.scalanative.unsafe.alloc[_GConverterInputStreamClass](1)
  def apply(parent_class : GFilterInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GConverterInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GConverterInputStreamClass)
    def parent_class : GFilterInputStreamClass = struct._1
    def parent_class_=(value: GFilterInputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverterinputstream.h
*/
opaque type _GConverterInputStreamPrivate = CStruct0
object _GConverterInputStreamPrivate:
  given _tag: Tag[_GConverterInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverteroutputstream.h
*/
opaque type _GConverterOutputStream = CStruct2[GFilterOutputStream, Ptr[GConverterOutputStreamPrivate]]
object _GConverterOutputStream:
  given _tag: Tag[_GConverterOutputStream] = Tag.materializeCStruct2Tag[GFilterOutputStream, Ptr[GConverterOutputStreamPrivate]]
  def apply()(using Zone): Ptr[_GConverterOutputStream] = scala.scalanative.unsafe.alloc[_GConverterOutputStream](1)
  def apply(parent_instance : GFilterOutputStream, priv : Ptr[GConverterOutputStreamPrivate])(using Zone): Ptr[_GConverterOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GConverterOutputStream)
    def parent_instance : GFilterOutputStream = struct._1
    def parent_instance_=(value: GFilterOutputStream): Unit = !struct.at1 = value
    def priv : Ptr[GConverterOutputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GConverterOutputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverteroutputstream.h
*/
opaque type _GConverterOutputStreamClass = CStruct6[GFilterOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GConverterOutputStreamClass:
  given _tag: Tag[_GConverterOutputStreamClass] = Tag.materializeCStruct6Tag[GFilterOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GConverterOutputStreamClass] = scala.scalanative.unsafe.alloc[_GConverterOutputStreamClass](1)
  def apply(parent_class : GFilterOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GConverterOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GConverterOutputStreamClass)
    def parent_class : GFilterOutputStreamClass = struct._1
    def parent_class_=(value: GFilterOutputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gconverteroutputstream.h
*/
opaque type _GConverterOutputStreamPrivate = CStruct0
object _GConverterOutputStreamPrivate:
  given _tag: Tag[_GConverterOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GCredentials = CStruct0
object _GCredentials:
  given _tag: Tag[_GCredentials] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gcredentials.h
*/
opaque type _GCredentialsClass = CStruct0
object _GCredentialsClass:
  given _tag: Tag[_GCredentialsClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusActionGroup = CStruct0
object _GDBusActionGroup:
  given _tag: Tag[_GDBusActionGroup] = Tag.materializeCStruct0Tag

/**
 * GDBusAnnotationInfo: _count: The reference count or -1 if statically allocated. : The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated". : The value of the annotation. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusAnnotationInfo = CStruct4[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[Byte]]
object _GDBusAnnotationInfo:
  given _tag: Tag[_GDBusAnnotationInfo] = Tag.materializeCStruct4Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusAnnotationInfo] = scala.scalanative.unsafe.alloc[_GDBusAnnotationInfo](1)
  def apply(ref_count : _root_.glib.gint, key : Ptr[_root_.glib.gchar], value : Ptr[_root_.glib.gchar], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusAnnotationInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).key = key
    (!____ptr).value = value
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusAnnotationInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def key : Ptr[_root_.glib.gchar] = struct._2
    def key_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def value : Ptr[_root_.glib.gchar] = struct._3
    def value_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at3 = value
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._4.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]

/**
 * GDBusArgInfo: _count: The reference count or -1 if statically allocated. : D-Bus signature of the argument (a single complete type). : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusArgInfo = CStruct4[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[Byte]]
object _GDBusArgInfo:
  given _tag: Tag[_GDBusArgInfo] = Tag.materializeCStruct4Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusArgInfo] = scala.scalanative.unsafe.alloc[_GDBusArgInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], signature : Ptr[_root_.glib.gchar], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusArgInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).signature = signature
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusArgInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def name : Ptr[_root_.glib.gchar] = struct._2
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def signature : Ptr[_root_.glib.gchar] = struct._3
    def signature_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at3 = value
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._4.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusAuthObserver = CStruct0
object _GDBusAuthObserver:
  given _tag: Tag[_GDBusAuthObserver] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusConnection = CStruct0
object _GDBusConnection:
  given _tag: Tag[_GDBusConnection] = Tag.materializeCStruct0Tag

/**
 * GDBusErrorEntry: _code: An error code. _error_name: The D-Bus error name to associate with _code.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbuserror.h
*/
opaque type _GDBusErrorEntry = CStruct2[_root_.glib.gint, Ptr[_root_.glib.gchar]]
object _GDBusErrorEntry:
  given _tag: Tag[_GDBusErrorEntry] = Tag.materializeCStruct2Tag[_root_.glib.gint, Ptr[_root_.glib.gchar]]
  def apply()(using Zone): Ptr[_GDBusErrorEntry] = scala.scalanative.unsafe.alloc[_GDBusErrorEntry](1)
  def apply(error_code : _root_.glib.gint, dbus_error_name : Ptr[_root_.glib.gchar])(using Zone): Ptr[_GDBusErrorEntry] = 
    val ____ptr = apply()
    (!____ptr).error_code = error_code
    (!____ptr).dbus_error_name = dbus_error_name
    ____ptr
  extension (struct: _GDBusErrorEntry)
    def error_code : _root_.glib.gint = struct._1
    def error_code_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def dbus_error_name : Ptr[_root_.glib.gchar] = struct._2
    def dbus_error_name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusInterface = CStruct0
object _GDBusInterface:
  given _tag: Tag[_GDBusInterface] = Tag.materializeCStruct0Tag

/**
 * GDBusInterfaceIface: _iface: The parent interface. _info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info(). _object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterface.h
*/
opaque type _GDBusInterfaceIface = CStruct5[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GDBusInterface], Ptr[Byte]], CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]], CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit], CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]]
object _GDBusInterfaceIface:
  given _tag: Tag[_GDBusInterfaceIface] = Tag.materializeCStruct5Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GDBusInterface], Ptr[Byte]], CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]], CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit], CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]]
  def apply()(using Zone): Ptr[_GDBusInterfaceIface] = scala.scalanative.unsafe.alloc[_GDBusInterfaceIface](1)
  def apply(parent_iface : _root_.gobject.GTypeInterface, get_info : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]], get_object : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]], set_object : CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit], dup_object : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]])(using Zone): Ptr[_GDBusInterfaceIface] = 
    val ____ptr = apply()
    (!____ptr).parent_iface = parent_iface
    (!____ptr).get_info = get_info
    (!____ptr).get_object = get_object
    (!____ptr).set_object = set_object
    (!____ptr).dup_object = dup_object
    ____ptr
  extension (struct: _GDBusInterfaceIface)
    def parent_iface : _root_.gobject.GTypeInterface = struct._1
    def parent_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def get_info : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]] = struct._2.asInstanceOf[CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]]
    def get_info_=(value: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusInterfaceInfo]]): Unit = !struct.at2 = value.asInstanceOf[CFuncPtr1[Ptr[GDBusInterface], Ptr[Byte]]]
    def get_object : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]] = struct._3
    def get_object_=(value: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]): Unit = !struct.at3 = value
    def set_object : CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit] = struct._4
    def set_object_=(value: CFuncPtr2[Ptr[GDBusInterface], Ptr[GDBusObject], Unit]): Unit = !struct.at4 = value
    def dup_object : CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]] = struct._5
    def dup_object_=(value: CFuncPtr1[Ptr[GDBusInterface], Ptr[GDBusObject]]): Unit = !struct.at5 = value

/**
 * GDBusInterfaceInfo: _count: The reference count or -1 if statically allocated. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusInterfaceInfo = CStruct6[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte], Ptr[Byte], Ptr[Byte]]
object _GDBusInterfaceInfo:
  given _tag: Tag[_GDBusInterfaceInfo] = Tag.materializeCStruct6Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte], Ptr[Byte], Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusInterfaceInfo] = scala.scalanative.unsafe.alloc[_GDBusInterfaceInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], methods : Ptr[Ptr[GDBusMethodInfo]], signals : Ptr[Ptr[GDBusSignalInfo]], properties : Ptr[Ptr[GDBusPropertyInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusInterfaceInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).methods = methods
    (!____ptr).signals = signals
    (!____ptr).properties = properties
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusInterfaceInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def name : Ptr[_root_.glib.gchar] = struct._2
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def methods : Ptr[Ptr[GDBusMethodInfo]] = struct._3.asInstanceOf[Ptr[Ptr[GDBusMethodInfo]]]
    def methods_=(value: Ptr[Ptr[GDBusMethodInfo]]): Unit = !struct.at3 = value.asInstanceOf[Ptr[Byte]]
    def signals : Ptr[Ptr[GDBusSignalInfo]] = struct._4.asInstanceOf[Ptr[Ptr[GDBusSignalInfo]]]
    def signals_=(value: Ptr[Ptr[GDBusSignalInfo]]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]
    def properties : Ptr[Ptr[GDBusPropertyInfo]] = struct._5.asInstanceOf[Ptr[Ptr[GDBusPropertyInfo]]]
    def properties_=(value: Ptr[Ptr[GDBusPropertyInfo]]): Unit = !struct.at5 = value.asInstanceOf[Ptr[Byte]]
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._6.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at6 = value.asInstanceOf[Ptr[Byte]]

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterfaceskeleton.h
*/
opaque type _GDBusInterfaceSkeleton = CStruct2[_root_.gobject.GObject, Ptr[GDBusInterfaceSkeletonPrivate]]
object _GDBusInterfaceSkeleton:
  given _tag: Tag[_GDBusInterfaceSkeleton] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GDBusInterfaceSkeletonPrivate]]
  def apply()(using Zone): Ptr[_GDBusInterfaceSkeleton] = scala.scalanative.unsafe.alloc[_GDBusInterfaceSkeleton](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusInterfaceSkeletonPrivate])(using Zone): Ptr[_GDBusInterfaceSkeleton] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDBusInterfaceSkeleton)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GDBusInterfaceSkeletonPrivate] = struct._2
    def priv_=(value: Ptr[GDBusInterfaceSkeletonPrivate]): Unit = !struct.at2 = value

/**
 * GDBusInterfaceSkeletonClass: _class: The parent class. _info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details. _vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details. _properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties(). : Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush(). _authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterfaceskeleton.h
*/
opaque type _GDBusInterfaceSkeletonClass = CStruct8[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[Byte]], CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]], CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]], CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit], CArray[_root_.glib.gpointer, Nat._8], CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusInterfaceSkeletonClass:
  given _tag: Tag[_GDBusInterfaceSkeletonClass] = Tag.materializeCStruct8Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[Byte]], CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]], CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]], CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit], CArray[_root_.glib.gpointer, Nat._8], CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusInterfaceSkeletonClass] = scala.scalanative.unsafe.alloc[_GDBusInterfaceSkeletonClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_info : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]], get_vtable : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]], get_properties : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]], flush : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit], vfunc_padding : CArray[_root_.glib.gpointer, Nat._8], g_authorize_method : CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], signal_padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusInterfaceSkeletonClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_info = get_info
    (!____ptr).get_vtable = get_vtable
    (!____ptr).get_properties = get_properties
    (!____ptr).flush = flush
    (!____ptr).vfunc_padding = vfunc_padding
    (!____ptr).g_authorize_method = g_authorize_method
    (!____ptr).signal_padding = signal_padding
    ____ptr
  extension (struct: _GDBusInterfaceSkeletonClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_info : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]] = struct._2.asInstanceOf[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]]
    def get_info_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceInfo]]): Unit = !struct.at2 = value.asInstanceOf[CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[Byte]]]
    def get_vtable : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]] = struct._3
    def get_vtable_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusInterfaceVTable]]): Unit = !struct.at3 = value
    def get_properties : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]] = struct._4
    def get_properties_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Ptr[_root_.glib.GVariant]]): Unit = !struct.at4 = value
    def flush : CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit] = struct._5
    def flush_=(value: CFuncPtr1[Ptr[GDBusInterfaceSkeleton], Unit]): Unit = !struct.at5 = value
    def vfunc_padding : CArray[_root_.glib.gpointer, Nat._8] = struct._6
    def vfunc_padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at6 = value
    def g_authorize_method : CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean] = struct._7
    def g_authorize_method_=(value: CFuncPtr2[Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]): Unit = !struct.at7 = value
    def signal_padding : CArray[_root_.glib.gpointer, Nat._8] = struct._8
    def signal_padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusinterfaceskeleton.h
*/
opaque type _GDBusInterfaceSkeletonPrivate = CStruct0
object _GDBusInterfaceSkeletonPrivate:
  given _tag: Tag[_GDBusInterfaceSkeletonPrivate] = Tag.materializeCStruct0Tag

/**
 * GDBusInterfaceVTable: _property: Function for getting a property.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusconnection.h
*/
opaque type _GDBusInterfaceVTable = CStruct4[GDBusInterfaceMethodCallFunc, GDBusInterfaceGetPropertyFunc, GDBusInterfaceSetPropertyFunc, CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusInterfaceVTable:
  given _tag: Tag[_GDBusInterfaceVTable] = Tag.materializeCStruct4Tag[GDBusInterfaceMethodCallFunc, GDBusInterfaceGetPropertyFunc, GDBusInterfaceSetPropertyFunc, CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusInterfaceVTable] = scala.scalanative.unsafe.alloc[_GDBusInterfaceVTable](1)
  def apply(method_call : GDBusInterfaceMethodCallFunc, get_property : GDBusInterfaceGetPropertyFunc, set_property : GDBusInterfaceSetPropertyFunc, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusInterfaceVTable] = 
    val ____ptr = apply()
    (!____ptr).method_call = method_call
    (!____ptr).get_property = get_property
    (!____ptr).set_property = set_property
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusInterfaceVTable)
    def method_call : GDBusInterfaceMethodCallFunc = struct._1
    def method_call_=(value: GDBusInterfaceMethodCallFunc): Unit = !struct.at1 = value
    def get_property : GDBusInterfaceGetPropertyFunc = struct._2
    def get_property_=(value: GDBusInterfaceGetPropertyFunc): Unit = !struct.at2 = value
    def set_property : GDBusInterfaceSetPropertyFunc = struct._3
    def set_property_=(value: GDBusInterfaceSetPropertyFunc): Unit = !struct.at3 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._4
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusmenumodel.h
*/
opaque type _GDBusMenuModel = CStruct0
object _GDBusMenuModel:
  given _tag: Tag[_GDBusMenuModel] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusMessage = CStruct0
object _GDBusMessage:
  given _tag: Tag[_GDBusMessage] = Tag.materializeCStruct0Tag

/**
 * GDBusMethodInfo: _count: The reference count or -1 if statically allocated. _args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments. _args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusMethodInfo = CStruct5[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte], Ptr[Byte]]
object _GDBusMethodInfo:
  given _tag: Tag[_GDBusMethodInfo] = Tag.materializeCStruct5Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte], Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusMethodInfo] = scala.scalanative.unsafe.alloc[_GDBusMethodInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], in_args : Ptr[Ptr[GDBusArgInfo]], out_args : Ptr[Ptr[GDBusArgInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusMethodInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).in_args = in_args
    (!____ptr).out_args = out_args
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusMethodInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def name : Ptr[_root_.glib.gchar] = struct._2
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def in_args : Ptr[Ptr[GDBusArgInfo]] = struct._3.asInstanceOf[Ptr[Ptr[GDBusArgInfo]]]
    def in_args_=(value: Ptr[Ptr[GDBusArgInfo]]): Unit = !struct.at3 = value.asInstanceOf[Ptr[Byte]]
    def out_args : Ptr[Ptr[GDBusArgInfo]] = struct._4.asInstanceOf[Ptr[Ptr[GDBusArgInfo]]]
    def out_args_=(value: Ptr[Ptr[GDBusArgInfo]]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._5.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at5 = value.asInstanceOf[Ptr[Byte]]

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusMethodInvocation = CStruct0
object _GDBusMethodInvocation:
  given _tag: Tag[_GDBusMethodInvocation] = Tag.materializeCStruct0Tag

/**
 * GDBusNodeInfo: _count: The reference count or -1 if statically allocated. : The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusNodeInfo = CStruct5[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte], Ptr[Byte]]
object _GDBusNodeInfo:
  given _tag: Tag[_GDBusNodeInfo] = Tag.materializeCStruct5Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte], Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusNodeInfo] = scala.scalanative.unsafe.alloc[_GDBusNodeInfo](1)
  def apply(ref_count : _root_.glib.gint, path : Ptr[_root_.glib.gchar], interfaces : Ptr[Ptr[GDBusInterfaceInfo]], nodes : Ptr[Ptr[GDBusNodeInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusNodeInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).path = path
    (!____ptr).interfaces = interfaces
    (!____ptr).nodes = nodes
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusNodeInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def path : Ptr[_root_.glib.gchar] = struct._2
    def path_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def interfaces : Ptr[Ptr[GDBusInterfaceInfo]] = struct._3.asInstanceOf[Ptr[Ptr[GDBusInterfaceInfo]]]
    def interfaces_=(value: Ptr[Ptr[GDBusInterfaceInfo]]): Unit = !struct.at3 = value.asInstanceOf[Ptr[Byte]]
    def nodes : Ptr[Ptr[GDBusNodeInfo]] = struct._4.asInstanceOf[Ptr[Ptr[GDBusNodeInfo]]]
    def nodes_=(value: Ptr[Ptr[GDBusNodeInfo]]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._5.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at5 = value.asInstanceOf[Ptr[Byte]]

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusObject = CStruct0
object _GDBusObject:
  given _tag: Tag[_GDBusObject] = Tag.materializeCStruct0Tag

/**
 * GDBusObjectIface: _iface: The parent interface. _object_path: Returns the object path. See g_dbus_object_get_object_path(). _interfaces: Returns all interfaces. See g_dbus_object_get_interfaces(). _interface: Returns an interface by name. See g_dbus_object_get_interface().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobject.h
*/
opaque type _GDBusObjectIface = CStruct6[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GDBusObject], Ptr[Byte]], CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit], CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]
object _GDBusObjectIface:
  given _tag: Tag[_GDBusObjectIface] = Tag.materializeCStruct6Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GDBusObject], Ptr[Byte]], CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit], CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]
  def apply()(using Zone): Ptr[_GDBusObjectIface] = scala.scalanative.unsafe.alloc[_GDBusObjectIface](1)
  def apply(parent_iface : _root_.gobject.GTypeInterface, get_object_path : CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]], get_interfaces : CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]], get_interface : CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], interface_added : CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit], interface_removed : CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit])(using Zone): Ptr[_GDBusObjectIface] = 
    val ____ptr = apply()
    (!____ptr).parent_iface = parent_iface
    (!____ptr).get_object_path = get_object_path
    (!____ptr).get_interfaces = get_interfaces
    (!____ptr).get_interface = get_interface
    (!____ptr).interface_added = interface_added
    (!____ptr).interface_removed = interface_removed
    ____ptr
  extension (struct: _GDBusObjectIface)
    def parent_iface : _root_.gobject.GTypeInterface = struct._1
    def parent_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def get_object_path : CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]] = struct._2
    def get_object_path_=(value: CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.gchar]]): Unit = !struct.at2 = value
    def get_interfaces : CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]] = struct._3.asInstanceOf[CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]]
    def get_interfaces_=(value: CFuncPtr1[Ptr[GDBusObject], Ptr[_root_.glib.GList]]): Unit = !struct.at3 = value.asInstanceOf[CFuncPtr1[Ptr[GDBusObject], Ptr[Byte]]]
    def get_interface : CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]] = struct._4
    def get_interface_=(value: CFuncPtr2[Ptr[GDBusObject], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]): Unit = !struct.at4 = value
    def interface_added : CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = struct._5
    def interface_added_=(value: CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at5 = value
    def interface_removed : CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = struct._6
    def interface_removed_=(value: CFuncPtr2[Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusObjectManager = CStruct0
object _GDBusObjectManager:
  given _tag: Tag[_GDBusObjectManager] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerclient.h
*/
opaque type _GDBusObjectManagerClient = CStruct2[_root_.gobject.GObject, Ptr[GDBusObjectManagerClientPrivate]]
object _GDBusObjectManagerClient:
  given _tag: Tag[_GDBusObjectManagerClient] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GDBusObjectManagerClientPrivate]]
  def apply()(using Zone): Ptr[_GDBusObjectManagerClient] = scala.scalanative.unsafe.alloc[_GDBusObjectManagerClient](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectManagerClientPrivate])(using Zone): Ptr[_GDBusObjectManagerClient] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDBusObjectManagerClient)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GDBusObjectManagerClientPrivate] = struct._2
    def priv_=(value: Ptr[GDBusObjectManagerClientPrivate]): Unit = !struct.at2 = value

/**
 * GDBusObjectManagerClientClass: _class: The parent class.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerclient.h
*/
opaque type _GDBusObjectManagerClientClass = CStruct4[_root_.gobject.GObjectClass, CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusObjectManagerClientClass:
  given _tag: Tag[_GDBusObjectManagerClientClass] = Tag.materializeCStruct4Tag[_root_.gobject.GObjectClass, CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusObjectManagerClientClass] = scala.scalanative.unsafe.alloc[_GDBusObjectManagerClientClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, interface_proxy_signal : CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], interface_proxy_properties_changed : CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusObjectManagerClientClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).interface_proxy_signal = interface_proxy_signal
    (!____ptr).interface_proxy_properties_changed = interface_proxy_properties_changed
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusObjectManagerClientClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def interface_proxy_signal : CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = struct._2
    def interface_proxy_signal_=(value: CFuncPtr6[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at2 = value
    def interface_proxy_properties_changed : CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit] = struct._3
    def interface_proxy_properties_changed_=(value: CFuncPtr5[Ptr[GDBusObjectManagerClient], Ptr[GDBusObjectProxy], Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at3 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._4
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerclient.h
*/
opaque type _GDBusObjectManagerClientPrivate = CStruct0
object _GDBusObjectManagerClientPrivate:
  given _tag: Tag[_GDBusObjectManagerClientPrivate] = Tag.materializeCStruct0Tag

/**
 * GDBusObjectManagerIface: _iface: The parent interface. _object_path: Virtual function for g_dbus_object_manager_get_object_path(). _objects: Virtual function for g_dbus_object_manager_get_objects(). _object: Virtual function for g_dbus_object_manager_get_object(). _interface: Virtual function for g_dbus_object_manager_get_interface(). _added: Signal handler for the #GDBusObjectManager::object-added signal. _removed: Signal handler for the #GDBusObjectManager::object-removed signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanager.h
*/
opaque type _GDBusObjectManagerIface = CStruct9[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GDBusObjectManager], Ptr[Byte]], CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]], CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit], CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]
object _GDBusObjectManagerIface:
  given _tag: Tag[_GDBusObjectManagerIface] = Tag.materializeCStruct9Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GDBusObjectManager], Ptr[Byte]], CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]], CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit], CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]]
  def apply()(using Zone): Ptr[_GDBusObjectManagerIface] = scala.scalanative.unsafe.alloc[_GDBusObjectManagerIface](1)
  def apply(parent_iface : _root_.gobject.GTypeInterface, get_object_path : CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]], get_objects : CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]], get_object : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]], get_interface : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]], object_added : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], object_removed : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit], interface_added : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit], interface_removed : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit])(using Zone): Ptr[_GDBusObjectManagerIface] = 
    val ____ptr = apply()
    (!____ptr).parent_iface = parent_iface
    (!____ptr).get_object_path = get_object_path
    (!____ptr).get_objects = get_objects
    (!____ptr).get_object = get_object
    (!____ptr).get_interface = get_interface
    (!____ptr).object_added = object_added
    (!____ptr).object_removed = object_removed
    (!____ptr).interface_added = interface_added
    (!____ptr).interface_removed = interface_removed
    ____ptr
  extension (struct: _GDBusObjectManagerIface)
    def parent_iface : _root_.gobject.GTypeInterface = struct._1
    def parent_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def get_object_path : CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]] = struct._2
    def get_object_path_=(value: CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar]]): Unit = !struct.at2 = value
    def get_objects : CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]] = struct._3.asInstanceOf[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]]
    def get_objects_=(value: CFuncPtr1[Ptr[GDBusObjectManager], Ptr[_root_.glib.GList]]): Unit = !struct.at3 = value.asInstanceOf[CFuncPtr1[Ptr[GDBusObjectManager], Ptr[Byte]]]
    def get_object : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]] = struct._4
    def get_object_=(value: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[GDBusObject]]): Unit = !struct.at4 = value
    def get_interface : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]] = struct._5
    def get_interface_=(value: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[GDBusInterface]]): Unit = !struct.at5 = value
    def object_added : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit] = struct._6
    def object_added_=(value: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]): Unit = !struct.at6 = value
    def object_removed : CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit] = struct._7
    def object_removed_=(value: CFuncPtr2[Ptr[GDBusObjectManager], Ptr[GDBusObject], Unit]): Unit = !struct.at7 = value
    def interface_added : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = struct._8
    def interface_added_=(value: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at8 = value
    def interface_removed : CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit] = struct._9
    def interface_removed_=(value: CFuncPtr3[Ptr[GDBusObjectManager], Ptr[GDBusObject], Ptr[GDBusInterface], Unit]): Unit = !struct.at9 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerserver.h
*/
opaque type _GDBusObjectManagerServer = CStruct2[_root_.gobject.GObject, Ptr[GDBusObjectManagerServerPrivate]]
object _GDBusObjectManagerServer:
  given _tag: Tag[_GDBusObjectManagerServer] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GDBusObjectManagerServerPrivate]]
  def apply()(using Zone): Ptr[_GDBusObjectManagerServer] = scala.scalanative.unsafe.alloc[_GDBusObjectManagerServer](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectManagerServerPrivate])(using Zone): Ptr[_GDBusObjectManagerServer] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDBusObjectManagerServer)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GDBusObjectManagerServerPrivate] = struct._2
    def priv_=(value: Ptr[GDBusObjectManagerServerPrivate]): Unit = !struct.at2 = value

/**
 * GDBusObjectManagerServerClass: _class: The parent class.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerserver.h
*/
opaque type _GDBusObjectManagerServerClass = CStruct2[_root_.gobject.GObjectClass, CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusObjectManagerServerClass:
  given _tag: Tag[_GDBusObjectManagerServerClass] = Tag.materializeCStruct2Tag[_root_.gobject.GObjectClass, CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusObjectManagerServerClass] = scala.scalanative.unsafe.alloc[_GDBusObjectManagerServerClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusObjectManagerServerClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusObjectManagerServerClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._2
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectmanagerserver.h
*/
opaque type _GDBusObjectManagerServerPrivate = CStruct0
object _GDBusObjectManagerServerPrivate:
  given _tag: Tag[_GDBusObjectManagerServerPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectproxy.h
*/
opaque type _GDBusObjectProxy = CStruct2[_root_.gobject.GObject, Ptr[GDBusObjectProxyPrivate]]
object _GDBusObjectProxy:
  given _tag: Tag[_GDBusObjectProxy] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GDBusObjectProxyPrivate]]
  def apply()(using Zone): Ptr[_GDBusObjectProxy] = scala.scalanative.unsafe.alloc[_GDBusObjectProxy](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectProxyPrivate])(using Zone): Ptr[_GDBusObjectProxy] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDBusObjectProxy)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GDBusObjectProxyPrivate] = struct._2
    def priv_=(value: Ptr[GDBusObjectProxyPrivate]): Unit = !struct.at2 = value

/**
 * GDBusObjectProxyClass: _class: The parent class.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectproxy.h
*/
opaque type _GDBusObjectProxyClass = CStruct2[_root_.gobject.GObjectClass, CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusObjectProxyClass:
  given _tag: Tag[_GDBusObjectProxyClass] = Tag.materializeCStruct2Tag[_root_.gobject.GObjectClass, CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusObjectProxyClass] = scala.scalanative.unsafe.alloc[_GDBusObjectProxyClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusObjectProxyClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusObjectProxyClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._2
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectproxy.h
*/
opaque type _GDBusObjectProxyPrivate = CStruct0
object _GDBusObjectProxyPrivate:
  given _tag: Tag[_GDBusObjectProxyPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectskeleton.h
*/
opaque type _GDBusObjectSkeleton = CStruct2[_root_.gobject.GObject, Ptr[GDBusObjectSkeletonPrivate]]
object _GDBusObjectSkeleton:
  given _tag: Tag[_GDBusObjectSkeleton] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GDBusObjectSkeletonPrivate]]
  def apply()(using Zone): Ptr[_GDBusObjectSkeleton] = scala.scalanative.unsafe.alloc[_GDBusObjectSkeleton](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusObjectSkeletonPrivate])(using Zone): Ptr[_GDBusObjectSkeleton] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDBusObjectSkeleton)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GDBusObjectSkeletonPrivate] = struct._2
    def priv_=(value: Ptr[GDBusObjectSkeletonPrivate]): Unit = !struct.at2 = value

/**
 * GDBusObjectSkeletonClass: _class: The parent class. _method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectskeleton.h
*/
opaque type _GDBusObjectSkeletonClass = CStruct3[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusObjectSkeletonClass:
  given _tag: Tag[_GDBusObjectSkeletonClass] = Tag.materializeCStruct3Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusObjectSkeletonClass] = scala.scalanative.unsafe.alloc[_GDBusObjectSkeletonClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, authorize_method : CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusObjectSkeletonClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).authorize_method = authorize_method
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusObjectSkeletonClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def authorize_method : CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean] = struct._2
    def authorize_method_=(value: CFuncPtr3[Ptr[GDBusObjectSkeleton], Ptr[GDBusInterfaceSkeleton], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._3
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusobjectskeleton.h
*/
opaque type _GDBusObjectSkeletonPrivate = CStruct0
object _GDBusObjectSkeletonPrivate:
  given _tag: Tag[_GDBusObjectSkeletonPrivate] = Tag.materializeCStruct0Tag

/**
 * GDBusPropertyInfo: _count: The reference count or -1 if statically allocated. : The D-Bus signature of the property (a single complete type). : Access control flags for the property. : (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusPropertyInfo = CStruct5[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], GDBusPropertyInfoFlags, Ptr[Byte]]
object _GDBusPropertyInfo:
  given _tag: Tag[_GDBusPropertyInfo] = Tag.materializeCStruct5Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], GDBusPropertyInfoFlags, Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusPropertyInfo] = scala.scalanative.unsafe.alloc[_GDBusPropertyInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], signature : Ptr[_root_.glib.gchar], flags : GDBusPropertyInfoFlags, annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusPropertyInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).signature = signature
    (!____ptr).flags = flags
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusPropertyInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def name : Ptr[_root_.glib.gchar] = struct._2
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def signature : Ptr[_root_.glib.gchar] = struct._3
    def signature_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at3 = value
    def flags : GDBusPropertyInfoFlags = struct._4
    def flags_=(value: GDBusPropertyInfoFlags): Unit = !struct.at4 = value
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._5.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at5 = value.asInstanceOf[Ptr[Byte]]

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusproxy.h
*/
opaque type _GDBusProxy = CStruct2[_root_.gobject.GObject, Ptr[GDBusProxyPrivate]]
object _GDBusProxy:
  given _tag: Tag[_GDBusProxy] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GDBusProxyPrivate]]
  def apply()(using Zone): Ptr[_GDBusProxy] = scala.scalanative.unsafe.alloc[_GDBusProxy](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GDBusProxyPrivate])(using Zone): Ptr[_GDBusProxy] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDBusProxy)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GDBusProxyPrivate] = struct._2
    def priv_=(value: Ptr[GDBusProxyPrivate]): Unit = !struct.at2 = value

/**
 * GDBusProxyClass: _properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal. _signal: Signal class handler for the #GDBusProxy::g-signal signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusproxy.h
*/
opaque type _GDBusProxyClass = CStruct4[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]]]
object _GDBusProxyClass:
  given _tag: Tag[_GDBusProxyClass] = Tag.materializeCStruct4Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]]]
  def apply()(using Zone): Ptr[_GDBusProxyClass] = scala.scalanative.unsafe.alloc[_GDBusProxyClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, g_properties_changed : CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit], g_signal : CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]])(using Zone): Ptr[_GDBusProxyClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).g_properties_changed = g_properties_changed
    (!____ptr).g_signal = g_signal
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusProxyClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def g_properties_changed : CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit] = struct._2
    def g_properties_changed_=(value: CFuncPtr3[Ptr[GDBusProxy], Ptr[_root_.glib.GVariant], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at2 = value
    def g_signal : CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit] = struct._3
    def g_signal_=(value: CFuncPtr4[Ptr[GDBusProxy], Ptr[_root_.glib.gchar], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at3 = value
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]] = struct._4
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._3, Nat._2]]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusproxy.h
*/
opaque type _GDBusProxyPrivate = CStruct0
object _GDBusProxyPrivate:
  given _tag: Tag[_GDBusProxyPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDBusServer = CStruct0
object _GDBusServer:
  given _tag: Tag[_GDBusServer] = Tag.materializeCStruct0Tag

/**
 * GDBusSignalInfo: _count: The reference count or -1 if statically allocated.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusintrospection.h
*/
opaque type _GDBusSignalInfo = CStruct4[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte]]
object _GDBusSignalInfo:
  given _tag: Tag[_GDBusSignalInfo] = Tag.materializeCStruct4Tag[_root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[Byte], Ptr[Byte]]
  def apply()(using Zone): Ptr[_GDBusSignalInfo] = scala.scalanative.unsafe.alloc[_GDBusSignalInfo](1)
  def apply(ref_count : _root_.glib.gint, name : Ptr[_root_.glib.gchar], args : Ptr[Ptr[GDBusArgInfo]], annotations : Ptr[Ptr[GDBusAnnotationInfo]])(using Zone): Ptr[_GDBusSignalInfo] = 
    val ____ptr = apply()
    (!____ptr).ref_count = ref_count
    (!____ptr).name = name
    (!____ptr).args = args
    (!____ptr).annotations = annotations
    ____ptr
  extension (struct: _GDBusSignalInfo)
    def ref_count : _root_.glib.gint = struct._1
    def ref_count_=(value: _root_.glib.gint): Unit = !struct.at1 = value
    def name : Ptr[_root_.glib.gchar] = struct._2
    def name_=(value: Ptr[_root_.glib.gchar]): Unit = !struct.at2 = value
    def args : Ptr[Ptr[GDBusArgInfo]] = struct._3.asInstanceOf[Ptr[Ptr[GDBusArgInfo]]]
    def args_=(value: Ptr[Ptr[GDBusArgInfo]]): Unit = !struct.at3 = value.asInstanceOf[Ptr[Byte]]
    def annotations : Ptr[Ptr[GDBusAnnotationInfo]] = struct._4.asInstanceOf[Ptr[Ptr[GDBusAnnotationInfo]]]
    def annotations_=(value: Ptr[Ptr[GDBusAnnotationInfo]]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]

/**
 * GDBusSubtreeVTable: : Function for enumerating child nodes. : Function for introspecting a child node. : Function for dispatching a remote call on a child node.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdbusconnection.h
*/
opaque type _GDBusSubtreeVTable = CStruct4[GDBusSubtreeEnumerateFunc, Ptr[Byte], GDBusSubtreeDispatchFunc, CArray[_root_.glib.gpointer, Nat._8]]
object _GDBusSubtreeVTable:
  given _tag: Tag[_GDBusSubtreeVTable] = Tag.materializeCStruct4Tag[GDBusSubtreeEnumerateFunc, Ptr[Byte], GDBusSubtreeDispatchFunc, CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GDBusSubtreeVTable] = scala.scalanative.unsafe.alloc[_GDBusSubtreeVTable](1)
  def apply(enumerate : GDBusSubtreeEnumerateFunc, introspect : GDBusSubtreeIntrospectFunc, dispatch : GDBusSubtreeDispatchFunc, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GDBusSubtreeVTable] = 
    val ____ptr = apply()
    (!____ptr).enumerate = enumerate
    (!____ptr).introspect = introspect
    (!____ptr).dispatch = dispatch
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDBusSubtreeVTable)
    def enumerate : GDBusSubtreeEnumerateFunc = struct._1
    def enumerate_=(value: GDBusSubtreeEnumerateFunc): Unit = !struct.at1 = value
    def introspect : GDBusSubtreeIntrospectFunc = struct._2.asInstanceOf[GDBusSubtreeIntrospectFunc]
    def introspect_=(value: GDBusSubtreeIntrospectFunc): Unit = !struct.at2 = value.asInstanceOf[Ptr[Byte]]
    def dispatch : GDBusSubtreeDispatchFunc = struct._3
    def dispatch_=(value: GDBusSubtreeDispatchFunc): Unit = !struct.at3 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._4
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatainputstream.h
*/
opaque type _GDataInputStream = CStruct2[GBufferedInputStream, Ptr[GDataInputStreamPrivate]]
object _GDataInputStream:
  given _tag: Tag[_GDataInputStream] = Tag.materializeCStruct2Tag[GBufferedInputStream, Ptr[GDataInputStreamPrivate]]
  def apply()(using Zone): Ptr[_GDataInputStream] = scala.scalanative.unsafe.alloc[_GDataInputStream](1)
  def apply(parent_instance : GBufferedInputStream, priv : Ptr[GDataInputStreamPrivate])(using Zone): Ptr[_GDataInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDataInputStream)
    def parent_instance : GBufferedInputStream = struct._1
    def parent_instance_=(value: GBufferedInputStream): Unit = !struct.at1 = value
    def priv : Ptr[GDataInputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GDataInputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatainputstream.h
*/
opaque type _GDataInputStreamClass = CStruct6[GBufferedInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GDataInputStreamClass:
  given _tag: Tag[_GDataInputStreamClass] = Tag.materializeCStruct6Tag[GBufferedInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GDataInputStreamClass] = scala.scalanative.unsafe.alloc[_GDataInputStreamClass](1)
  def apply(parent_class : GBufferedInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GDataInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GDataInputStreamClass)
    def parent_class : GBufferedInputStreamClass = struct._1
    def parent_class_=(value: GBufferedInputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatainputstream.h
*/
opaque type _GDataInputStreamPrivate = CStruct0
object _GDataInputStreamPrivate:
  given _tag: Tag[_GDataInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdataoutputstream.h
*/
opaque type _GDataOutputStream = CStruct2[GFilterOutputStream, Ptr[GDataOutputStreamPrivate]]
object _GDataOutputStream:
  given _tag: Tag[_GDataOutputStream] = Tag.materializeCStruct2Tag[GFilterOutputStream, Ptr[GDataOutputStreamPrivate]]
  def apply()(using Zone): Ptr[_GDataOutputStream] = scala.scalanative.unsafe.alloc[_GDataOutputStream](1)
  def apply(parent_instance : GFilterOutputStream, priv : Ptr[GDataOutputStreamPrivate])(using Zone): Ptr[_GDataOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GDataOutputStream)
    def parent_instance : GFilterOutputStream = struct._1
    def parent_instance_=(value: GFilterOutputStream): Unit = !struct.at1 = value
    def priv : Ptr[GDataOutputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GDataOutputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdataoutputstream.h
*/
opaque type _GDataOutputStreamClass = CStruct6[GFilterOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GDataOutputStreamClass:
  given _tag: Tag[_GDataOutputStreamClass] = Tag.materializeCStruct6Tag[GFilterOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GDataOutputStreamClass] = scala.scalanative.unsafe.alloc[_GDataOutputStreamClass](1)
  def apply(parent_class : GFilterOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GDataOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GDataOutputStreamClass)
    def parent_class : GFilterOutputStreamClass = struct._1
    def parent_class_=(value: GFilterOutputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdataoutputstream.h
*/
opaque type _GDataOutputStreamPrivate = CStruct0
object _GDataOutputStreamPrivate:
  given _tag: Tag[_GDataOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDatagramBased = CStruct0
object _GDatagramBased:
  given _tag: Tag[_GDatagramBased] = Tag.materializeCStruct0Tag

/**
 * GDatagramBasedInterface: _iface: The parent interface. _messages: Virtual method for g_datagram_based_receive_messages(). _messages: Virtual method for g_datagram_based_send_messages(). _source: Virtual method for g_datagram_based_create_source(). _check: Virtual method for g_datagram_based_condition_check(). _wait: Virtual method for g_datagram_based_condition_wait().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdatagrambased.h
*/
opaque type _GDatagramBasedInterface = CStruct6[_root_.gobject.GTypeInterface, CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[Byte]], CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition], CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GDatagramBasedInterface:
  given _tag: Tag[_GDatagramBasedInterface] = Tag.materializeCStruct6Tag[_root_.gobject.GTypeInterface, CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[Byte]], CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition], CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GDatagramBasedInterface] = scala.scalanative.unsafe.alloc[_GDatagramBasedInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, receive_messages : CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], send_messages : CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint], create_source : CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]], condition_check : CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition], condition_wait : CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GDatagramBasedInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).receive_messages = receive_messages
    (!____ptr).send_messages = send_messages
    (!____ptr).create_source = create_source
    (!____ptr).condition_check = condition_check
    (!____ptr).condition_wait = condition_wait
    ____ptr
  extension (struct: _GDatagramBasedInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def receive_messages : CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint] = struct._2
    def receive_messages_=(value: CFuncPtr7[Ptr[GDatagramBased], Ptr[GInputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]): Unit = !struct.at2 = value
    def send_messages : CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint] = struct._3
    def send_messages_=(value: CFuncPtr7[Ptr[GDatagramBased], Ptr[GOutputMessage], _root_.glib.guint, _root_.glib.gint, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gint]): Unit = !struct.at3 = value
    def create_source : CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]] = struct._4.asInstanceOf[CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]]
    def create_source_=(value: CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[_root_.glib.GSource]]): Unit = !struct.at4 = value.asInstanceOf[CFuncPtr3[Ptr[GDatagramBased], _root_.glib.GIOCondition, Ptr[GCancellable], Ptr[Byte]]]
    def condition_check : CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition] = struct._5
    def condition_check_=(value: CFuncPtr2[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.GIOCondition]): Unit = !struct.at5 = value
    def condition_wait : CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def condition_wait_=(value: CFuncPtr5[Ptr[GDatagramBased], _root_.glib.GIOCondition, _root_.glib.gint64, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value

opaque type _GDebugController = CStruct0
object _GDebugController:
  given _tag: Tag[_GDebugController] = Tag.materializeCStruct0Tag

opaque type _GDebugControllerDBus = CStruct1[_root_.gobject.GObject]
object _GDebugControllerDBus:
  given _tag: Tag[_GDebugControllerDBus] = Tag.materializeCStruct1Tag[_root_.gobject.GObject]
  def apply()(using Zone): Ptr[_GDebugControllerDBus] = scala.scalanative.unsafe.alloc[_GDebugControllerDBus](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[_GDebugControllerDBus] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: _GDebugControllerDBus)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value

/**
 * GDebugControllerDBusClass: _class: The parent class. : Default handler for the #GDebugControllerDBus::authorize signal.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdebugcontrollerdbus.h
*/
opaque type _GDebugControllerDBusClass = CStruct3[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]
object _GDebugControllerDBusClass:
  given _tag: Tag[_GDebugControllerDBusClass] = Tag.materializeCStruct3Tag[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]
  def apply()(using Zone): Ptr[_GDebugControllerDBusClass] = scala.scalanative.unsafe.alloc[_GDebugControllerDBusClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, authorize : CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]])(using Zone): Ptr[_GDebugControllerDBusClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).authorize = authorize
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GDebugControllerDBusClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def authorize : CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean] = struct._2
    def authorize_=(value: CFuncPtr2[Ptr[GDebugControllerDBus], Ptr[GDBusMethodInvocation], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]] = struct._3
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]): Unit = !struct.at3 = value

/**
 * GDebugControllerInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdebugcontroller.h
*/
opaque type _GDebugControllerInterface = CStruct1[_root_.gobject.GTypeInterface]
object _GDebugControllerInterface:
  given _tag: Tag[_GDebugControllerInterface] = Tag.materializeCStruct1Tag[_root_.gobject.GTypeInterface]
  def apply()(using Zone): Ptr[_GDebugControllerInterface] = scala.scalanative.unsafe.alloc[_GDebugControllerInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[_GDebugControllerInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: _GDebugControllerInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDrive = CStruct0
object _GDrive:
  given _tag: Tag[_GDrive] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdrive.h
*/
opaque type _GDriveIface = CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]]
object _GDriveIface:
  given _tag: Tag[_GDriveIface] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._7, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._7, Nat._2](Tag.Nat2, Tag.Nat7, Tag.Nat2))
  def apply()(using Zone): Ptr[_GDriveIface] = scala.scalanative.unsafe.alloc[_GDriveIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, changed : CFuncPtr1[Ptr[GDrive], Unit], disconnected : CFuncPtr1[Ptr[GDrive], Unit], eject_button : CFuncPtr1[Ptr[GDrive], Unit], get_name : CFuncPtr1[Ptr[GDrive], CString], get_icon : CFuncPtr1[Ptr[GDrive], Ptr[GIcon]], has_volumes : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], get_volumes : CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]], is_media_removable : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], has_media : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], is_media_check_automatic : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], can_eject : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], can_poll_for_media : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], eject : CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], poll_for_media : CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], poll_for_media_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_identifier : CFuncPtr2[Ptr[GDrive], CString, CString], enumerate_identifiers : CFuncPtr1[Ptr[GDrive], Ptr[CString]], get_start_stop_type : CFuncPtr1[Ptr[GDrive], GDriveStartStopType], can_start : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], can_start_degraded : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], start : CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], start_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_stop : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean], stop : CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], stop_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], stop_button : CFuncPtr1[Ptr[GDrive], Unit], eject_with_operation : CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_with_operation_finish : CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_sort_key : CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]], get_symbolic_icon : CFuncPtr1[Ptr[GDrive], Ptr[GIcon]], is_removable : CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean])(using Zone): Ptr[_GDriveIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).changed = changed
    (!____ptr).disconnected = disconnected
    (!____ptr).eject_button = eject_button
    (!____ptr).get_name = get_name
    (!____ptr).get_icon = get_icon
    (!____ptr).has_volumes = has_volumes
    (!____ptr).get_volumes = get_volumes
    (!____ptr).is_media_removable = is_media_removable
    (!____ptr).has_media = has_media
    (!____ptr).is_media_check_automatic = is_media_check_automatic
    (!____ptr).can_eject = can_eject
    (!____ptr).can_poll_for_media = can_poll_for_media
    (!____ptr).eject = eject
    (!____ptr).eject_finish = eject_finish
    (!____ptr).poll_for_media = poll_for_media
    (!____ptr).poll_for_media_finish = poll_for_media_finish
    (!____ptr).get_identifier = get_identifier
    (!____ptr).enumerate_identifiers = enumerate_identifiers
    (!____ptr).get_start_stop_type = get_start_stop_type
    (!____ptr).can_start = can_start
    (!____ptr).can_start_degraded = can_start_degraded
    (!____ptr).start = start
    (!____ptr).start_finish = start_finish
    (!____ptr).can_stop = can_stop
    (!____ptr).stop = stop
    (!____ptr).stop_finish = stop_finish
    (!____ptr).stop_button = stop_button
    (!____ptr).eject_with_operation = eject_with_operation
    (!____ptr).eject_with_operation_finish = eject_with_operation_finish
    (!____ptr).get_sort_key = get_sort_key
    (!____ptr).get_symbolic_icon = get_symbolic_icon
    (!____ptr).is_removable = is_removable
    ____ptr
  extension (struct: _GDriveIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def changed: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def changed_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def disconnected: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def disconnected_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def eject_button: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def eject_button_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def get_name: CFuncPtr1[Ptr[GDrive], CString] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GDrive], CString]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]] = value
    def has_volumes: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def has_volumes_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def get_volumes: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]]]
    def get_volumes_=(value: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]]] = value
    def is_media_removable: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def is_media_removable_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def has_media: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def has_media_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def is_media_check_automatic: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def is_media_check_automatic_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def can_eject: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_eject_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def can_poll_for_media: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_poll_for_media_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def eject: CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_=(value: CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def poll_for_media: CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def poll_for_media_=(value: CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def poll_for_media_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def poll_for_media_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_identifier: CFuncPtr2[Ptr[GDrive], CString, CString] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDrive], CString, CString]]]
    def get_identifier_=(value: CFuncPtr2[Ptr[GDrive], CString, CString]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GDrive], CString, CString]]] = value
    def enumerate_identifiers: CFuncPtr1[Ptr[GDrive], Ptr[CString]] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[CString]]]]
    def enumerate_identifiers_=(value: CFuncPtr1[Ptr[GDrive], Ptr[CString]]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[CString]]]] = value
    def get_start_stop_type: CFuncPtr1[Ptr[GDrive], GDriveStartStopType] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]]]
    def get_start_stop_type_=(value: CFuncPtr1[Ptr[GDrive], GDriveStartStopType]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]]] = value
    def can_start: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_start_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def can_start_degraded: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_start_degraded_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def start: CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def start_=(value: CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def start_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def start_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def can_stop: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def can_stop_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
    def stop: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def stop_=(value: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def stop_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def stop_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def stop_button: CFuncPtr1[Ptr[GDrive], Unit] = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]]
    def stop_button_=(value: CFuncPtr1[Ptr[GDrive], Unit]): Unit = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Unit]]] = value
    def eject_with_operation: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_with_operation_=(value: CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_with_operation_finish: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_with_operation_finish_=(value: CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_sort_key: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]] = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]]]
    def get_sort_key_=(value: CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]]] = value
    def get_symbolic_icon: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]] = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]]
    def get_symbolic_icon_=(value: CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]): Unit = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]]] = value
    def is_removable: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean] = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]]
    def is_removable_=(value: CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]): Unit = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](33)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], CString]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GDrive], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr5[Ptr[GDrive], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr4[Ptr[GDrive], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GDrive], CString, CString]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr2[Ptr[GDrive], CString, CString]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[CString]]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[CString]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr1[Ptr[GDrive], GDriveStartStopType]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr6[Ptr[GDrive], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(26) = align(res(25) + sizeof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(27) = align(res(26) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Unit]].toInt)
    res(28) = align(res(27) + sizeof[CFuncPtr1[Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(29) = align(res(28) + sizeof[CFuncPtr6[Ptr[GDrive], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(30) = align(res(29) + sizeof[CFuncPtr3[Ptr[GDrive], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]].toInt)
    res(31) = align(res(30) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt)
    res(32) = align(res(31) + sizeof[CFuncPtr1[Ptr[GDrive], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GDrive], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDtlsClientConnection = CStruct0
object _GDtlsClientConnection:
  given _tag: Tag[_GDtlsClientConnection] = Tag.materializeCStruct0Tag

/**
 * GDtlsClientConnectionInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdtlsclientconnection.h
*/
opaque type _GDtlsClientConnectionInterface = CStruct1[_root_.gobject.GTypeInterface]
object _GDtlsClientConnectionInterface:
  given _tag: Tag[_GDtlsClientConnectionInterface] = Tag.materializeCStruct1Tag[_root_.gobject.GTypeInterface]
  def apply()(using Zone): Ptr[_GDtlsClientConnectionInterface] = scala.scalanative.unsafe.alloc[_GDtlsClientConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[_GDtlsClientConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: _GDtlsClientConnectionInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDtlsConnection = CStruct0
object _GDtlsConnection:
  given _tag: Tag[_GDtlsConnection] = Tag.materializeCStruct0Tag

/**
 * GDtlsConnectionInterface: _iface: The parent interface. _certificate: Check whether to accept a certificate. : Perform a handshake operation. _async: Start an asynchronous handshake operation. _finish: Finish an asynchronous handshake operation. : Shut down one or both directions of the connection. _async: Start an asynchronous shutdown operation. _finish: Finish an asynchronous shutdown operation.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdtlsconnection.h
*/
opaque type _GDtlsConnectionInterface = CStruct11[_root_.gobject.GTypeInterface, CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit], CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]], CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GDtlsConnectionInterface:
  given _tag: Tag[_GDtlsConnectionInterface] = Tag.materializeCStruct11Tag[_root_.gobject.GTypeInterface, CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit], CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]], CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GDtlsConnectionInterface] = scala.scalanative.unsafe.alloc[_GDtlsConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, accept_certificate : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], handshake : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], handshake_async : CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], handshake_finish : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], shutdown : CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], shutdown_async : CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], shutdown_finish : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_advertised_protocols : CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit], get_negotiated_protocol : CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]], get_binding_data : CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GDtlsConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).accept_certificate = accept_certificate
    (!____ptr).handshake = handshake
    (!____ptr).handshake_async = handshake_async
    (!____ptr).handshake_finish = handshake_finish
    (!____ptr).shutdown = shutdown
    (!____ptr).shutdown_async = shutdown_async
    (!____ptr).shutdown_finish = shutdown_finish
    (!____ptr).set_advertised_protocols = set_advertised_protocols
    (!____ptr).get_negotiated_protocol = get_negotiated_protocol
    (!____ptr).get_binding_data = get_binding_data
    ____ptr
  extension (struct: _GDtlsConnectionInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def accept_certificate : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean] = struct._2
    def accept_certificate_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]): Unit = !struct.at2 = value
    def handshake : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._3
    def handshake_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def handshake_async : CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._4
    def handshake_async_=(value: CFuncPtr5[Ptr[GDtlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at4 = value
    def handshake_finish : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._5
    def handshake_finish_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def shutdown : CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def shutdown_=(value: CFuncPtr5[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def shutdown_async : CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._7
    def shutdown_async_=(value: CFuncPtr7[Ptr[GDtlsConnection], _root_.glib.gboolean, _root_.glib.gboolean, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at7 = value
    def shutdown_finish : CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._8
    def shutdown_finish_=(value: CFuncPtr3[Ptr[GDtlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at8 = value
    def set_advertised_protocols : CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit] = struct._9
    def set_advertised_protocols_=(value: CFuncPtr2[Ptr[GDtlsConnection], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at9 = value
    def get_negotiated_protocol : CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]] = struct._10
    def get_negotiated_protocol_=(value: CFuncPtr1[Ptr[GDtlsConnection], Ptr[_root_.glib.gchar]]): Unit = !struct.at10 = value
    def get_binding_data : CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._11
    def get_binding_data_=(value: CFuncPtr4[Ptr[GDtlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at11 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GDtlsServerConnection = CStruct0
object _GDtlsServerConnection:
  given _tag: Tag[_GDtlsServerConnection] = Tag.materializeCStruct0Tag

/**
 * GDtlsServerConnectionInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gdtlsserverconnection.h
*/
opaque type _GDtlsServerConnectionInterface = CStruct1[_root_.gobject.GTypeInterface]
object _GDtlsServerConnectionInterface:
  given _tag: Tag[_GDtlsServerConnectionInterface] = Tag.materializeCStruct1Tag[_root_.gobject.GTypeInterface]
  def apply()(using Zone): Ptr[_GDtlsServerConnectionInterface] = scala.scalanative.unsafe.alloc[_GDtlsServerConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[_GDtlsServerConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: _GDtlsServerConnectionInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblem.h
*/
opaque type _GEmblem = CStruct0
object _GEmblem:
  given _tag: Tag[_GEmblem] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblem.h
*/
opaque type _GEmblemClass = CStruct0
object _GEmblemClass:
  given _tag: Tag[_GEmblemClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblemedicon.h
*/
opaque type _GEmblemedIcon = CStruct2[_root_.gobject.GObject, Ptr[GEmblemedIconPrivate]]
object _GEmblemedIcon:
  given _tag: Tag[_GEmblemedIcon] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GEmblemedIconPrivate]]
  def apply()(using Zone): Ptr[_GEmblemedIcon] = scala.scalanative.unsafe.alloc[_GEmblemedIcon](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GEmblemedIconPrivate])(using Zone): Ptr[_GEmblemedIcon] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GEmblemedIcon)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GEmblemedIconPrivate] = struct._2
    def priv_=(value: Ptr[GEmblemedIconPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblemedicon.h
*/
opaque type _GEmblemedIconClass = CStruct1[_root_.gobject.GObjectClass]
object _GEmblemedIconClass:
  given _tag: Tag[_GEmblemedIconClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GEmblemedIconClass] = scala.scalanative.unsafe.alloc[_GEmblemedIconClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GEmblemedIconClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GEmblemedIconClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gemblemedicon.h
*/
opaque type _GEmblemedIconPrivate = CStruct0
object _GEmblemedIconPrivate:
  given _tag: Tag[_GEmblemedIconPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GFile = CStruct0
object _GFile:
  given _tag: Tag[_GFile] = Tag.materializeCStruct0Tag

/**
 * GFileAttributeInfo: : the #GFileAttributeType type of the attribute. : a set of #GFileAttributeInfoFlags.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileattribute.h
*/
opaque type _GFileAttributeInfo = CStruct3[CString, GFileAttributeType, GFileAttributeInfoFlags]
object _GFileAttributeInfo:
  given _tag: Tag[_GFileAttributeInfo] = Tag.materializeCStruct3Tag[CString, GFileAttributeType, GFileAttributeInfoFlags]
  def apply()(using Zone): Ptr[_GFileAttributeInfo] = scala.scalanative.unsafe.alloc[_GFileAttributeInfo](1)
  def apply(name : CString, `type` : GFileAttributeType, flags : GFileAttributeInfoFlags)(using Zone): Ptr[_GFileAttributeInfo] = 
    val ____ptr = apply()
    (!____ptr).name = name
    (!____ptr).`type` = `type`
    (!____ptr).flags = flags
    ____ptr
  extension (struct: _GFileAttributeInfo)
    def name : CString = struct._1
    def name_=(value: CString): Unit = !struct.at1 = value
    def `type` : GFileAttributeType = struct._2
    def type_=(value: GFileAttributeType): Unit = !struct.at2 = value
    def flags : GFileAttributeInfoFlags = struct._3
    def flags_=(value: GFileAttributeInfoFlags): Unit = !struct.at3 = value

/**
 * GFileAttributeInfoList: : an array of #GFileAttributeInfos. _infos: the number of values in the array.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileattribute.h
*/
opaque type _GFileAttributeInfoList = CStruct2[Ptr[GFileAttributeInfo], CInt]
object _GFileAttributeInfoList:
  given _tag: Tag[_GFileAttributeInfoList] = Tag.materializeCStruct2Tag[Ptr[GFileAttributeInfo], CInt]
  def apply()(using Zone): Ptr[_GFileAttributeInfoList] = scala.scalanative.unsafe.alloc[_GFileAttributeInfoList](1)
  def apply(infos : Ptr[GFileAttributeInfo], n_infos : CInt)(using Zone): Ptr[_GFileAttributeInfoList] = 
    val ____ptr = apply()
    (!____ptr).infos = infos
    (!____ptr).n_infos = n_infos
    ____ptr
  extension (struct: _GFileAttributeInfoList)
    def infos : Ptr[GFileAttributeInfo] = struct._1
    def infos_=(value: Ptr[GFileAttributeInfo]): Unit = !struct.at1 = value
    def n_infos : CInt = struct._2
    def n_infos_=(value: CInt): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GFileAttributeMatcher = CStruct0
object _GFileAttributeMatcher:
  given _tag: Tag[_GFileAttributeMatcher] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileenumerator.h
*/
opaque type _GFileEnumerator = CStruct2[_root_.gobject.GObject, Ptr[GFileEnumeratorPrivate]]
object _GFileEnumerator:
  given _tag: Tag[_GFileEnumerator] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GFileEnumeratorPrivate]]
  def apply()(using Zone): Ptr[_GFileEnumerator] = scala.scalanative.unsafe.alloc[_GFileEnumerator](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GFileEnumeratorPrivate])(using Zone): Ptr[_GFileEnumerator] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GFileEnumerator)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GFileEnumeratorPrivate] = struct._2
    def priv_=(value: Ptr[GFileEnumeratorPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileenumerator.h
*/
opaque type _GFileEnumeratorClass = CStruct14[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFileEnumeratorClass:
  given _tag: Tag[_GFileEnumeratorClass] = Tag.materializeCStruct14Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFileEnumeratorClass] = scala.scalanative.unsafe.alloc[_GFileEnumeratorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, next_file : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], close_fn : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], next_files_async : CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], next_files_finish : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], close_async : CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit])(using Zone): Ptr[_GFileEnumeratorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).next_file = next_file
    (!____ptr).close_fn = close_fn
    (!____ptr).next_files_async = next_files_async
    (!____ptr).next_files_finish = next_files_finish
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    ____ptr
  extension (struct: _GFileEnumeratorClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def next_file : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._2
    def next_file_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at2 = value
    def close_fn : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._3
    def close_fn_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def next_files_async : CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._4
    def next_files_async_=(value: CFuncPtr6[Ptr[GFileEnumerator], CInt, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at4 = value
    def next_files_finish : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._5.asInstanceOf[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def next_files_finish_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at5 = value.asInstanceOf[CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def close_async : CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._6
    def close_async_=(value: CFuncPtr5[Ptr[GFileEnumerator], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at6 = value
    def close_finish : CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._7
    def close_finish_=(value: CFuncPtr3[Ptr[GFileEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at7 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._8
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._9
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._10
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at10 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._11
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._12
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._13
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved7 : CFuncPtr0[Unit] = struct._14
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileenumerator.h
*/
opaque type _GFileEnumeratorPrivate = CStruct0
object _GFileEnumeratorPrivate:
  given _tag: Tag[_GFileEnumeratorPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileiostream.h
*/
opaque type _GFileIOStream = CStruct2[GIOStream, Ptr[GFileIOStreamPrivate]]
object _GFileIOStream:
  given _tag: Tag[_GFileIOStream] = Tag.materializeCStruct2Tag[GIOStream, Ptr[GFileIOStreamPrivate]]
  def apply()(using Zone): Ptr[_GFileIOStream] = scala.scalanative.unsafe.alloc[_GFileIOStream](1)
  def apply(parent_instance : GIOStream, priv : Ptr[GFileIOStreamPrivate])(using Zone): Ptr[_GFileIOStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GFileIOStream)
    def parent_instance : GIOStream = struct._1
    def parent_instance_=(value: GIOStream): Unit = !struct.at1 = value
    def priv : Ptr[GFileIOStreamPrivate] = struct._2
    def priv_=(value: Ptr[GFileIOStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileiostream.h
*/
opaque type _GFileIOStreamClass = CStruct15[GIOStreamClass, CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset], CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr1[Ptr[GFileIOStream], CString], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFileIOStreamClass:
  given _tag: Tag[_GFileIOStreamClass] = Tag.materializeCStruct15Tag[GIOStreamClass, CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset], CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr1[Ptr[GFileIOStream], CString], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFileIOStreamClass] = scala.scalanative.unsafe.alloc[_GFileIOStreamClass](1)
  def apply(parent_class : GIOStreamClass, tell : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_truncate : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean], truncate_fn : CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], query_info : CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], get_etag : CFuncPtr1[Ptr[GFileIOStream], CString], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GFileIOStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).can_truncate = can_truncate
    (!____ptr).truncate_fn = truncate_fn
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr).get_etag = get_etag
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GFileIOStreamClass)
    def parent_class : GIOStreamClass = struct._1
    def parent_class_=(value: GIOStreamClass): Unit = !struct.at1 = value
    def tell : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset] = struct._2
    def tell_=(value: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.goffset]): Unit = !struct.at2 = value
    def can_seek : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean] = struct._3
    def can_seek_=(value: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def seek : CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def seek_=(value: CFuncPtr5[Ptr[GFileIOStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def can_truncate : CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean] = struct._5
    def can_truncate_=(value: CFuncPtr1[Ptr[GFileIOStream], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def truncate_fn : CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def truncate_fn_=(value: CFuncPtr4[Ptr[GFileIOStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def query_info : CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._7
    def query_info_=(value: CFuncPtr4[Ptr[GFileIOStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at7 = value
    def query_info_async : CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._8
    def query_info_async_=(value: CFuncPtr6[Ptr[GFileIOStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at8 = value
    def query_info_finish : CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._9
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFileIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at9 = value
    def get_etag : CFuncPtr1[Ptr[GFileIOStream], CString] = struct._10
    def get_etag_=(value: CFuncPtr1[Ptr[GFileIOStream], CString]): Unit = !struct.at10 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._11
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._12
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._13
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._14
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._15
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at15 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileiostream.h
*/
opaque type _GFileIOStreamPrivate = CStruct0
object _GFileIOStreamPrivate:
  given _tag: Tag[_GFileIOStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GFileIcon = CStruct0
object _GFileIcon:
  given _tag: Tag[_GFileIcon] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileicon.h
*/
opaque type _GFileIconClass = CStruct0
object _GFileIconClass:
  given _tag: Tag[_GFileIconClass] = Tag.materializeCStruct0Tag

/**
 * GFileIface: _iface: The parent interface. : Duplicates a #GFile. : Creates a hash of a #GFile. : Checks equality of two given #GFiles. _uri_scheme: Checks to see if a #GFile has a given URI scheme. _uri_scheme: Gets the URI scheme for a #GFile. _basename: Gets the basename for a given #GFile. _path: Gets the current path within a #GFile. _uri: Gets a URI for the path within a #GFile. _parse_name: Gets the parsed name for the #GFile. _parent: Gets the parent directory for the #GFile. _matches: Checks whether a #GFile contains a specified file. _relative_path: Gets the path for a #GFile relative to a given path. _relative_path: Resolves a relative path for a #GFile to an absolute path. _child_for_display_name: Gets the child #GFile for a given display name. _children: Gets a #GFileEnumerator with the children of a #GFile. _children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile. _children_finish: Finishes asynchronously enumerating the children. _info: Gets the #GFileInfo for a #GFile. _info_async: Asynchronously gets the #GFileInfo for a #GFile. _info_finish: Finishes an asynchronous query info operation. _filesystem_info: Gets a #GFileInfo for the file system #GFile is on. _filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on. _filesystem_info_finish: Finishes asynchronously getting the file system info. _enclosing_mount: Gets a #GMount for the #GFile. _enclosing_mount_async: Asynchronously gets the #GMount for a #GFile. _enclosing_mount_finish: Finishes asynchronously getting the volume.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfile.h
*/
opaque type _GFileIface = CArray[CChar, Nat.Digit3[Nat._8, Nat._4, Nat._0]]
object _GFileIface:
  given _tag: Tag[_GFileIface] = Tag.CArray[CChar, Nat.Digit3[Nat._8, Nat._4, Nat._0]](Tag.Byte, Tag.Digit3[Nat._8, Nat._4, Nat._0](Tag.Nat8, Tag.Nat4, Tag.Nat0))
  def apply()(using Zone): Ptr[_GFileIface] = scala.scalanative.unsafe.alloc[_GFileIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, dup : CFuncPtr1[Ptr[GFile], Ptr[GFile]], hash : CFuncPtr1[Ptr[GFile], _root_.glib.guint], equal : CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean], is_native : CFuncPtr1[Ptr[GFile], _root_.glib.gboolean], has_uri_scheme : CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean], get_uri_scheme : CFuncPtr1[Ptr[GFile], CString], get_basename : CFuncPtr1[Ptr[GFile], CString], get_path : CFuncPtr1[Ptr[GFile], CString], get_uri : CFuncPtr1[Ptr[GFile], CString], get_parse_name : CFuncPtr1[Ptr[GFile], CString], get_parent : CFuncPtr1[Ptr[GFile], Ptr[GFile]], prefix_matches : CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean], get_relative_path : CFuncPtr2[Ptr[GFile], Ptr[GFile], CString], resolve_relative_path : CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]], get_child_for_display_name : CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], enumerate_children : CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]], enumerate_children_async : CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], enumerate_children_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]], query_info : CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_filesystem_info : CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_filesystem_info_async : CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_filesystem_info_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], find_enclosing_mount : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]], find_enclosing_mount_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], find_enclosing_mount_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]], set_display_name : CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], set_display_name_async : CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], set_display_name_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], query_settable_attributes : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]], _query_settable_attributes_async : CFuncPtr0[Unit], _query_settable_attributes_finish : CFuncPtr0[Unit], query_writable_namespaces : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]], _query_writable_namespaces_async : CFuncPtr0[Unit], _query_writable_namespaces_finish : CFuncPtr0[Unit], set_attribute : CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_attributes_from_info : CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], set_attributes_async : CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], set_attributes_finish : CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], read_fn : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]], read_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], read_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]], append_to : CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], append_to_async : CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], append_to_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], create : CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], create_async : CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], create_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], replace : CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], replace_async : CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], replace_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]], delete_file : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], delete_file_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], delete_file_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], trash : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], trash_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], trash_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_directory : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_directory_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], make_directory_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_symbolic_link : CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], make_symbolic_link_async : CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], make_symbolic_link_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], copy : CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], copy_async : CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit], copy_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], move : CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], move_async : CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit], move_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], mount_mountable : CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], mount_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]], unmount_mountable : CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject_mountable : CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], mount_enclosing_volume : CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], mount_enclosing_volume_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], monitor_dir : CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]], monitor_file : CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]], open_readwrite : CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], open_readwrite_async : CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], open_readwrite_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], create_readwrite : CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], create_readwrite_async : CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], create_readwrite_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], replace_readwrite : CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], replace_readwrite_async : CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], replace_readwrite_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]], start_mountable : CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], start_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], stop_mountable : CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], stop_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], supports_thread_contexts : _root_.glib.gboolean, unmount_mountable_with_operation : CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_mountable_with_operation_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject_mountable_with_operation : CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_mountable_with_operation_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], poll_mountable : CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], poll_mountable_finish : CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], measure_disk_usage : CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], measure_disk_usage_async : CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit], measure_disk_usage_finish : CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GFileIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).dup = dup
    (!____ptr).hash = hash
    (!____ptr).equal = equal
    (!____ptr).is_native = is_native
    (!____ptr).has_uri_scheme = has_uri_scheme
    (!____ptr).get_uri_scheme = get_uri_scheme
    (!____ptr).get_basename = get_basename
    (!____ptr).get_path = get_path
    (!____ptr).get_uri = get_uri
    (!____ptr).get_parse_name = get_parse_name
    (!____ptr).get_parent = get_parent
    (!____ptr).prefix_matches = prefix_matches
    (!____ptr).get_relative_path = get_relative_path
    (!____ptr).resolve_relative_path = resolve_relative_path
    (!____ptr).get_child_for_display_name = get_child_for_display_name
    (!____ptr).enumerate_children = enumerate_children
    (!____ptr).enumerate_children_async = enumerate_children_async
    (!____ptr).enumerate_children_finish = enumerate_children_finish
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr).query_filesystem_info = query_filesystem_info
    (!____ptr).query_filesystem_info_async = query_filesystem_info_async
    (!____ptr).query_filesystem_info_finish = query_filesystem_info_finish
    (!____ptr).find_enclosing_mount = find_enclosing_mount
    (!____ptr).find_enclosing_mount_async = find_enclosing_mount_async
    (!____ptr).find_enclosing_mount_finish = find_enclosing_mount_finish
    (!____ptr).set_display_name = set_display_name
    (!____ptr).set_display_name_async = set_display_name_async
    (!____ptr).set_display_name_finish = set_display_name_finish
    (!____ptr).query_settable_attributes = query_settable_attributes
    (!____ptr)._query_settable_attributes_async = _query_settable_attributes_async
    (!____ptr)._query_settable_attributes_finish = _query_settable_attributes_finish
    (!____ptr).query_writable_namespaces = query_writable_namespaces
    (!____ptr)._query_writable_namespaces_async = _query_writable_namespaces_async
    (!____ptr)._query_writable_namespaces_finish = _query_writable_namespaces_finish
    (!____ptr).set_attribute = set_attribute
    (!____ptr).set_attributes_from_info = set_attributes_from_info
    (!____ptr).set_attributes_async = set_attributes_async
    (!____ptr).set_attributes_finish = set_attributes_finish
    (!____ptr).read_fn = read_fn
    (!____ptr).read_async = read_async
    (!____ptr).read_finish = read_finish
    (!____ptr).append_to = append_to
    (!____ptr).append_to_async = append_to_async
    (!____ptr).append_to_finish = append_to_finish
    (!____ptr).create = create
    (!____ptr).create_async = create_async
    (!____ptr).create_finish = create_finish
    (!____ptr).replace = replace
    (!____ptr).replace_async = replace_async
    (!____ptr).replace_finish = replace_finish
    (!____ptr).delete_file = delete_file
    (!____ptr).delete_file_async = delete_file_async
    (!____ptr).delete_file_finish = delete_file_finish
    (!____ptr).trash = trash
    (!____ptr).trash_async = trash_async
    (!____ptr).trash_finish = trash_finish
    (!____ptr).make_directory = make_directory
    (!____ptr).make_directory_async = make_directory_async
    (!____ptr).make_directory_finish = make_directory_finish
    (!____ptr).make_symbolic_link = make_symbolic_link
    (!____ptr).make_symbolic_link_async = make_symbolic_link_async
    (!____ptr).make_symbolic_link_finish = make_symbolic_link_finish
    (!____ptr).copy = copy
    (!____ptr).copy_async = copy_async
    (!____ptr).copy_finish = copy_finish
    (!____ptr).move = move
    (!____ptr).move_async = move_async
    (!____ptr).move_finish = move_finish
    (!____ptr).mount_mountable = mount_mountable
    (!____ptr).mount_mountable_finish = mount_mountable_finish
    (!____ptr).unmount_mountable = unmount_mountable
    (!____ptr).unmount_mountable_finish = unmount_mountable_finish
    (!____ptr).eject_mountable = eject_mountable
    (!____ptr).eject_mountable_finish = eject_mountable_finish
    (!____ptr).mount_enclosing_volume = mount_enclosing_volume
    (!____ptr).mount_enclosing_volume_finish = mount_enclosing_volume_finish
    (!____ptr).monitor_dir = monitor_dir
    (!____ptr).monitor_file = monitor_file
    (!____ptr).open_readwrite = open_readwrite
    (!____ptr).open_readwrite_async = open_readwrite_async
    (!____ptr).open_readwrite_finish = open_readwrite_finish
    (!____ptr).create_readwrite = create_readwrite
    (!____ptr).create_readwrite_async = create_readwrite_async
    (!____ptr).create_readwrite_finish = create_readwrite_finish
    (!____ptr).replace_readwrite = replace_readwrite
    (!____ptr).replace_readwrite_async = replace_readwrite_async
    (!____ptr).replace_readwrite_finish = replace_readwrite_finish
    (!____ptr).start_mountable = start_mountable
    (!____ptr).start_mountable_finish = start_mountable_finish
    (!____ptr).stop_mountable = stop_mountable
    (!____ptr).stop_mountable_finish = stop_mountable_finish
    (!____ptr).supports_thread_contexts = supports_thread_contexts
    (!____ptr).unmount_mountable_with_operation = unmount_mountable_with_operation
    (!____ptr).unmount_mountable_with_operation_finish = unmount_mountable_with_operation_finish
    (!____ptr).eject_mountable_with_operation = eject_mountable_with_operation
    (!____ptr).eject_mountable_with_operation_finish = eject_mountable_with_operation_finish
    (!____ptr).poll_mountable = poll_mountable
    (!____ptr).poll_mountable_finish = poll_mountable_finish
    (!____ptr).measure_disk_usage = measure_disk_usage
    (!____ptr).measure_disk_usage_async = measure_disk_usage_async
    (!____ptr).measure_disk_usage_finish = measure_disk_usage_finish
    ____ptr
  extension (struct: _GFileIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def dup: CFuncPtr1[Ptr[GFile], Ptr[GFile]] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]]
    def dup_=(value: CFuncPtr1[Ptr[GFile], Ptr[GFile]]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]] = value
    def hash: CFuncPtr1[Ptr[GFile], _root_.glib.guint] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.guint]]]
    def hash_=(value: CFuncPtr1[Ptr[GFile], _root_.glib.guint]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.guint]]] = value
    def equal: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]]
    def equal_=(value: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]] = value
    def is_native: CFuncPtr1[Ptr[GFile], _root_.glib.gboolean] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]]]
    def is_native_=(value: CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]]] = value
    def has_uri_scheme: CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]]]
    def has_uri_scheme_=(value: CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]]] = value
    def get_uri_scheme: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_uri_scheme_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_basename: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_basename_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_path: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_path_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_uri: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_uri_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_parse_name: CFuncPtr1[Ptr[GFile], CString] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]]
    def get_parse_name_=(value: CFuncPtr1[Ptr[GFile], CString]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], CString]]] = value
    def get_parent: CFuncPtr1[Ptr[GFile], Ptr[GFile]] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]]
    def get_parent_=(value: CFuncPtr1[Ptr[GFile], Ptr[GFile]]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GFile], Ptr[GFile]]]] = value
    def prefix_matches: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]]
    def prefix_matches_=(value: CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]]] = value
    def get_relative_path: CFuncPtr2[Ptr[GFile], Ptr[GFile], CString] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]]]
    def get_relative_path_=(value: CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]]] = value
    def resolve_relative_path: CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]]]
    def resolve_relative_path_=(value: CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]]] = value
    def get_child_for_display_name: CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def get_child_for_display_name_=(value: CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def enumerate_children: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]]
    def enumerate_children_=(value: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]] = value
    def enumerate_children_async: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def enumerate_children_async_=(value: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def enumerate_children_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]]
    def enumerate_children_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]]] = value
    def query_info: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_=(value: CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_info_async: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_info_async_=(value: CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_info_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_filesystem_info: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_filesystem_info_=(value: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def query_filesystem_info_async: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def query_filesystem_info_async_=(value: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def query_filesystem_info_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]]
    def query_filesystem_info_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]]] = value
    def find_enclosing_mount: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]]
    def find_enclosing_mount_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]] = value
    def find_enclosing_mount_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def find_enclosing_mount_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def find_enclosing_mount_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]] = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]]
    def find_enclosing_mount_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]): Unit = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]]] = value
    def set_display_name: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def set_display_name_=(value: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(28)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def set_display_name_async: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def set_display_name_async_=(value: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(29)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def set_display_name_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def set_display_name_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(30)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def query_settable_attributes: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]] = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]]
    def query_settable_attributes_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]): Unit = !struct.at(offsets(31)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]] = value
    def _query_settable_attributes_async: CFuncPtr0[Unit] = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_settable_attributes_async_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(32)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _query_settable_attributes_finish: CFuncPtr0[Unit] = !struct.at(offsets(33)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_settable_attributes_finish_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(33)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def query_writable_namespaces: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]] = !struct.at(offsets(34)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]]
    def query_writable_namespaces_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]): Unit = !struct.at(offsets(34)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]]] = value
    def _query_writable_namespaces_async: CFuncPtr0[Unit] = !struct.at(offsets(35)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_writable_namespaces_async_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(35)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _query_writable_namespaces_finish: CFuncPtr0[Unit] = !struct.at(offsets(36)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _query_writable_namespaces_finish_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(36)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def set_attribute: CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(37)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_attribute_=(value: CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(37)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_attributes_from_info: CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(38)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_attributes_from_info_=(value: CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(38)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def set_attributes_async: CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(39)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def set_attributes_async_=(value: CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(39)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def set_attributes_finish: CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(40)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def set_attributes_finish_=(value: CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(40)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def read_fn: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]] = !struct.at(offsets(41)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]]
    def read_fn_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]): Unit = !struct.at(offsets(41)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]] = value
    def read_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(42)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def read_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(42)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def read_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]] = !struct.at(offsets(43)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]]
    def read_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]): Unit = !struct.at(offsets(43)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]]] = value
    def append_to: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(44)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def append_to_=(value: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(44)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def append_to_async: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(45)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def append_to_async_=(value: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(45)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def append_to_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(46)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def append_to_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(46)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def create: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(47)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def create_=(value: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(47)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def create_async: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(48)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def create_async_=(value: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(48)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def create_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(49)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def create_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(49)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def replace: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(50)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def replace_=(value: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(50)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def replace_async: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(51)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def replace_async_=(value: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(51)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def replace_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]] = !struct.at(offsets(52)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]]
    def replace_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]): Unit = !struct.at(offsets(52)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]]] = value
    def delete_file: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(53)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def delete_file_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(53)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def delete_file_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(54)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def delete_file_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(54)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def delete_file_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(55)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def delete_file_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(55)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def trash: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(56)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def trash_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(56)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def trash_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(57)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def trash_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(57)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def trash_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(58)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def trash_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(58)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_directory: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(59)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_directory_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(59)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_directory_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(60)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def make_directory_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(60)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def make_directory_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(61)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_directory_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(61)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_symbolic_link: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(62)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_symbolic_link_=(value: CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(62)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def make_symbolic_link_async: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(63)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def make_symbolic_link_async_=(value: CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(63)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def make_symbolic_link_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(64)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def make_symbolic_link_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(64)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def copy: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(65)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def copy_=(value: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(65)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def copy_async: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(66)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def copy_async_=(value: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(66)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def copy_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(67)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def copy_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(67)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def move: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(68)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def move_=(value: CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(68)).asInstanceOf[Ptr[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def move_async: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(69)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def move_async_=(value: CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(69)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def move_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(70)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def move_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(70)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def mount_mountable: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(71)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def mount_mountable_=(value: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(71)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def mount_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]] = !struct.at(offsets(72)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]]
    def mount_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]): Unit = !struct.at(offsets(72)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]]] = value
    def unmount_mountable: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(73)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_mountable_=(value: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(73)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(74)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(74)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject_mountable: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(75)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_mountable_=(value: CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(75)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(76)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(76)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def mount_enclosing_volume: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(77)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def mount_enclosing_volume_=(value: CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(77)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def mount_enclosing_volume_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(78)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def mount_enclosing_volume_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(78)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def monitor_dir: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]] = !struct.at(offsets(79)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]]
    def monitor_dir_=(value: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]): Unit = !struct.at(offsets(79)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]] = value
    def monitor_file: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]] = !struct.at(offsets(80)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]]
    def monitor_file_=(value: CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]): Unit = !struct.at(offsets(80)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]]] = value
    def open_readwrite: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(81)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def open_readwrite_=(value: CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(81)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def open_readwrite_async: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(82)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def open_readwrite_async_=(value: CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(82)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def open_readwrite_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(83)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def open_readwrite_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(83)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def create_readwrite: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(84)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def create_readwrite_=(value: CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(84)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def create_readwrite_async: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(85)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def create_readwrite_async_=(value: CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(85)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def create_readwrite_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(86)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def create_readwrite_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(86)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def replace_readwrite: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(87)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def replace_readwrite_=(value: CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(87)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def replace_readwrite_async: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(88)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def replace_readwrite_async_=(value: CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(88)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def replace_readwrite_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]] = !struct.at(offsets(89)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]]
    def replace_readwrite_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]): Unit = !struct.at(offsets(89)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]]] = value
    def start_mountable: CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(90)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def start_mountable_=(value: CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(90)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def start_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(91)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def start_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(91)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def stop_mountable: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(92)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def stop_mountable_=(value: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(92)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def stop_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(93)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def stop_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(93)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def supports_thread_contexts: _root_.glib.gboolean = !struct.at(offsets(94)).asInstanceOf[Ptr[_root_.glib.gboolean]]
    def supports_thread_contexts_=(value: _root_.glib.gboolean): Unit = !struct.at(offsets(94)).asInstanceOf[Ptr[_root_.glib.gboolean]] = value
    def unmount_mountable_with_operation: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(95)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_mountable_with_operation_=(value: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(95)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_mountable_with_operation_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(96)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_mountable_with_operation_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(96)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject_mountable_with_operation: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(97)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_mountable_with_operation_=(value: CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(97)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_mountable_with_operation_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(98)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_mountable_with_operation_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(98)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def poll_mountable: CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(99)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def poll_mountable_=(value: CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(99)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def poll_mountable_finish: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(100)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def poll_mountable_finish_=(value: CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(100)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def measure_disk_usage: CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(101)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def measure_disk_usage_=(value: CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(101)).asInstanceOf[Ptr[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def measure_disk_usage_async: CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(102)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def measure_disk_usage_async_=(value: CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(102)).asInstanceOf[Ptr[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def measure_disk_usage_finish: CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(103)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def measure_disk_usage_finish_=(value: CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(103)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](104)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], _root_.glib.guint]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GFile], _root_.glib.guint]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GFile], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GFile], CString, _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], CString]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr1[Ptr[GFile], Ptr[GFile]]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr2[Ptr[GFile], Ptr[GFile], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr2[Ptr[GFile], Ptr[GFile], CString]].toInt, alignmentof[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr2[Ptr[GFile], CString, Ptr[GFile]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr3[Ptr[GFile], CString, Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileEnumerator]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr5[Ptr[GFile], CString, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr7[Ptr[GFile], CString, GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt)
    res(26) = align(res(25) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(27) = align(res(26) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt)
    res(28) = align(res(27) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GMount]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(29) = align(res(28) + sizeof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(30) = align(res(29) + sizeof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(31) = align(res(30) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt)
    res(32) = align(res(31) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(33) = align(res(32) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(34) = align(res(33) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt)
    res(35) = align(res(34) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileAttributeInfoList]]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(36) = align(res(35) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(37) = align(res(36) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(38) = align(res(37) + sizeof[CFuncPtr7[Ptr[GFile], CString, GFileAttributeType, _root_.glib.gpointer, GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(39) = align(res(38) + sizeof[CFuncPtr5[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(40) = align(res(39) + sizeof[CFuncPtr7[Ptr[GFile], Ptr[GFileInfo], GFileQueryInfoFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(41) = align(res(40) + sizeof[CFuncPtr4[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[GFileInfo]], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt)
    res(42) = align(res(41) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(43) = align(res(42) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt)
    res(44) = align(res(43) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInputStream]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(45) = align(res(44) + sizeof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(46) = align(res(45) + sizeof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(47) = align(res(46) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(48) = align(res(47) + sizeof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(49) = align(res(48) + sizeof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(50) = align(res(49) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(51) = align(res(50) + sizeof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(52) = align(res(51) + sizeof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt)
    res(53) = align(res(52) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileOutputStream]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(54) = align(res(53) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(55) = align(res(54) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(56) = align(res(55) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(57) = align(res(56) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(58) = align(res(57) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(59) = align(res(58) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(60) = align(res(59) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(61) = align(res(60) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(62) = align(res(61) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(63) = align(res(62) + sizeof[CFuncPtr4[Ptr[GFile], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(64) = align(res(63) + sizeof[CFuncPtr6[Ptr[GFile], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(65) = align(res(64) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(66) = align(res(65) + sizeof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(67) = align(res(66) + sizeof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(68) = align(res(67) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(69) = align(res(68) + sizeof[CFuncPtr7[Ptr[GFile], Ptr[GFile], GFileCopyFlags, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(70) = align(res(69) + sizeof[CFuncPtr9[Ptr[GFile], Ptr[GFile], GFileCopyFlags, CInt, Ptr[GCancellable], GFileProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(71) = align(res(70) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(72) = align(res(71) + sizeof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt)
    res(73) = align(res(72) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFile]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(74) = align(res(73) + sizeof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(75) = align(res(74) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(76) = align(res(75) + sizeof[CFuncPtr5[Ptr[GFile], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(77) = align(res(76) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(78) = align(res(77) + sizeof[CFuncPtr6[Ptr[GFile], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(79) = align(res(78) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt)
    res(80) = align(res(79) + sizeof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt)
    res(81) = align(res(80) + sizeof[CFuncPtr4[Ptr[GFile], GFileMonitorFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileMonitor]]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(82) = align(res(81) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(83) = align(res(82) + sizeof[CFuncPtr5[Ptr[GFile], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(84) = align(res(83) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(85) = align(res(84) + sizeof[CFuncPtr4[Ptr[GFile], GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(86) = align(res(85) + sizeof[CFuncPtr6[Ptr[GFile], GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(87) = align(res(86) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(88) = align(res(87) + sizeof[CFuncPtr6[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(89) = align(res(88) + sizeof[CFuncPtr8[Ptr[GFile], CString, _root_.glib.gboolean, GFileCreateFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt)
    res(90) = align(res(89) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileIOStream]]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(91) = align(res(90) + sizeof[CFuncPtr6[Ptr[GFile], GDriveStartFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(92) = align(res(91) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(93) = align(res(92) + sizeof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(94) = align(res(93) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[_root_.glib.gboolean].toInt)
    res(95) = align(res(94) + sizeof[_root_.glib.gboolean].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(96) = align(res(95) + sizeof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(97) = align(res(96) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(98) = align(res(97) + sizeof[CFuncPtr6[Ptr[GFile], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(99) = align(res(98) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(100) = align(res(99) + sizeof[CFuncPtr4[Ptr[GFile], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(101) = align(res(100) + sizeof[CFuncPtr3[Ptr[GFile], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(102) = align(res(101) + sizeof[CFuncPtr9[Ptr[GFile], GFileMeasureFlags, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(103) = align(res(102) + sizeof[CFuncPtr8[Ptr[GFile], GFileMeasureFlags, _root_.glib.gint, Ptr[GCancellable], GFileMeasureProgressCallback, _root_.glib.gpointer, GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GFile], Ptr[GAsyncResult], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[_root_.glib.guint64], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GFileInfo = CStruct0
object _GFileInfo:
  given _tag: Tag[_GFileInfo] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinfo.h
*/
opaque type _GFileInfoClass = CStruct0
object _GFileInfoClass:
  given _tag: Tag[_GFileInfoClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinputstream.h
*/
opaque type _GFileInputStream = CStruct2[GInputStream, Ptr[GFileInputStreamPrivate]]
object _GFileInputStream:
  given _tag: Tag[_GFileInputStream] = Tag.materializeCStruct2Tag[GInputStream, Ptr[GFileInputStreamPrivate]]
  def apply()(using Zone): Ptr[_GFileInputStream] = scala.scalanative.unsafe.alloc[_GFileInputStream](1)
  def apply(parent_instance : GInputStream, priv : Ptr[GFileInputStreamPrivate])(using Zone): Ptr[_GFileInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GFileInputStream)
    def parent_instance : GInputStream = struct._1
    def parent_instance_=(value: GInputStream): Unit = !struct.at1 = value
    def priv : Ptr[GFileInputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GFileInputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinputstream.h
*/
opaque type _GFileInputStreamClass = CStruct12[GInputStreamClass, CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset], CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean], CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFileInputStreamClass:
  given _tag: Tag[_GFileInputStreamClass] = Tag.materializeCStruct12Tag[GInputStreamClass, CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset], CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean], CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFileInputStreamClass] = scala.scalanative.unsafe.alloc[_GFileInputStreamClass](1)
  def apply(parent_class : GInputStreamClass, tell : CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], query_info : CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GFileInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GFileInputStreamClass)
    def parent_class : GInputStreamClass = struct._1
    def parent_class_=(value: GInputStreamClass): Unit = !struct.at1 = value
    def tell : CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset] = struct._2
    def tell_=(value: CFuncPtr1[Ptr[GFileInputStream], _root_.glib.goffset]): Unit = !struct.at2 = value
    def can_seek : CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean] = struct._3
    def can_seek_=(value: CFuncPtr1[Ptr[GFileInputStream], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def seek : CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def seek_=(value: CFuncPtr5[Ptr[GFileInputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def query_info : CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._5
    def query_info_=(value: CFuncPtr4[Ptr[GFileInputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at5 = value
    def query_info_async : CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._6
    def query_info_async_=(value: CFuncPtr6[Ptr[GFileInputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at6 = value
    def query_info_finish : CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._7
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFileInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at7 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._8
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._9
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._10
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at10 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._11
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._12
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileinputstream.h
*/
opaque type _GFileInputStreamPrivate = CStruct0
object _GFileInputStreamPrivate:
  given _tag: Tag[_GFileInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilemonitor.h
*/
opaque type _GFileMonitor = CStruct2[_root_.gobject.GObject, Ptr[GFileMonitorPrivate]]
object _GFileMonitor:
  given _tag: Tag[_GFileMonitor] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GFileMonitorPrivate]]
  def apply()(using Zone): Ptr[_GFileMonitor] = scala.scalanative.unsafe.alloc[_GFileMonitor](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GFileMonitorPrivate])(using Zone): Ptr[_GFileMonitor] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GFileMonitor)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GFileMonitorPrivate] = struct._2
    def priv_=(value: Ptr[GFileMonitorPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilemonitor.h
*/
opaque type _GFileMonitorClass = CStruct8[_root_.gobject.GObjectClass, CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit], CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFileMonitorClass:
  given _tag: Tag[_GFileMonitorClass] = Tag.materializeCStruct8Tag[_root_.gobject.GObjectClass, CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit], CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFileMonitorClass] = scala.scalanative.unsafe.alloc[_GFileMonitorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, changed : CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit], cancel : CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GFileMonitorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).changed = changed
    (!____ptr).cancel = cancel
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GFileMonitorClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def changed : CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit] = struct._2
    def changed_=(value: CFuncPtr4[Ptr[GFileMonitor], Ptr[GFile], Ptr[GFile], GFileMonitorEvent, Unit]): Unit = !struct.at2 = value
    def cancel : CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean] = struct._3
    def cancel_=(value: CFuncPtr1[Ptr[GFileMonitor], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._4
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._5
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._6
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._7
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._8
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilemonitor.h
*/
opaque type _GFileMonitorPrivate = CStruct0
object _GFileMonitorPrivate:
  given _tag: Tag[_GFileMonitorPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileoutputstream.h
*/
opaque type _GFileOutputStream = CStruct2[GOutputStream, Ptr[GFileOutputStreamPrivate]]
object _GFileOutputStream:
  given _tag: Tag[_GFileOutputStream] = Tag.materializeCStruct2Tag[GOutputStream, Ptr[GFileOutputStreamPrivate]]
  def apply()(using Zone): Ptr[_GFileOutputStream] = scala.scalanative.unsafe.alloc[_GFileOutputStream](1)
  def apply(parent_instance : GOutputStream, priv : Ptr[GFileOutputStreamPrivate])(using Zone): Ptr[_GFileOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GFileOutputStream)
    def parent_instance : GOutputStream = struct._1
    def parent_instance_=(value: GOutputStream): Unit = !struct.at1 = value
    def priv : Ptr[GFileOutputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GFileOutputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileoutputstream.h
*/
opaque type _GFileOutputStreamClass = CStruct15[GOutputStreamClass, CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset], CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr1[Ptr[GFileOutputStream], CString], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFileOutputStreamClass:
  given _tag: Tag[_GFileOutputStreamClass] = Tag.materializeCStruct15Tag[GOutputStreamClass, CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset], CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], CFuncPtr1[Ptr[GFileOutputStream], CString], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFileOutputStreamClass] = scala.scalanative.unsafe.alloc[_GFileOutputStreamClass](1)
  def apply(parent_class : GOutputStreamClass, tell : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_truncate : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean], truncate_fn : CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], query_info : CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], query_info_async : CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], query_info_finish : CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]], get_etag : CFuncPtr1[Ptr[GFileOutputStream], CString], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GFileOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).can_truncate = can_truncate
    (!____ptr).truncate_fn = truncate_fn
    (!____ptr).query_info = query_info
    (!____ptr).query_info_async = query_info_async
    (!____ptr).query_info_finish = query_info_finish
    (!____ptr).get_etag = get_etag
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GFileOutputStreamClass)
    def parent_class : GOutputStreamClass = struct._1
    def parent_class_=(value: GOutputStreamClass): Unit = !struct.at1 = value
    def tell : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset] = struct._2
    def tell_=(value: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.goffset]): Unit = !struct.at2 = value
    def can_seek : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean] = struct._3
    def can_seek_=(value: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def seek : CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def seek_=(value: CFuncPtr5[Ptr[GFileOutputStream], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def can_truncate : CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean] = struct._5
    def can_truncate_=(value: CFuncPtr1[Ptr[GFileOutputStream], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def truncate_fn : CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def truncate_fn_=(value: CFuncPtr4[Ptr[GFileOutputStream], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def query_info : CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._7
    def query_info_=(value: CFuncPtr4[Ptr[GFileOutputStream], CString, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at7 = value
    def query_info_async : CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._8
    def query_info_async_=(value: CFuncPtr6[Ptr[GFileOutputStream], CString, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at8 = value
    def query_info_finish : CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]] = struct._9
    def query_info_finish_=(value: CFuncPtr3[Ptr[GFileOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GFileInfo]]): Unit = !struct.at9 = value
    def get_etag : CFuncPtr1[Ptr[GFileOutputStream], CString] = struct._10
    def get_etag_=(value: CFuncPtr1[Ptr[GFileOutputStream], CString]): Unit = !struct.at10 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._11
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._12
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._13
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._14
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._15
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at15 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfileoutputstream.h
*/
opaque type _GFileOutputStreamPrivate = CStruct0
object _GFileOutputStreamPrivate:
  given _tag: Tag[_GFileOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GFilenameCompleter = CStruct0
object _GFilenameCompleter:
  given _tag: Tag[_GFilenameCompleter] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilenamecompleter.h
*/
opaque type _GFilenameCompleterClass = CStruct5[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GFilenameCompleter], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFilenameCompleterClass:
  given _tag: Tag[_GFilenameCompleterClass] = Tag.materializeCStruct5Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GFilenameCompleter], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFilenameCompleterClass] = scala.scalanative.unsafe.alloc[_GFilenameCompleterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, got_completion_data : CFuncPtr1[Ptr[GFilenameCompleter], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[_GFilenameCompleterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).got_completion_data = got_completion_data
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: _GFilenameCompleterClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def got_completion_data : CFuncPtr1[Ptr[GFilenameCompleter], Unit] = struct._2
    def got_completion_data_=(value: CFuncPtr1[Ptr[GFilenameCompleter], Unit]): Unit = !struct.at2 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._3
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._4
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._5
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilterinputstream.h
*/
opaque type _GFilterInputStream = CStruct2[GInputStream, Ptr[GInputStream]]
object _GFilterInputStream:
  given _tag: Tag[_GFilterInputStream] = Tag.materializeCStruct2Tag[GInputStream, Ptr[GInputStream]]
  def apply()(using Zone): Ptr[_GFilterInputStream] = scala.scalanative.unsafe.alloc[_GFilterInputStream](1)
  def apply(parent_instance : GInputStream, base_stream : Ptr[GInputStream])(using Zone): Ptr[_GFilterInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).base_stream = base_stream
    ____ptr
  extension (struct: _GFilterInputStream)
    def parent_instance : GInputStream = struct._1
    def parent_instance_=(value: GInputStream): Unit = !struct.at1 = value
    def base_stream : Ptr[GInputStream] = struct._2
    def base_stream_=(value: Ptr[GInputStream]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilterinputstream.h
*/
opaque type _GFilterInputStreamClass = CStruct4[GInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFilterInputStreamClass:
  given _tag: Tag[_GFilterInputStreamClass] = Tag.materializeCStruct4Tag[GInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFilterInputStreamClass] = scala.scalanative.unsafe.alloc[_GFilterInputStreamClass](1)
  def apply(parent_class : GInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[_GFilterInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: _GFilterInputStreamClass)
    def parent_class : GInputStreamClass = struct._1
    def parent_class_=(value: GInputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilteroutputstream.h
*/
opaque type _GFilterOutputStream = CStruct2[GOutputStream, Ptr[GOutputStream]]
object _GFilterOutputStream:
  given _tag: Tag[_GFilterOutputStream] = Tag.materializeCStruct2Tag[GOutputStream, Ptr[GOutputStream]]
  def apply()(using Zone): Ptr[_GFilterOutputStream] = scala.scalanative.unsafe.alloc[_GFilterOutputStream](1)
  def apply(parent_instance : GOutputStream, base_stream : Ptr[GOutputStream])(using Zone): Ptr[_GFilterOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).base_stream = base_stream
    ____ptr
  extension (struct: _GFilterOutputStream)
    def parent_instance : GOutputStream = struct._1
    def parent_instance_=(value: GOutputStream): Unit = !struct.at1 = value
    def base_stream : Ptr[GOutputStream] = struct._2
    def base_stream_=(value: Ptr[GOutputStream]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gfilteroutputstream.h
*/
opaque type _GFilterOutputStreamClass = CStruct4[GOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GFilterOutputStreamClass:
  given _tag: Tag[_GFilterOutputStreamClass] = Tag.materializeCStruct4Tag[GOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GFilterOutputStreamClass] = scala.scalanative.unsafe.alloc[_GFilterOutputStreamClass](1)
  def apply(parent_class : GOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit])(using Zone): Ptr[_GFilterOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    ____ptr
  extension (struct: _GFilterOutputStreamClass)
    def parent_class : GOutputStreamClass = struct._1
    def parent_class_=(value: GOutputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GIOExtension = CStruct0
object _GIOExtension:
  given _tag: Tag[_GIOExtension] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GIOExtensionPoint = CStruct0
object _GIOExtensionPoint:
  given _tag: Tag[_GIOExtensionPoint] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GIOModule = CStruct0
object _GIOModule:
  given _tag: Tag[_GIOModule] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giomodule.h
*/
opaque type _GIOModuleClass = CStruct0
object _GIOModuleClass:
  given _tag: Tag[_GIOModuleClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giomodule.h
*/
opaque type _GIOModuleScope = CStruct0
object _GIOModuleScope:
  given _tag: Tag[_GIOModuleScope] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GIOSchedulerJob = CStruct0
object _GIOSchedulerJob:
  given _tag: Tag[_GIOSchedulerJob] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giostream.h
*/
opaque type _GIOStream = CStruct2[_root_.gobject.GObject, Ptr[GIOStreamPrivate]]
object _GIOStream:
  given _tag: Tag[_GIOStream] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GIOStreamPrivate]]
  def apply()(using Zone): Ptr[_GIOStream] = scala.scalanative.unsafe.alloc[_GIOStream](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GIOStreamPrivate])(using Zone): Ptr[_GIOStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GIOStream)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GIOStreamPrivate] = struct._2
    def priv_=(value: Ptr[GIOStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GIOStreamAdapter = CStruct0
object _GIOStreamAdapter:
  given _tag: Tag[_GIOStreamAdapter] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giostream.h
*/
opaque type _GIOStreamClass = CStruct16[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]], CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]], CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GIOStreamClass:
  given _tag: Tag[_GIOStreamClass] = Tag.materializeCStruct16Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]], CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]], CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GIOStreamClass] = scala.scalanative.unsafe.alloc[_GIOStreamClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_input_stream : CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]], get_output_stream : CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]], close_fn : CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], close_async : CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit], _g_reserved9 : CFuncPtr0[Unit], _g_reserved10 : CFuncPtr0[Unit])(using Zone): Ptr[_GIOStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_input_stream = get_input_stream
    (!____ptr).get_output_stream = get_output_stream
    (!____ptr).close_fn = close_fn
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    (!____ptr)._g_reserved9 = _g_reserved9
    (!____ptr)._g_reserved10 = _g_reserved10
    ____ptr
  extension (struct: _GIOStreamClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_input_stream : CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]] = struct._2
    def get_input_stream_=(value: CFuncPtr1[Ptr[GIOStream], Ptr[GInputStream]]): Unit = !struct.at2 = value
    def get_output_stream : CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]] = struct._3
    def get_output_stream_=(value: CFuncPtr1[Ptr[GIOStream], Ptr[GOutputStream]]): Unit = !struct.at3 = value
    def close_fn : CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def close_fn_=(value: CFuncPtr3[Ptr[GIOStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def close_async : CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._5
    def close_async_=(value: CFuncPtr5[Ptr[GIOStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at5 = value
    def close_finish : CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def close_finish_=(value: CFuncPtr3[Ptr[GIOStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._7
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._8
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._9
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._10
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at10 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._11
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._12
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value
    def _g_reserved7 : CFuncPtr0[Unit] = struct._13
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved8 : CFuncPtr0[Unit] = struct._14
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value
    def _g_reserved9 : CFuncPtr0[Unit] = struct._15
    def _g_reserved9_=(value: CFuncPtr0[Unit]): Unit = !struct.at15 = value
    def _g_reserved10 : CFuncPtr0[Unit] = struct._16
    def _g_reserved10_=(value: CFuncPtr0[Unit]): Unit = !struct.at16 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giostream.h
*/
opaque type _GIOStreamPrivate = CStruct0
object _GIOStreamPrivate:
  given _tag: Tag[_GIOStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GIcon = CStruct0
object _GIcon:
  given _tag: Tag[_GIcon] = Tag.materializeCStruct0Tag

/**
 * GIconIface: _iface: The parent interface. : A hash for a given #GIcon. : Checks if two #GIcons are equal. _tokens: Serializes a #GIcon into tokens. The tokens must not contain any whitespace. Don't implement if the #GIcon can't be serialized (Since 2.20). _tokens: Constructs a #GIcon from tokens. Set the #GError if the tokens are malformed. Don't implement if the #GIcon can't be serialized (Since 2.20). : Serializes a #GIcon into a #GVariant. Since: 2.38

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gicon.h
*/
opaque type _GIconIface = CStruct6[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GIcon], _root_.glib.guint], CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean], CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean], CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]], CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]]
object _GIconIface:
  given _tag: Tag[_GIconIface] = Tag.materializeCStruct6Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GIcon], _root_.glib.guint], CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean], CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean], CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]], CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]]
  def apply()(using Zone): Ptr[_GIconIface] = scala.scalanative.unsafe.alloc[_GIconIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, hash : CFuncPtr1[Ptr[GIcon], _root_.glib.guint], equal : CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean], to_tokens : CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean], from_tokens : CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]], serialize : CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]])(using Zone): Ptr[_GIconIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).hash = hash
    (!____ptr).equal = equal
    (!____ptr).to_tokens = to_tokens
    (!____ptr).from_tokens = from_tokens
    (!____ptr).serialize = serialize
    ____ptr
  extension (struct: _GIconIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def hash : CFuncPtr1[Ptr[GIcon], _root_.glib.guint] = struct._2
    def hash_=(value: CFuncPtr1[Ptr[GIcon], _root_.glib.guint]): Unit = !struct.at2 = value
    def equal : CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean] = struct._3
    def equal_=(value: CFuncPtr2[Ptr[GIcon], Ptr[GIcon], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def to_tokens : CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean] = struct._4
    def to_tokens_=(value: CFuncPtr3[Ptr[GIcon], Ptr[_root_.glib.GPtrArray], Ptr[_root_.glib.gint], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def from_tokens : CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]] = struct._5
    def from_tokens_=(value: CFuncPtr4[Ptr[Ptr[_root_.glib.gchar]], _root_.glib.gint, _root_.glib.gint, Ptr[Ptr[_root_.glib.GError]], Ptr[GIcon]]): Unit = !struct.at5 = value
    def serialize : CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]] = struct._6
    def serialize_=(value: CFuncPtr1[Ptr[GIcon], Ptr[_root_.glib.GVariant]]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddress.h
*/
opaque type _GInetAddress = CStruct2[_root_.gobject.GObject, Ptr[GInetAddressPrivate]]
object _GInetAddress:
  given _tag: Tag[_GInetAddress] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GInetAddressPrivate]]
  def apply()(using Zone): Ptr[_GInetAddress] = scala.scalanative.unsafe.alloc[_GInetAddress](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GInetAddressPrivate])(using Zone): Ptr[_GInetAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GInetAddress)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GInetAddressPrivate] = struct._2
    def priv_=(value: Ptr[GInetAddressPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddress.h
*/
opaque type _GInetAddressClass = CStruct3[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]]
object _GInetAddressClass:
  given _tag: Tag[_GInetAddressClass] = Tag.materializeCStruct3Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]]
  def apply()(using Zone): Ptr[_GInetAddressClass] = scala.scalanative.unsafe.alloc[_GInetAddressClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, to_string : CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]], to_bytes : CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]])(using Zone): Ptr[_GInetAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).to_string = to_string
    (!____ptr).to_bytes = to_bytes
    ____ptr
  extension (struct: _GInetAddressClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def to_string : CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]] = struct._2
    def to_string_=(value: CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.gchar]]): Unit = !struct.at2 = value
    def to_bytes : CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]] = struct._3
    def to_bytes_=(value: CFuncPtr1[Ptr[GInetAddress], Ptr[_root_.glib.guint8]]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddressmask.h
*/
opaque type _GInetAddressMask = CStruct2[_root_.gobject.GObject, Ptr[GInetAddressMaskPrivate]]
object _GInetAddressMask:
  given _tag: Tag[_GInetAddressMask] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GInetAddressMaskPrivate]]
  def apply()(using Zone): Ptr[_GInetAddressMask] = scala.scalanative.unsafe.alloc[_GInetAddressMask](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GInetAddressMaskPrivate])(using Zone): Ptr[_GInetAddressMask] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GInetAddressMask)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GInetAddressMaskPrivate] = struct._2
    def priv_=(value: Ptr[GInetAddressMaskPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddressmask.h
*/
opaque type _GInetAddressMaskClass = CStruct1[_root_.gobject.GObjectClass]
object _GInetAddressMaskClass:
  given _tag: Tag[_GInetAddressMaskClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GInetAddressMaskClass] = scala.scalanative.unsafe.alloc[_GInetAddressMaskClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GInetAddressMaskClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GInetAddressMaskClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddressmask.h
*/
opaque type _GInetAddressMaskPrivate = CStruct0
object _GInetAddressMaskPrivate:
  given _tag: Tag[_GInetAddressMaskPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetaddress.h
*/
opaque type _GInetAddressPrivate = CStruct0
object _GInetAddressPrivate:
  given _tag: Tag[_GInetAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetsocketaddress.h
*/
opaque type _GInetSocketAddress = CStruct2[GSocketAddress, Ptr[GInetSocketAddressPrivate]]
object _GInetSocketAddress:
  given _tag: Tag[_GInetSocketAddress] = Tag.materializeCStruct2Tag[GSocketAddress, Ptr[GInetSocketAddressPrivate]]
  def apply()(using Zone): Ptr[_GInetSocketAddress] = scala.scalanative.unsafe.alloc[_GInetSocketAddress](1)
  def apply(parent_instance : GSocketAddress, priv : Ptr[GInetSocketAddressPrivate])(using Zone): Ptr[_GInetSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GInetSocketAddress)
    def parent_instance : GSocketAddress = struct._1
    def parent_instance_=(value: GSocketAddress): Unit = !struct.at1 = value
    def priv : Ptr[GInetSocketAddressPrivate] = struct._2
    def priv_=(value: Ptr[GInetSocketAddressPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetsocketaddress.h
*/
opaque type _GInetSocketAddressClass = CStruct1[GSocketAddressClass]
object _GInetSocketAddressClass:
  given _tag: Tag[_GInetSocketAddressClass] = Tag.materializeCStruct1Tag[GSocketAddressClass]
  def apply()(using Zone): Ptr[_GInetSocketAddressClass] = scala.scalanative.unsafe.alloc[_GInetSocketAddressClass](1)
  def apply(parent_class : GSocketAddressClass)(using Zone): Ptr[_GInetSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GInetSocketAddressClass)
    def parent_class : GSocketAddressClass = struct._1
    def parent_class_=(value: GSocketAddressClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginetsocketaddress.h
*/
opaque type _GInetSocketAddressPrivate = CStruct0
object _GInetSocketAddressPrivate:
  given _tag: Tag[_GInetSocketAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GInitable = CStruct0
object _GInitable:
  given _tag: Tag[_GInitable] = Tag.materializeCStruct0Tag

/**
 * GInitableIface: _iface: The parent interface. : Initializes the object.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginitable.h
*/
opaque type _GInitableIface = CStruct2[_root_.gobject.GTypeInterface, CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GInitableIface:
  given _tag: Tag[_GInitableIface] = Tag.materializeCStruct2Tag[_root_.gobject.GTypeInterface, CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GInitableIface] = scala.scalanative.unsafe.alloc[_GInitableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, init : CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GInitableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).init = init
    ____ptr
  extension (struct: _GInitableIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def init : CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._2
    def init_=(value: CFuncPtr3[Ptr[GInitable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GInputMessage = CStruct7[Ptr[Ptr[GSocketAddress]], Ptr[GInputVector], _root_.glib.guint, _root_.glib.gsize, _root_.glib.gint, Ptr[Ptr[Ptr[GSocketControlMessage]]], Ptr[_root_.glib.guint]]
object _GInputMessage:
  given _tag: Tag[_GInputMessage] = Tag.materializeCStruct7Tag[Ptr[Ptr[GSocketAddress]], Ptr[GInputVector], _root_.glib.guint, _root_.glib.gsize, _root_.glib.gint, Ptr[Ptr[Ptr[GSocketControlMessage]]], Ptr[_root_.glib.guint]]
  def apply()(using Zone): Ptr[_GInputMessage] = scala.scalanative.unsafe.alloc[_GInputMessage](1)
  def apply(address : Ptr[Ptr[GSocketAddress]], vectors : Ptr[GInputVector], num_vectors : _root_.glib.guint, bytes_received : _root_.glib.gsize, flags : _root_.glib.gint, control_messages : Ptr[Ptr[Ptr[GSocketControlMessage]]], num_control_messages : Ptr[_root_.glib.guint])(using Zone): Ptr[_GInputMessage] = 
    val ____ptr = apply()
    (!____ptr).address = address
    (!____ptr).vectors = vectors
    (!____ptr).num_vectors = num_vectors
    (!____ptr).bytes_received = bytes_received
    (!____ptr).flags = flags
    (!____ptr).control_messages = control_messages
    (!____ptr).num_control_messages = num_control_messages
    ____ptr
  extension (struct: _GInputMessage)
    def address : Ptr[Ptr[GSocketAddress]] = struct._1
    def address_=(value: Ptr[Ptr[GSocketAddress]]): Unit = !struct.at1 = value
    def vectors : Ptr[GInputVector] = struct._2
    def vectors_=(value: Ptr[GInputVector]): Unit = !struct.at2 = value
    def num_vectors : _root_.glib.guint = struct._3
    def num_vectors_=(value: _root_.glib.guint): Unit = !struct.at3 = value
    def bytes_received : _root_.glib.gsize = struct._4
    def bytes_received_=(value: _root_.glib.gsize): Unit = !struct.at4 = value
    def flags : _root_.glib.gint = struct._5
    def flags_=(value: _root_.glib.gint): Unit = !struct.at5 = value
    def control_messages : Ptr[Ptr[Ptr[GSocketControlMessage]]] = struct._6
    def control_messages_=(value: Ptr[Ptr[Ptr[GSocketControlMessage]]]): Unit = !struct.at6 = value
    def num_control_messages : Ptr[_root_.glib.guint] = struct._7
    def num_control_messages_=(value: Ptr[_root_.glib.guint]): Unit = !struct.at7 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginputstream.h
*/
opaque type _GInputStream = CStruct2[_root_.gobject.GObject, Ptr[GInputStreamPrivate]]
object _GInputStream:
  given _tag: Tag[_GInputStream] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GInputStreamPrivate]]
  def apply()(using Zone): Ptr[_GInputStream] = scala.scalanative.unsafe.alloc[_GInputStream](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GInputStreamPrivate])(using Zone): Ptr[_GInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GInputStream)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GInputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GInputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginputstream.h
*/
opaque type _GInputStreamClass = CStruct15[_root_.gobject.GObjectClass, CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GInputStreamClass:
  given _tag: Tag[_GInputStreamClass] = Tag.materializeCStruct15Tag[_root_.gobject.GObjectClass, CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GInputStreamClass] = scala.scalanative.unsafe.alloc[_GInputStreamClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, read_fn : CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], skip : CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], close_fn : CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], read_async : CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], read_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], skip_async : CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], skip_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], close_async : CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).read_fn = read_fn
    (!____ptr).skip = skip
    (!____ptr).close_fn = close_fn
    (!____ptr).read_async = read_async
    (!____ptr).read_finish = read_finish
    (!____ptr).skip_async = skip_async
    (!____ptr).skip_finish = skip_finish
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GInputStreamClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def read_fn : CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._2
    def read_fn_=(value: CFuncPtr5[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at2 = value
    def skip : CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._3
    def skip_=(value: CFuncPtr4[Ptr[GInputStream], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at3 = value
    def close_fn : CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def close_fn_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def read_async : CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._5
    def read_async_=(value: CFuncPtr7[Ptr[GInputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at5 = value
    def read_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._6
    def read_finish_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at6 = value
    def skip_async : CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._7
    def skip_async_=(value: CFuncPtr6[Ptr[GInputStream], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at7 = value
    def skip_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._8
    def skip_finish_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at8 = value
    def close_async : CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._9
    def close_async_=(value: CFuncPtr5[Ptr[GInputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at9 = value
    def close_finish : CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._10
    def close_finish_=(value: CFuncPtr3[Ptr[GInputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at10 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._11
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._12
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._13
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._14
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._15
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at15 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/ginputstream.h
*/
opaque type _GInputStreamPrivate = CStruct0
object _GInputStreamPrivate:
  given _tag: Tag[_GInputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GInputVector = CStruct2[_root_.glib.gpointer, _root_.glib.gsize]
object _GInputVector:
  given _tag: Tag[_GInputVector] = Tag.materializeCStruct2Tag[_root_.glib.gpointer, _root_.glib.gsize]
  def apply()(using Zone): Ptr[_GInputVector] = scala.scalanative.unsafe.alloc[_GInputVector](1)
  def apply(buffer : _root_.glib.gpointer, size : _root_.glib.gsize)(using Zone): Ptr[_GInputVector] = 
    val ____ptr = apply()
    (!____ptr).buffer = buffer
    (!____ptr).size = size
    ____ptr
  extension (struct: _GInputVector)
    def buffer : _root_.glib.gpointer = struct._1
    def buffer_=(value: _root_.glib.gpointer): Unit = !struct.at1 = value
    def size : _root_.glib.gsize = struct._2
    def size_=(value: _root_.glib.gsize): Unit = !struct.at2 = value

opaque type _GListModel = CStruct0
object _GListModel:
  given _tag: Tag[_GListModel] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/glistmodel.h
*/
opaque type _GListModelInterface = CStruct4[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GListModel], _root_.gobject.GType], CFuncPtr1[Ptr[GListModel], _root_.glib.guint], CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]]
object _GListModelInterface:
  given _tag: Tag[_GListModelInterface] = Tag.materializeCStruct4Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GListModel], _root_.gobject.GType], CFuncPtr1[Ptr[GListModel], _root_.glib.guint], CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]]
  def apply()(using Zone): Ptr[_GListModelInterface] = scala.scalanative.unsafe.alloc[_GListModelInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, get_item_type : CFuncPtr1[Ptr[GListModel], _root_.gobject.GType], get_n_items : CFuncPtr1[Ptr[GListModel], _root_.glib.guint], get_item : CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer])(using Zone): Ptr[_GListModelInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).get_item_type = get_item_type
    (!____ptr).get_n_items = get_n_items
    (!____ptr).get_item = get_item
    ____ptr
  extension (struct: _GListModelInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def get_item_type : CFuncPtr1[Ptr[GListModel], _root_.gobject.GType] = struct._2
    def get_item_type_=(value: CFuncPtr1[Ptr[GListModel], _root_.gobject.GType]): Unit = !struct.at2 = value
    def get_n_items : CFuncPtr1[Ptr[GListModel], _root_.glib.guint] = struct._3
    def get_n_items_=(value: CFuncPtr1[Ptr[GListModel], _root_.glib.guint]): Unit = !struct.at3 = value
    def get_item : CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer] = struct._4
    def get_item_=(value: CFuncPtr2[Ptr[GListModel], _root_.glib.guint, _root_.glib.gpointer]): Unit = !struct.at4 = value

opaque type _GListStore = CStruct0
object _GListStore:
  given _tag: Tag[_GListStore] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GLoadableIcon = CStruct0
object _GLoadableIcon:
  given _tag: Tag[_GLoadableIcon] = Tag.materializeCStruct0Tag

/**
 * GLoadableIconIface: _iface: The parent interface. : Loads an icon. _async: Loads an icon asynchronously. _finish: Finishes an asynchronous icon load.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gloadableicon.h
*/
opaque type _GLoadableIconIface = CStruct4[_root_.gobject.GTypeInterface, CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]], CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]]
object _GLoadableIconIface:
  given _tag: Tag[_GLoadableIconIface] = Tag.materializeCStruct4Tag[_root_.gobject.GTypeInterface, CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]], CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]]
  def apply()(using Zone): Ptr[_GLoadableIconIface] = scala.scalanative.unsafe.alloc[_GLoadableIconIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, load : CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]], load_async : CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], load_finish : CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]])(using Zone): Ptr[_GLoadableIconIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).load = load
    (!____ptr).load_async = load_async
    (!____ptr).load_finish = load_finish
    ____ptr
  extension (struct: _GLoadableIconIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def load : CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]] = struct._2
    def load_=(value: CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[CString], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]): Unit = !struct.at2 = value
    def load_async : CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def load_async_=(value: CFuncPtr5[Ptr[GLoadableIcon], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def load_finish : CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]] = struct._4
    def load_finish_=(value: CFuncPtr4[Ptr[GLoadableIcon], Ptr[GAsyncResult], Ptr[CString], Ptr[Ptr[_root_.glib.GError]], Ptr[GInputStream]]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryinputstream.h
*/
opaque type _GMemoryInputStream = CStruct2[GInputStream, Ptr[GMemoryInputStreamPrivate]]
object _GMemoryInputStream:
  given _tag: Tag[_GMemoryInputStream] = Tag.materializeCStruct2Tag[GInputStream, Ptr[GMemoryInputStreamPrivate]]
  def apply()(using Zone): Ptr[_GMemoryInputStream] = scala.scalanative.unsafe.alloc[_GMemoryInputStream](1)
  def apply(parent_instance : GInputStream, priv : Ptr[GMemoryInputStreamPrivate])(using Zone): Ptr[_GMemoryInputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GMemoryInputStream)
    def parent_instance : GInputStream = struct._1
    def parent_instance_=(value: GInputStream): Unit = !struct.at1 = value
    def priv : Ptr[GMemoryInputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GMemoryInputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryinputstream.h
*/
opaque type _GMemoryInputStreamClass = CStruct6[GInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GMemoryInputStreamClass:
  given _tag: Tag[_GMemoryInputStreamClass] = Tag.materializeCStruct6Tag[GInputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GMemoryInputStreamClass] = scala.scalanative.unsafe.alloc[_GMemoryInputStreamClass](1)
  def apply(parent_class : GInputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GMemoryInputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GMemoryInputStreamClass)
    def parent_class : GInputStreamClass = struct._1
    def parent_class_=(value: GInputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryinputstream.h
*/
opaque type _GMemoryInputStreamPrivate = CStruct0
object _GMemoryInputStreamPrivate:
  given _tag: Tag[_GMemoryInputStreamPrivate] = Tag.materializeCStruct0Tag

opaque type _GMemoryMonitor = CStruct0
object _GMemoryMonitor:
  given _tag: Tag[_GMemoryMonitor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemorymonitor.h
*/
opaque type _GMemoryMonitorInterface = CStruct2[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]]
object _GMemoryMonitorInterface:
  given _tag: Tag[_GMemoryMonitorInterface] = Tag.materializeCStruct2Tag[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]]
  def apply()(using Zone): Ptr[_GMemoryMonitorInterface] = scala.scalanative.unsafe.alloc[_GMemoryMonitorInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, low_memory_warning : CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit])(using Zone): Ptr[_GMemoryMonitorInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).low_memory_warning = low_memory_warning
    ____ptr
  extension (struct: _GMemoryMonitorInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def low_memory_warning : CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit] = struct._2
    def low_memory_warning_=(value: CFuncPtr2[Ptr[GMemoryMonitor], GMemoryMonitorWarningLevel, Unit]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryoutputstream.h
*/
opaque type _GMemoryOutputStream = CStruct2[GOutputStream, Ptr[GMemoryOutputStreamPrivate]]
object _GMemoryOutputStream:
  given _tag: Tag[_GMemoryOutputStream] = Tag.materializeCStruct2Tag[GOutputStream, Ptr[GMemoryOutputStreamPrivate]]
  def apply()(using Zone): Ptr[_GMemoryOutputStream] = scala.scalanative.unsafe.alloc[_GMemoryOutputStream](1)
  def apply(parent_instance : GOutputStream, priv : Ptr[GMemoryOutputStreamPrivate])(using Zone): Ptr[_GMemoryOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GMemoryOutputStream)
    def parent_instance : GOutputStream = struct._1
    def parent_instance_=(value: GOutputStream): Unit = !struct.at1 = value
    def priv : Ptr[GMemoryOutputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GMemoryOutputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryoutputstream.h
*/
opaque type _GMemoryOutputStreamClass = CStruct6[GOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GMemoryOutputStreamClass:
  given _tag: Tag[_GMemoryOutputStreamClass] = Tag.materializeCStruct6Tag[GOutputStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GMemoryOutputStreamClass] = scala.scalanative.unsafe.alloc[_GMemoryOutputStreamClass](1)
  def apply(parent_class : GOutputStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GMemoryOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GMemoryOutputStreamClass)
    def parent_class : GOutputStreamClass = struct._1
    def parent_class_=(value: GOutputStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmemoryoutputstream.h
*/
opaque type _GMemoryOutputStreamPrivate = CStruct0
object _GMemoryOutputStreamPrivate:
  given _tag: Tag[_GMemoryOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenu.h
*/
opaque type _GMenu = CStruct0
object _GMenu:
  given _tag: Tag[_GMenu] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuAttributeIter = CStruct2[_root_.gobject.GObject, Ptr[GMenuAttributeIterPrivate]]
object _GMenuAttributeIter:
  given _tag: Tag[_GMenuAttributeIter] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GMenuAttributeIterPrivate]]
  def apply()(using Zone): Ptr[_GMenuAttributeIter] = scala.scalanative.unsafe.alloc[_GMenuAttributeIter](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMenuAttributeIterPrivate])(using Zone): Ptr[_GMenuAttributeIter] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GMenuAttributeIter)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GMenuAttributeIterPrivate] = struct._2
    def priv_=(value: Ptr[GMenuAttributeIterPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuAttributeIterClass = CStruct2[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]
object _GMenuAttributeIterClass:
  given _tag: Tag[_GMenuAttributeIterClass] = Tag.materializeCStruct2Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GMenuAttributeIterClass] = scala.scalanative.unsafe.alloc[_GMenuAttributeIterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_next : CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean])(using Zone): Ptr[_GMenuAttributeIterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_next = get_next
    ____ptr
  extension (struct: _GMenuAttributeIterClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_next : CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean] = struct._2
    def get_next_=(value: CFuncPtr3[Ptr[GMenuAttributeIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[_root_.glib.GVariant]], _root_.glib.gboolean]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuAttributeIterPrivate = CStruct0
object _GMenuAttributeIterPrivate:
  given _tag: Tag[_GMenuAttributeIterPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenu.h
*/
opaque type _GMenuItem = CStruct0
object _GMenuItem:
  given _tag: Tag[_GMenuItem] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuLinkIter = CStruct2[_root_.gobject.GObject, Ptr[GMenuLinkIterPrivate]]
object _GMenuLinkIter:
  given _tag: Tag[_GMenuLinkIter] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GMenuLinkIterPrivate]]
  def apply()(using Zone): Ptr[_GMenuLinkIter] = scala.scalanative.unsafe.alloc[_GMenuLinkIter](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMenuLinkIterPrivate])(using Zone): Ptr[_GMenuLinkIter] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GMenuLinkIter)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GMenuLinkIterPrivate] = struct._2
    def priv_=(value: Ptr[GMenuLinkIterPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuLinkIterClass = CStruct2[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]]
object _GMenuLinkIterClass:
  given _tag: Tag[_GMenuLinkIterClass] = Tag.materializeCStruct2Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GMenuLinkIterClass] = scala.scalanative.unsafe.alloc[_GMenuLinkIterClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_next : CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean])(using Zone): Ptr[_GMenuLinkIterClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_next = get_next
    ____ptr
  extension (struct: _GMenuLinkIterClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_next : CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean] = struct._2
    def get_next_=(value: CFuncPtr3[Ptr[GMenuLinkIter], Ptr[Ptr[_root_.glib.gchar]], Ptr[Ptr[GMenuModel]], _root_.glib.gboolean]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuLinkIterPrivate = CStruct0
object _GMenuLinkIterPrivate:
  given _tag: Tag[_GMenuLinkIterPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuModel = CStruct2[_root_.gobject.GObject, Ptr[GMenuModelPrivate]]
object _GMenuModel:
  given _tag: Tag[_GMenuModel] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GMenuModelPrivate]]
  def apply()(using Zone): Ptr[_GMenuModel] = scala.scalanative.unsafe.alloc[_GMenuModel](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMenuModelPrivate])(using Zone): Ptr[_GMenuModel] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GMenuModel)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GMenuModelPrivate] = struct._2
    def priv_=(value: Ptr[GMenuModelPrivate]): Unit = !struct.at2 = value

/**
 * GMenuModelClass::get_item_attributes: : the #GMenuModel to query _index: The #GMenuItem to query : (out) (element-type utf8 GLib.Variant): Attributes on the item

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuModelClass = CStruct9[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean], CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint], CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]], CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]], CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]], CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]]
object _GMenuModelClass:
  given _tag: Tag[_GMenuModelClass] = Tag.materializeCStruct9Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean], CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint], CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]], CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]], CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]], CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]]
  def apply()(using Zone): Ptr[_GMenuModelClass] = scala.scalanative.unsafe.alloc[_GMenuModelClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, is_mutable : CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean], get_n_items : CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint], get_item_attributes : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], iterate_item_attributes : CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]], get_item_attribute_value : CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]], get_item_links : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit], iterate_item_links : CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]], get_item_link : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]])(using Zone): Ptr[_GMenuModelClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).is_mutable = is_mutable
    (!____ptr).get_n_items = get_n_items
    (!____ptr).get_item_attributes = get_item_attributes
    (!____ptr).iterate_item_attributes = iterate_item_attributes
    (!____ptr).get_item_attribute_value = get_item_attribute_value
    (!____ptr).get_item_links = get_item_links
    (!____ptr).iterate_item_links = iterate_item_links
    (!____ptr).get_item_link = get_item_link
    ____ptr
  extension (struct: _GMenuModelClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def is_mutable : CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean] = struct._2
    def is_mutable_=(value: CFuncPtr1[Ptr[GMenuModel], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def get_n_items : CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint] = struct._3
    def get_n_items_=(value: CFuncPtr1[Ptr[GMenuModel], _root_.glib.gint]): Unit = !struct.at3 = value
    def get_item_attributes : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit] = struct._4
    def get_item_attributes_=(value: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]): Unit = !struct.at4 = value
    def iterate_item_attributes : CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]] = struct._5
    def iterate_item_attributes_=(value: CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuAttributeIter]]): Unit = !struct.at5 = value
    def get_item_attribute_value : CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]] = struct._6
    def get_item_attribute_value_=(value: CFuncPtr4[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariantType], Ptr[_root_.glib.GVariant]]): Unit = !struct.at6 = value
    def get_item_links : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit] = struct._7
    def get_item_links_=(value: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[Ptr[_root_.glib.GHashTable]], Unit]): Unit = !struct.at7 = value
    def iterate_item_links : CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]] = struct._8
    def iterate_item_links_=(value: CFuncPtr2[Ptr[GMenuModel], _root_.glib.gint, Ptr[GMenuLinkIter]]): Unit = !struct.at8 = value
    def get_item_link : CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]] = struct._9
    def get_item_link_=(value: CFuncPtr3[Ptr[GMenuModel], _root_.glib.gint, Ptr[_root_.glib.gchar], Ptr[GMenuModel]]): Unit = !struct.at9 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmenumodel.h
*/
opaque type _GMenuModelPrivate = CStruct0
object _GMenuModelPrivate:
  given _tag: Tag[_GMenuModelPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GMount = CStruct0
object _GMount:
  given _tag: Tag[_GMount] = Tag.materializeCStruct0Tag

/**
 * GMountIface: _iface: The parent interface. : Changed signal that is emitted when the mount's state has changed. : The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmount.h
*/
opaque type _GMountIface = CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]]
object _GMountIface:
  given _tag: Tag[_GMountIface] = Tag.CArray[CChar, Nat.Digit3[Nat._2, Nat._3, Nat._2]](Tag.Byte, Tag.Digit3[Nat._2, Nat._3, Nat._2](Tag.Nat2, Tag.Nat3, Tag.Nat2))
  def apply()(using Zone): Ptr[_GMountIface] = scala.scalanative.unsafe.alloc[_GMountIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, changed : CFuncPtr1[Ptr[GMount], Unit], unmounted : CFuncPtr1[Ptr[GMount], Unit], get_root : CFuncPtr1[Ptr[GMount], Ptr[GFile]], get_name : CFuncPtr1[Ptr[GMount], CString], get_icon : CFuncPtr1[Ptr[GMount], Ptr[GIcon]], get_uuid : CFuncPtr1[Ptr[GMount], CString], get_volume : CFuncPtr1[Ptr[GMount], Ptr[GVolume]], get_drive : CFuncPtr1[Ptr[GMount], Ptr[GDrive]], can_unmount : CFuncPtr1[Ptr[GMount], _root_.glib.gboolean], can_eject : CFuncPtr1[Ptr[GMount], _root_.glib.gboolean], unmount : CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject : CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], remount : CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], remount_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], guess_content_type : CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], guess_content_type_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], guess_content_type_sync : CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], pre_unmount : CFuncPtr1[Ptr[GMount], Unit], unmount_with_operation : CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], unmount_with_operation_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject_with_operation : CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_with_operation_finish : CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_default_location : CFuncPtr1[Ptr[GMount], Ptr[GFile]], get_sort_key : CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]], get_symbolic_icon : CFuncPtr1[Ptr[GMount], Ptr[GIcon]])(using Zone): Ptr[_GMountIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).changed = changed
    (!____ptr).unmounted = unmounted
    (!____ptr).get_root = get_root
    (!____ptr).get_name = get_name
    (!____ptr).get_icon = get_icon
    (!____ptr).get_uuid = get_uuid
    (!____ptr).get_volume = get_volume
    (!____ptr).get_drive = get_drive
    (!____ptr).can_unmount = can_unmount
    (!____ptr).can_eject = can_eject
    (!____ptr).unmount = unmount
    (!____ptr).unmount_finish = unmount_finish
    (!____ptr).eject = eject
    (!____ptr).eject_finish = eject_finish
    (!____ptr).remount = remount
    (!____ptr).remount_finish = remount_finish
    (!____ptr).guess_content_type = guess_content_type
    (!____ptr).guess_content_type_finish = guess_content_type_finish
    (!____ptr).guess_content_type_sync = guess_content_type_sync
    (!____ptr).pre_unmount = pre_unmount
    (!____ptr).unmount_with_operation = unmount_with_operation
    (!____ptr).unmount_with_operation_finish = unmount_with_operation_finish
    (!____ptr).eject_with_operation = eject_with_operation
    (!____ptr).eject_with_operation_finish = eject_with_operation_finish
    (!____ptr).get_default_location = get_default_location
    (!____ptr).get_sort_key = get_sort_key
    (!____ptr).get_symbolic_icon = get_symbolic_icon
    ____ptr
  extension (struct: _GMountIface)
    def g_iface: _root_.gobject.GTypeInterface = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]]
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GTypeInterface]] = value
    def changed: CFuncPtr1[Ptr[GMount], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]]
    def changed_=(value: CFuncPtr1[Ptr[GMount], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]] = value
    def unmounted: CFuncPtr1[Ptr[GMount], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]]
    def unmounted_=(value: CFuncPtr1[Ptr[GMount], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]] = value
    def get_root: CFuncPtr1[Ptr[GMount], Ptr[GFile]] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]]
    def get_root_=(value: CFuncPtr1[Ptr[GMount], Ptr[GFile]]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]] = value
    def get_name: CFuncPtr1[Ptr[GMount], CString] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]]
    def get_name_=(value: CFuncPtr1[Ptr[GMount], CString]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]] = value
    def get_icon: CFuncPtr1[Ptr[GMount], Ptr[GIcon]] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]]
    def get_icon_=(value: CFuncPtr1[Ptr[GMount], Ptr[GIcon]]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]] = value
    def get_uuid: CFuncPtr1[Ptr[GMount], CString] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]]
    def get_uuid_=(value: CFuncPtr1[Ptr[GMount], CString]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], CString]]] = value
    def get_volume: CFuncPtr1[Ptr[GMount], Ptr[GVolume]] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]]]
    def get_volume_=(value: CFuncPtr1[Ptr[GMount], Ptr[GVolume]]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]]] = value
    def get_drive: CFuncPtr1[Ptr[GMount], Ptr[GDrive]] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]]]
    def get_drive_=(value: CFuncPtr1[Ptr[GMount], Ptr[GDrive]]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]]] = value
    def can_unmount: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]]
    def can_unmount_=(value: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]] = value
    def can_eject: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]]
    def can_eject_=(value: CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]]] = value
    def unmount: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_=(value: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_=(value: CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def remount: CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def remount_=(value: CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def remount_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def remount_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def guess_content_type: CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def guess_content_type_=(value: CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def guess_content_type_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]]
    def guess_content_type_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def guess_content_type_sync: CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]]
    def guess_content_type_sync_=(value: CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]] = value
    def pre_unmount: CFuncPtr1[Ptr[GMount], Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]]
    def pre_unmount_=(value: CFuncPtr1[Ptr[GMount], Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Unit]]] = value
    def unmount_with_operation: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def unmount_with_operation_=(value: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def unmount_with_operation_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def unmount_with_operation_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def eject_with_operation: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]]
    def eject_with_operation_=(value: CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]]] = value
    def eject_with_operation_finish: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]]
    def eject_with_operation_finish_=(value: CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]] = value
    def get_default_location: CFuncPtr1[Ptr[GMount], Ptr[GFile]] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]]
    def get_default_location_=(value: CFuncPtr1[Ptr[GMount], Ptr[GFile]]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GFile]]]] = value
    def get_sort_key: CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]] = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]]]
    def get_sort_key_=(value: CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]): Unit = !struct.at(offsets(26)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]]] = value
    def get_symbolic_icon: CFuncPtr1[Ptr[GMount], Ptr[GIcon]] = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]]
    def get_symbolic_icon_=(value: CFuncPtr1[Ptr[GMount], Ptr[GIcon]]): Unit = !struct.at(offsets(27)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](28)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GTypeInterface].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GTypeInterface].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr1[Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr1[Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], CString]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr1[Ptr[GMount], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], CString]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr1[Ptr[GMount], CString]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GVolume]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GDrive]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr1[Ptr[GMount], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr5[Ptr[GMount], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr6[Ptr[GMount], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr5[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr4[Ptr[GMount], _root_.glib.gboolean, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Unit]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr1[Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr6[Ptr[GMount], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]].toInt, alignmentof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr3[Ptr[GMount], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt)
    res(26) = align(res(25) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[GFile]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]].toInt)
    res(27) = align(res(26) + sizeof[CFuncPtr1[Ptr[GMount], Ptr[_root_.glib.gchar]]].toInt, alignmentof[CFuncPtr1[Ptr[GMount], Ptr[GIcon]]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmountoperation.h
*/
opaque type _GMountOperation = CStruct2[_root_.gobject.GObject, Ptr[GMountOperationPrivate]]
object _GMountOperation:
  given _tag: Tag[_GMountOperation] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GMountOperationPrivate]]
  def apply()(using Zone): Ptr[_GMountOperation] = scala.scalanative.unsafe.alloc[_GMountOperation](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GMountOperationPrivate])(using Zone): Ptr[_GMountOperation] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GMountOperation)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GMountOperationPrivate] = struct._2
    def priv_=(value: Ptr[GMountOperationPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmountoperation.h
*/
opaque type _GMountOperationClass = CStruct16[_root_.gobject.GObjectClass, CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit], CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit], CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit], CFuncPtr1[Ptr[GMountOperation], Unit], CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit], CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GMountOperationClass:
  given _tag: Tag[_GMountOperationClass] = Tag.materializeCStruct16Tag[_root_.gobject.GObjectClass, CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit], CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit], CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit], CFuncPtr1[Ptr[GMountOperation], Unit], CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit], CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GMountOperationClass] = scala.scalanative.unsafe.alloc[_GMountOperationClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, ask_password : CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit], ask_question : CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit], reply : CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit], aborted : CFuncPtr1[Ptr[GMountOperation], Unit], show_processes : CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit], show_unmount_progress : CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit], _g_reserved9 : CFuncPtr0[Unit])(using Zone): Ptr[_GMountOperationClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).ask_password = ask_password
    (!____ptr).ask_question = ask_question
    (!____ptr).reply = reply
    (!____ptr).aborted = aborted
    (!____ptr).show_processes = show_processes
    (!____ptr).show_unmount_progress = show_unmount_progress
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    (!____ptr)._g_reserved9 = _g_reserved9
    ____ptr
  extension (struct: _GMountOperationClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def ask_password : CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit] = struct._2
    def ask_password_=(value: CFuncPtr5[Ptr[GMountOperation], CString, CString, CString, GAskPasswordFlags, Unit]): Unit = !struct.at2 = value
    def ask_question : CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit] = struct._3
    def ask_question_=(value: CFuncPtr3[Ptr[GMountOperation], CString, Ptr[CString], Unit]): Unit = !struct.at3 = value
    def reply : CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit] = struct._4
    def reply_=(value: CFuncPtr2[Ptr[GMountOperation], GMountOperationResult, Unit]): Unit = !struct.at4 = value
    def aborted : CFuncPtr1[Ptr[GMountOperation], Unit] = struct._5
    def aborted_=(value: CFuncPtr1[Ptr[GMountOperation], Unit]): Unit = !struct.at5 = value
    def show_processes : CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit] = struct._6
    def show_processes_=(value: CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GArray], Ptr[Ptr[_root_.glib.gchar]], Unit]): Unit = !struct.at6 = value
    def show_unmount_progress : CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit] = struct._7
    def show_unmount_progress_=(value: CFuncPtr4[Ptr[GMountOperation], Ptr[_root_.glib.gchar], _root_.glib.gint64, _root_.glib.gint64, Unit]): Unit = !struct.at7 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._8
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._9
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._10
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at10 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._11
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._12
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at12 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._13
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved7 : CFuncPtr0[Unit] = struct._14
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value
    def _g_reserved8 : CFuncPtr0[Unit] = struct._15
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at15 = value
    def _g_reserved9 : CFuncPtr0[Unit] = struct._16
    def _g_reserved9_=(value: CFuncPtr0[Unit]): Unit = !struct.at16 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gmountoperation.h
*/
opaque type _GMountOperationPrivate = CStruct0
object _GMountOperationPrivate:
  given _tag: Tag[_GMountOperationPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativesocketaddress.h
*/
opaque type _GNativeSocketAddress = CStruct2[GSocketAddress, Ptr[GNativeSocketAddressPrivate]]
object _GNativeSocketAddress:
  given _tag: Tag[_GNativeSocketAddress] = Tag.materializeCStruct2Tag[GSocketAddress, Ptr[GNativeSocketAddressPrivate]]
  def apply()(using Zone): Ptr[_GNativeSocketAddress] = scala.scalanative.unsafe.alloc[_GNativeSocketAddress](1)
  def apply(parent_instance : GSocketAddress, priv : Ptr[GNativeSocketAddressPrivate])(using Zone): Ptr[_GNativeSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GNativeSocketAddress)
    def parent_instance : GSocketAddress = struct._1
    def parent_instance_=(value: GSocketAddress): Unit = !struct.at1 = value
    def priv : Ptr[GNativeSocketAddressPrivate] = struct._2
    def priv_=(value: Ptr[GNativeSocketAddressPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativesocketaddress.h
*/
opaque type _GNativeSocketAddressClass = CStruct1[GSocketAddressClass]
object _GNativeSocketAddressClass:
  given _tag: Tag[_GNativeSocketAddressClass] = Tag.materializeCStruct1Tag[GSocketAddressClass]
  def apply()(using Zone): Ptr[_GNativeSocketAddressClass] = scala.scalanative.unsafe.alloc[_GNativeSocketAddressClass](1)
  def apply(parent_class : GSocketAddressClass)(using Zone): Ptr[_GNativeSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GNativeSocketAddressClass)
    def parent_class : GSocketAddressClass = struct._1
    def parent_class_=(value: GSocketAddressClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativesocketaddress.h
*/
opaque type _GNativeSocketAddressPrivate = CStruct0
object _GNativeSocketAddressPrivate:
  given _tag: Tag[_GNativeSocketAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativevolumemonitor.h
*/
opaque type _GNativeVolumeMonitor = CStruct1[GVolumeMonitor]
object _GNativeVolumeMonitor:
  given _tag: Tag[_GNativeVolumeMonitor] = Tag.materializeCStruct1Tag[GVolumeMonitor]
  def apply()(using Zone): Ptr[_GNativeVolumeMonitor] = scala.scalanative.unsafe.alloc[_GNativeVolumeMonitor](1)
  def apply(parent_instance : GVolumeMonitor)(using Zone): Ptr[_GNativeVolumeMonitor] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: _GNativeVolumeMonitor)
    def parent_instance : GVolumeMonitor = struct._1
    def parent_instance_=(value: GVolumeMonitor): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnativevolumemonitor.h
*/
opaque type _GNativeVolumeMonitorClass = CStruct2[GVolumeMonitorClass, CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]]
object _GNativeVolumeMonitorClass:
  given _tag: Tag[_GNativeVolumeMonitorClass] = Tag.materializeCStruct2Tag[GVolumeMonitorClass, CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]]
  def apply()(using Zone): Ptr[_GNativeVolumeMonitorClass] = scala.scalanative.unsafe.alloc[_GNativeVolumeMonitorClass](1)
  def apply(parent_class : GVolumeMonitorClass, get_mount_for_mount_path : CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]])(using Zone): Ptr[_GNativeVolumeMonitorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_mount_for_mount_path = get_mount_for_mount_path
    ____ptr
  extension (struct: _GNativeVolumeMonitorClass)
    def parent_class : GVolumeMonitorClass = struct._1
    def parent_class_=(value: GVolumeMonitorClass): Unit = !struct.at1 = value
    def get_mount_for_mount_path : CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]] = struct._2
    def get_mount_for_mount_path_=(value: CFuncPtr2[CString, Ptr[GCancellable], Ptr[GMount]]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkaddress.h
*/
opaque type _GNetworkAddress = CStruct2[_root_.gobject.GObject, Ptr[GNetworkAddressPrivate]]
object _GNetworkAddress:
  given _tag: Tag[_GNetworkAddress] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GNetworkAddressPrivate]]
  def apply()(using Zone): Ptr[_GNetworkAddress] = scala.scalanative.unsafe.alloc[_GNetworkAddress](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GNetworkAddressPrivate])(using Zone): Ptr[_GNetworkAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GNetworkAddress)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GNetworkAddressPrivate] = struct._2
    def priv_=(value: Ptr[GNetworkAddressPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkaddress.h
*/
opaque type _GNetworkAddressClass = CStruct1[_root_.gobject.GObjectClass]
object _GNetworkAddressClass:
  given _tag: Tag[_GNetworkAddressClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GNetworkAddressClass] = scala.scalanative.unsafe.alloc[_GNetworkAddressClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GNetworkAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GNetworkAddressClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkaddress.h
*/
opaque type _GNetworkAddressPrivate = CStruct0
object _GNetworkAddressPrivate:
  given _tag: Tag[_GNetworkAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GNetworkMonitor = CStruct0
object _GNetworkMonitor:
  given _tag: Tag[_GNetworkMonitor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkmonitor.h
*/
opaque type _GNetworkMonitorInterface = CStruct5[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit], CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GNetworkMonitorInterface:
  given _tag: Tag[_GNetworkMonitorInterface] = Tag.materializeCStruct5Tag[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit], CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GNetworkMonitorInterface] = scala.scalanative.unsafe.alloc[_GNetworkMonitorInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, network_changed : CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit], can_reach : CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_reach_async : CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], can_reach_finish : CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GNetworkMonitorInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).network_changed = network_changed
    (!____ptr).can_reach = can_reach
    (!____ptr).can_reach_async = can_reach_async
    (!____ptr).can_reach_finish = can_reach_finish
    ____ptr
  extension (struct: _GNetworkMonitorInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def network_changed : CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit] = struct._2
    def network_changed_=(value: CFuncPtr2[Ptr[GNetworkMonitor], _root_.glib.gboolean, Unit]): Unit = !struct.at2 = value
    def can_reach : CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._3
    def can_reach_=(value: CFuncPtr4[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def can_reach_async : CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._4
    def can_reach_async_=(value: CFuncPtr5[Ptr[GNetworkMonitor], Ptr[GSocketConnectable], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at4 = value
    def can_reach_finish : CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._5
    def can_reach_finish_=(value: CFuncPtr3[Ptr[GNetworkMonitor], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkservice.h
*/
opaque type _GNetworkService = CStruct2[_root_.gobject.GObject, Ptr[GNetworkServicePrivate]]
object _GNetworkService:
  given _tag: Tag[_GNetworkService] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GNetworkServicePrivate]]
  def apply()(using Zone): Ptr[_GNetworkService] = scala.scalanative.unsafe.alloc[_GNetworkService](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GNetworkServicePrivate])(using Zone): Ptr[_GNetworkService] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GNetworkService)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GNetworkServicePrivate] = struct._2
    def priv_=(value: Ptr[GNetworkServicePrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkservice.h
*/
opaque type _GNetworkServiceClass = CStruct1[_root_.gobject.GObjectClass]
object _GNetworkServiceClass:
  given _tag: Tag[_GNetworkServiceClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GNetworkServiceClass] = scala.scalanative.unsafe.alloc[_GNetworkServiceClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GNetworkServiceClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GNetworkServiceClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gnetworkservice.h
*/
opaque type _GNetworkServicePrivate = CStruct0
object _GNetworkServicePrivate:
  given _tag: Tag[_GNetworkServicePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GNotification = CStruct0
object _GNotification:
  given _tag: Tag[_GNotification] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GOutputMessage = CStruct6[Ptr[GSocketAddress], Ptr[GOutputVector], _root_.glib.guint, _root_.glib.guint, Ptr[Ptr[GSocketControlMessage]], _root_.glib.guint]
object _GOutputMessage:
  given _tag: Tag[_GOutputMessage] = Tag.materializeCStruct6Tag[Ptr[GSocketAddress], Ptr[GOutputVector], _root_.glib.guint, _root_.glib.guint, Ptr[Ptr[GSocketControlMessage]], _root_.glib.guint]
  def apply()(using Zone): Ptr[_GOutputMessage] = scala.scalanative.unsafe.alloc[_GOutputMessage](1)
  def apply(address : Ptr[GSocketAddress], vectors : Ptr[GOutputVector], num_vectors : _root_.glib.guint, bytes_sent : _root_.glib.guint, control_messages : Ptr[Ptr[GSocketControlMessage]], num_control_messages : _root_.glib.guint)(using Zone): Ptr[_GOutputMessage] = 
    val ____ptr = apply()
    (!____ptr).address = address
    (!____ptr).vectors = vectors
    (!____ptr).num_vectors = num_vectors
    (!____ptr).bytes_sent = bytes_sent
    (!____ptr).control_messages = control_messages
    (!____ptr).num_control_messages = num_control_messages
    ____ptr
  extension (struct: _GOutputMessage)
    def address : Ptr[GSocketAddress] = struct._1
    def address_=(value: Ptr[GSocketAddress]): Unit = !struct.at1 = value
    def vectors : Ptr[GOutputVector] = struct._2
    def vectors_=(value: Ptr[GOutputVector]): Unit = !struct.at2 = value
    def num_vectors : _root_.glib.guint = struct._3
    def num_vectors_=(value: _root_.glib.guint): Unit = !struct.at3 = value
    def bytes_sent : _root_.glib.guint = struct._4
    def bytes_sent_=(value: _root_.glib.guint): Unit = !struct.at4 = value
    def control_messages : Ptr[Ptr[GSocketControlMessage]] = struct._5
    def control_messages_=(value: Ptr[Ptr[GSocketControlMessage]]): Unit = !struct.at5 = value
    def num_control_messages : _root_.glib.guint = struct._6
    def num_control_messages_=(value: _root_.glib.guint): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/goutputstream.h
*/
opaque type _GOutputStream = CStruct2[_root_.gobject.GObject, Ptr[GOutputStreamPrivate]]
object _GOutputStream:
  given _tag: Tag[_GOutputStream] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GOutputStreamPrivate]]
  def apply()(using Zone): Ptr[_GOutputStream] = scala.scalanative.unsafe.alloc[_GOutputStream](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GOutputStreamPrivate])(using Zone): Ptr[_GOutputStream] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GOutputStream)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GOutputStreamPrivate] = struct._2
    def priv_=(value: Ptr[GOutputStreamPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/goutputstream.h
*/
opaque type _GOutputStreamClass = CStruct21[_root_.gobject.GObjectClass, CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GOutputStreamClass:
  given _tag: Tag[_GOutputStreamClass] = Tag.materializeCStruct21Tag[_root_.gobject.GObjectClass, CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GOutputStreamClass] = scala.scalanative.unsafe.alloc[_GOutputStreamClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, write_fn : CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], splice : CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], flush : CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], close_fn : CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], write_async : CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], write_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], splice_async : CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], splice_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], flush_async : CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], flush_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], close_async : CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], close_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], writev_fn : CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], writev_async : CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], writev_finish : CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit])(using Zone): Ptr[_GOutputStreamClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).write_fn = write_fn
    (!____ptr).splice = splice
    (!____ptr).flush = flush
    (!____ptr).close_fn = close_fn
    (!____ptr).write_async = write_async
    (!____ptr).write_finish = write_finish
    (!____ptr).splice_async = splice_async
    (!____ptr).splice_finish = splice_finish
    (!____ptr).flush_async = flush_async
    (!____ptr).flush_finish = flush_finish
    (!____ptr).close_async = close_async
    (!____ptr).close_finish = close_finish
    (!____ptr).writev_fn = writev_fn
    (!____ptr).writev_async = writev_async
    (!____ptr).writev_finish = writev_finish
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    ____ptr
  extension (struct: _GOutputStreamClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def write_fn : CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._2
    def write_fn_=(value: CFuncPtr5[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at2 = value
    def splice : CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._3
    def splice_=(value: CFuncPtr5[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at3 = value
    def flush : CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def flush_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def close_fn : CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._5
    def close_fn_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def write_async : CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._6
    def write_async_=(value: CFuncPtr7[Ptr[GOutputStream], Ptr[Byte], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at6 = value
    def write_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._7
    def write_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at7 = value
    def splice_async : CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._8
    def splice_async_=(value: CFuncPtr7[Ptr[GOutputStream], Ptr[GInputStream], GOutputStreamSpliceFlags, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at8 = value
    def splice_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._9
    def splice_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at9 = value
    def flush_async : CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._10
    def flush_async_=(value: CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at10 = value
    def flush_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._11
    def flush_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at11 = value
    def close_async : CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._12
    def close_async_=(value: CFuncPtr5[Ptr[GOutputStream], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at12 = value
    def close_finish : CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._13
    def close_finish_=(value: CFuncPtr3[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at13 = value
    def writev_fn : CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._14
    def writev_fn_=(value: CFuncPtr6[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at14 = value
    def writev_async : CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._15
    def writev_async_=(value: CFuncPtr7[Ptr[GOutputStream], Ptr[GOutputVector], _root_.glib.gsize, CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at15 = value
    def writev_finish : CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._16
    def writev_finish_=(value: CFuncPtr4[Ptr[GOutputStream], Ptr[GAsyncResult], Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at16 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._17
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at17 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._18
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at18 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._19
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at19 = value
    def _g_reserved7 : CFuncPtr0[Unit] = struct._20
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at20 = value
    def _g_reserved8 : CFuncPtr0[Unit] = struct._21
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at21 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/goutputstream.h
*/
opaque type _GOutputStreamPrivate = CStruct0
object _GOutputStreamPrivate:
  given _tag: Tag[_GOutputStreamPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GOutputVector = CStruct2[_root_.glib.gconstpointer, _root_.glib.gsize]
object _GOutputVector:
  given _tag: Tag[_GOutputVector] = Tag.materializeCStruct2Tag[_root_.glib.gconstpointer, _root_.glib.gsize]
  def apply()(using Zone): Ptr[_GOutputVector] = scala.scalanative.unsafe.alloc[_GOutputVector](1)
  def apply(buffer : _root_.glib.gconstpointer, size : _root_.glib.gsize)(using Zone): Ptr[_GOutputVector] = 
    val ____ptr = apply()
    (!____ptr).buffer = buffer
    (!____ptr).size = size
    ____ptr
  extension (struct: _GOutputVector)
    def buffer : _root_.glib.gconstpointer = struct._1
    def buffer_=(value: _root_.glib.gconstpointer): Unit = !struct.at1 = value
    def size : _root_.glib.gsize = struct._2
    def size_=(value: _root_.glib.gsize): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpermission.h
*/
opaque type _GPermission = CStruct2[_root_.gobject.GObject, Ptr[GPermissionPrivate]]
object _GPermission:
  given _tag: Tag[_GPermission] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GPermissionPrivate]]
  def apply()(using Zone): Ptr[_GPermission] = scala.scalanative.unsafe.alloc[_GPermission](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GPermissionPrivate])(using Zone): Ptr[_GPermission] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GPermission)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GPermissionPrivate] = struct._2
    def priv_=(value: Ptr[GPermissionPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpermission.h
*/
opaque type _GPermissionClass = CStruct8[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]
object _GPermissionClass:
  given _tag: Tag[_GPermissionClass] = Tag.materializeCStruct8Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]
  def apply()(using Zone): Ptr[_GPermissionClass] = scala.scalanative.unsafe.alloc[_GPermissionClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, acquire : CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], acquire_async : CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], acquire_finish : CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], release : CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], release_async : CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], release_finish : CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], reserved : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]])(using Zone): Ptr[_GPermissionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).acquire = acquire
    (!____ptr).acquire_async = acquire_async
    (!____ptr).acquire_finish = acquire_finish
    (!____ptr).release = release
    (!____ptr).release_async = release_async
    (!____ptr).release_finish = release_finish
    (!____ptr).reserved = reserved
    ____ptr
  extension (struct: _GPermissionClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def acquire : CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._2
    def acquire_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def acquire_async : CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def acquire_async_=(value: CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def acquire_finish : CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def acquire_finish_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def release : CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._5
    def release_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def release_async : CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._6
    def release_async_=(value: CFuncPtr4[Ptr[GPermission], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at6 = value
    def release_finish : CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._7
    def release_finish_=(value: CFuncPtr3[Ptr[GPermission], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at7 = value
    def reserved : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]] = struct._8
    def reserved_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpermission.h
*/
opaque type _GPermissionPrivate = CStruct0
object _GPermissionPrivate:
  given _tag: Tag[_GPermissionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GPollableInputStream = CStruct0
object _GPollableInputStream:
  given _tag: Tag[_GPollableInputStream] = Tag.materializeCStruct0Tag

/**
 * GPollableInputStreamInterface: _iface: The parent interface. _poll: Checks if the #GPollableInputStream instance is actually pollable _source: Creates a #GSource to poll the stream _nonblocking: Does a non-blocking read or returns %G_IO_ERROR_WOULD_BLOCK

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpollableinputstream.h
*/
opaque type _GPollableInputStreamInterface = CStruct5[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[Byte]], CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]
object _GPollableInputStreamInterface:
  given _tag: Tag[_GPollableInputStreamInterface] = Tag.materializeCStruct5Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[Byte]], CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]]
  def apply()(using Zone): Ptr[_GPollableInputStreamInterface] = scala.scalanative.unsafe.alloc[_GPollableInputStreamInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, can_poll : CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], is_readable : CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean], create_source : CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]], read_nonblocking : CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize])(using Zone): Ptr[_GPollableInputStreamInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).can_poll = can_poll
    (!____ptr).is_readable = is_readable
    (!____ptr).create_source = create_source
    (!____ptr).read_nonblocking = read_nonblocking
    ____ptr
  extension (struct: _GPollableInputStreamInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def can_poll : CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean] = struct._2
    def can_poll_=(value: CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def is_readable : CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean] = struct._3
    def is_readable_=(value: CFuncPtr1[Ptr[GPollableInputStream], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def create_source : CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]] = struct._4.asInstanceOf[CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]]
    def create_source_=(value: CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]): Unit = !struct.at4 = value.asInstanceOf[CFuncPtr2[Ptr[GPollableInputStream], Ptr[GCancellable], Ptr[Byte]]]
    def read_nonblocking : CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._5
    def read_nonblocking_=(value: CFuncPtr4[Ptr[GPollableInputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GPollableOutputStream = CStruct0
object _GPollableOutputStream:
  given _tag: Tag[_GPollableOutputStream] = Tag.materializeCStruct0Tag

/**
 * GPollableOutputStreamInterface: _iface: The parent interface. _poll: Checks if the #GPollableOutputStream instance is actually pollable _source: Creates a #GSource to poll the stream _nonblocking: Does a non-blocking write or returns %G_IO_ERROR_WOULD_BLOCK _nonblocking: Does a vectored non-blocking write, or returns %G_POLLABLE_RETURN_WOULD_BLOCK

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpollableoutputstream.h
*/
opaque type _GPollableOutputStreamInterface = CStruct6[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[Byte]], CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]]
object _GPollableOutputStreamInterface:
  given _tag: Tag[_GPollableOutputStreamInterface] = Tag.materializeCStruct6Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[Byte]], CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]]
  def apply()(using Zone): Ptr[_GPollableOutputStreamInterface] = scala.scalanative.unsafe.alloc[_GPollableOutputStreamInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, can_poll : CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], is_writable : CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean], create_source : CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]], write_nonblocking : CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize], writev_nonblocking : CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn])(using Zone): Ptr[_GPollableOutputStreamInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).can_poll = can_poll
    (!____ptr).is_writable = is_writable
    (!____ptr).create_source = create_source
    (!____ptr).write_nonblocking = write_nonblocking
    (!____ptr).writev_nonblocking = writev_nonblocking
    ____ptr
  extension (struct: _GPollableOutputStreamInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def can_poll : CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean] = struct._2
    def can_poll_=(value: CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def is_writable : CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean] = struct._3
    def is_writable_=(value: CFuncPtr1[Ptr[GPollableOutputStream], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def create_source : CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]] = struct._4.asInstanceOf[CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]]
    def create_source_=(value: CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[_root_.glib.GSource]]): Unit = !struct.at4 = value.asInstanceOf[CFuncPtr2[Ptr[GPollableOutputStream], Ptr[GCancellable], Ptr[Byte]]]
    def write_nonblocking : CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize] = struct._5
    def write_nonblocking_=(value: CFuncPtr4[Ptr[GPollableOutputStream], Ptr[Byte], _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gssize]): Unit = !struct.at5 = value
    def writev_nonblocking : CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn] = struct._6
    def writev_nonblocking_=(value: CFuncPtr5[Ptr[GPollableOutputStream], Ptr[GOutputVector], _root_.glib.gsize, Ptr[_root_.glib.gsize], Ptr[Ptr[_root_.glib.GError]], GPollableReturn]): Unit = !struct.at6 = value

opaque type _GPowerProfileMonitor = CStruct0
object _GPowerProfileMonitor:
  given _tag: Tag[_GPowerProfileMonitor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gpowerprofilemonitor.h
*/
opaque type _GPowerProfileMonitorInterface = CStruct1[_root_.gobject.GTypeInterface]
object _GPowerProfileMonitorInterface:
  given _tag: Tag[_GPowerProfileMonitorInterface] = Tag.materializeCStruct1Tag[_root_.gobject.GTypeInterface]
  def apply()(using Zone): Ptr[_GPowerProfileMonitorInterface] = scala.scalanative.unsafe.alloc[_GPowerProfileMonitorInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[_GPowerProfileMonitorInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: _GPowerProfileMonitorInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GPropertyAction = CStruct0
object _GPropertyAction:
  given _tag: Tag[_GPropertyAction] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GProxy = CStruct0
object _GProxy:
  given _tag: Tag[_GProxy] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddress.h
*/
opaque type _GProxyAddress = CStruct2[GInetSocketAddress, Ptr[GProxyAddressPrivate]]
object _GProxyAddress:
  given _tag: Tag[_GProxyAddress] = Tag.materializeCStruct2Tag[GInetSocketAddress, Ptr[GProxyAddressPrivate]]
  def apply()(using Zone): Ptr[_GProxyAddress] = scala.scalanative.unsafe.alloc[_GProxyAddress](1)
  def apply(parent_instance : GInetSocketAddress, priv : Ptr[GProxyAddressPrivate])(using Zone): Ptr[_GProxyAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GProxyAddress)
    def parent_instance : GInetSocketAddress = struct._1
    def parent_instance_=(value: GInetSocketAddress): Unit = !struct.at1 = value
    def priv : Ptr[GProxyAddressPrivate] = struct._2
    def priv_=(value: Ptr[GProxyAddressPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddress.h
*/
opaque type _GProxyAddressClass = CStruct1[GInetSocketAddressClass]
object _GProxyAddressClass:
  given _tag: Tag[_GProxyAddressClass] = Tag.materializeCStruct1Tag[GInetSocketAddressClass]
  def apply()(using Zone): Ptr[_GProxyAddressClass] = scala.scalanative.unsafe.alloc[_GProxyAddressClass](1)
  def apply(parent_class : GInetSocketAddressClass)(using Zone): Ptr[_GProxyAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GProxyAddressClass)
    def parent_class : GInetSocketAddressClass = struct._1
    def parent_class_=(value: GInetSocketAddressClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddressenumerator.h
*/
opaque type _GProxyAddressEnumerator = CStruct2[GSocketAddressEnumerator, Ptr[GProxyAddressEnumeratorPrivate]]
object _GProxyAddressEnumerator:
  given _tag: Tag[_GProxyAddressEnumerator] = Tag.materializeCStruct2Tag[GSocketAddressEnumerator, Ptr[GProxyAddressEnumeratorPrivate]]
  def apply()(using Zone): Ptr[_GProxyAddressEnumerator] = scala.scalanative.unsafe.alloc[_GProxyAddressEnumerator](1)
  def apply(parent_instance : GSocketAddressEnumerator, priv : Ptr[GProxyAddressEnumeratorPrivate])(using Zone): Ptr[_GProxyAddressEnumerator] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GProxyAddressEnumerator)
    def parent_instance : GSocketAddressEnumerator = struct._1
    def parent_instance_=(value: GSocketAddressEnumerator): Unit = !struct.at1 = value
    def priv : Ptr[GProxyAddressEnumeratorPrivate] = struct._2
    def priv_=(value: Ptr[GProxyAddressEnumeratorPrivate]): Unit = !struct.at2 = value

/**
 * GProxyAddressEnumeratorClass:

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddressenumerator.h
*/
opaque type _GProxyAddressEnumeratorClass = CStruct8[GSocketAddressEnumeratorClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GProxyAddressEnumeratorClass:
  given _tag: Tag[_GProxyAddressEnumeratorClass] = Tag.materializeCStruct8Tag[GSocketAddressEnumeratorClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GProxyAddressEnumeratorClass] = scala.scalanative.unsafe.alloc[_GProxyAddressEnumeratorClass](1)
  def apply(parent_class : GSocketAddressEnumeratorClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit])(using Zone): Ptr[_GProxyAddressEnumeratorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    ____ptr
  extension (struct: _GProxyAddressEnumeratorClass)
    def parent_class : GSocketAddressEnumeratorClass = struct._1
    def parent_class_=(value: GSocketAddressEnumeratorClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._7
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved7 : CFuncPtr0[Unit] = struct._8
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddressenumerator.h
*/
opaque type _GProxyAddressEnumeratorPrivate = CStruct0
object _GProxyAddressEnumeratorPrivate:
  given _tag: Tag[_GProxyAddressEnumeratorPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyaddress.h
*/
opaque type _GProxyAddressPrivate = CStruct0
object _GProxyAddressPrivate:
  given _tag: Tag[_GProxyAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * GProxyInterface: _iface: The parent interface. : Connect to proxy server and wrap (if required) the #connection to handle payload. _async: Same as connect() but asynchronous. _finish: Returns the result of connect_async() _hostname: Returns whether the proxy supports hostname lookups.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxy.h
*/
opaque type _GProxyInterface = CStruct5[_root_.gobject.GTypeInterface, CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]]
object _GProxyInterface:
  given _tag: Tag[_GProxyInterface] = Tag.materializeCStruct5Tag[_root_.gobject.GTypeInterface, CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GProxyInterface] = scala.scalanative.unsafe.alloc[_GProxyInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, connect : CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], connect_async : CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], connect_finish : CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]], supports_hostname : CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean])(using Zone): Ptr[_GProxyInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).connect = connect
    (!____ptr).connect_async = connect_async
    (!____ptr).connect_finish = connect_finish
    (!____ptr).supports_hostname = supports_hostname
    ____ptr
  extension (struct: _GProxyInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def connect : CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]] = struct._2
    def connect_=(value: CFuncPtr5[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]): Unit = !struct.at2 = value
    def connect_async : CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def connect_async_=(value: CFuncPtr6[Ptr[GProxy], Ptr[GIOStream], Ptr[GProxyAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def connect_finish : CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]] = struct._4
    def connect_finish_=(value: CFuncPtr3[Ptr[GProxy], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GIOStream]]): Unit = !struct.at4 = value
    def supports_hostname : CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean] = struct._5
    def supports_hostname_=(value: CFuncPtr1[Ptr[GProxy], _root_.glib.gboolean]): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GProxyResolver = CStruct0
object _GProxyResolver:
  given _tag: Tag[_GProxyResolver] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gproxyresolver.h
*/
opaque type _GProxyResolverInterface = CStruct5[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean], CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]
object _GProxyResolverInterface:
  given _tag: Tag[_GProxyResolverInterface] = Tag.materializeCStruct5Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean], CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]]
  def apply()(using Zone): Ptr[_GProxyResolverInterface] = scala.scalanative.unsafe.alloc[_GProxyResolverInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, is_supported : CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean], lookup : CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]], lookup_async : CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_finish : CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]])(using Zone): Ptr[_GProxyResolverInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).is_supported = is_supported
    (!____ptr).lookup = lookup
    (!____ptr).lookup_async = lookup_async
    (!____ptr).lookup_finish = lookup_finish
    ____ptr
  extension (struct: _GProxyResolverInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def is_supported : CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean] = struct._2
    def is_supported_=(value: CFuncPtr1[Ptr[GProxyResolver], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def lookup : CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = struct._3
    def lookup_=(value: CFuncPtr4[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at3 = value
    def lookup_async : CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._4
    def lookup_async_=(value: CFuncPtr5[Ptr[GProxyResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at4 = value
    def lookup_finish : CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]] = struct._5
    def lookup_finish_=(value: CFuncPtr3[Ptr[GProxyResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GRemoteActionGroup = CStruct0
object _GRemoteActionGroup:
  given _tag: Tag[_GRemoteActionGroup] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gremoteactiongroup.h
*/
opaque type _GRemoteActionGroupInterface = CStruct3[_root_.gobject.GTypeInterface, CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit], CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]]
object _GRemoteActionGroupInterface:
  given _tag: Tag[_GRemoteActionGroupInterface] = Tag.materializeCStruct3Tag[_root_.gobject.GTypeInterface, CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit], CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]]
  def apply()(using Zone): Ptr[_GRemoteActionGroupInterface] = scala.scalanative.unsafe.alloc[_GRemoteActionGroupInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, activate_action_full : CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit], change_action_state_full : CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit])(using Zone): Ptr[_GRemoteActionGroupInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).activate_action_full = activate_action_full
    (!____ptr).change_action_state_full = change_action_state_full
    ____ptr
  extension (struct: _GRemoteActionGroupInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def activate_action_full : CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit] = struct._2
    def activate_action_full_=(value: CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at2 = value
    def change_action_state_full : CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit] = struct._3
    def change_action_state_full_=(value: CFuncPtr4[Ptr[GRemoteActionGroup], Ptr[_root_.glib.gchar], Ptr[_root_.glib.GVariant], Ptr[_root_.glib.GVariant], Unit]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresolver.h
*/
opaque type _GResolver = CStruct2[_root_.gobject.GObject, Ptr[GResolverPrivate]]
object _GResolver:
  given _tag: Tag[_GResolver] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GResolverPrivate]]
  def apply()(using Zone): Ptr[_GResolver] = scala.scalanative.unsafe.alloc[_GResolver](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GResolverPrivate])(using Zone): Ptr[_GResolver] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GResolver)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GResolverPrivate] = struct._2
    def priv_=(value: Ptr[GResolverPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresolver.h
*/
opaque type _GResolverClass = CStruct17[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GResolver], Unit], CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
object _GResolverClass:
  given _tag: Tag[_GResolverClass] = Tag.materializeCStruct17Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GResolver], Unit], CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
  def apply()(using Zone): Ptr[_GResolverClass] = scala.scalanative.unsafe.alloc[_GResolverClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, reload : CFuncPtr1[Ptr[GResolver], Unit], lookup_by_name : CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_name_async : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_by_name_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_address : CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], lookup_by_address_async : CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_by_address_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]], lookup_service : CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_service_async : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_service_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_records : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_records_async : CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_records_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_name_with_flags_async : CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_by_name_with_flags_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_by_name_with_flags : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]])(using Zone): Ptr[_GResolverClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).reload = reload
    (!____ptr).lookup_by_name = lookup_by_name
    (!____ptr).lookup_by_name_async = lookup_by_name_async
    (!____ptr).lookup_by_name_finish = lookup_by_name_finish
    (!____ptr).lookup_by_address = lookup_by_address
    (!____ptr).lookup_by_address_async = lookup_by_address_async
    (!____ptr).lookup_by_address_finish = lookup_by_address_finish
    (!____ptr).lookup_service = lookup_service
    (!____ptr).lookup_service_async = lookup_service_async
    (!____ptr).lookup_service_finish = lookup_service_finish
    (!____ptr).lookup_records = lookup_records
    (!____ptr).lookup_records_async = lookup_records_async
    (!____ptr).lookup_records_finish = lookup_records_finish
    (!____ptr).lookup_by_name_with_flags_async = lookup_by_name_with_flags_async
    (!____ptr).lookup_by_name_with_flags_finish = lookup_by_name_with_flags_finish
    (!____ptr).lookup_by_name_with_flags = lookup_by_name_with_flags
    ____ptr
  extension (struct: _GResolverClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def reload : CFuncPtr1[Ptr[GResolver], Unit] = struct._2
    def reload_=(value: CFuncPtr1[Ptr[GResolver], Unit]): Unit = !struct.at2 = value
    def lookup_by_name : CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._3.asInstanceOf[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_by_name_=(value: CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at3 = value.asInstanceOf[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_by_name_async : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._4
    def lookup_by_name_async_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at4 = value
    def lookup_by_name_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._5.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_by_name_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at5 = value.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_by_address : CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]] = struct._6
    def lookup_by_address_=(value: CFuncPtr4[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]): Unit = !struct.at6 = value
    def lookup_by_address_async : CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._7
    def lookup_by_address_async_=(value: CFuncPtr5[Ptr[GResolver], Ptr[GInetAddress], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at7 = value
    def lookup_by_address_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]] = struct._8
    def lookup_by_address_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.gchar]]): Unit = !struct.at8 = value
    def lookup_service : CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._9.asInstanceOf[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_service_=(value: CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at9 = value.asInstanceOf[CFuncPtr4[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_service_async : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._10
    def lookup_service_async_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at10 = value
    def lookup_service_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._11.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_service_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at11 = value.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_records : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._12.asInstanceOf[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_records_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at12 = value.asInstanceOf[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_records_async : CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._13
    def lookup_records_async_=(value: CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverRecordType, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at13 = value
    def lookup_records_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._14.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_records_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at14 = value.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_by_name_with_flags_async : CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._15
    def lookup_by_name_with_flags_async_=(value: CFuncPtr6[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at15 = value
    def lookup_by_name_with_flags_finish : CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._16.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_by_name_with_flags_finish_=(value: CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at16 = value.asInstanceOf[CFuncPtr3[Ptr[GResolver], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_by_name_with_flags : CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._17.asInstanceOf[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_by_name_with_flags_=(value: CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at17 = value.asInstanceOf[CFuncPtr5[Ptr[GResolver], Ptr[_root_.glib.gchar], GResolverNameLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresolver.h
*/
opaque type _GResolverPrivate = CStruct0
object _GResolverPrivate:
  given _tag: Tag[_GResolverPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GResource = CStruct0
object _GResource:
  given _tag: Tag[_GResource] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSeekable = CStruct0
object _GSeekable:
  given _tag: Tag[_GSeekable] = Tag.materializeCStruct0Tag

/**
 * GSeekableIface: _iface: The parent interface. : Tells the current location within a stream. _seek: Checks if seeking is supported by the stream.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gseekable.h
*/
opaque type _GSeekableIface = CStruct6[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset], CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GSeekableIface:
  given _tag: Tag[_GSeekableIface] = Tag.materializeCStruct6Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset], CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GSeekableIface] = scala.scalanative.unsafe.alloc[_GSeekableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, tell : CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset], can_seek : CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], seek : CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], can_truncate : CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean], truncate_fn : CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GSeekableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).tell = tell
    (!____ptr).can_seek = can_seek
    (!____ptr).seek = seek
    (!____ptr).can_truncate = can_truncate
    (!____ptr).truncate_fn = truncate_fn
    ____ptr
  extension (struct: _GSeekableIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def tell : CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset] = struct._2
    def tell_=(value: CFuncPtr1[Ptr[GSeekable], _root_.glib.goffset]): Unit = !struct.at2 = value
    def can_seek : CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean] = struct._3
    def can_seek_=(value: CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def seek : CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def seek_=(value: CFuncPtr5[Ptr[GSeekable], _root_.glib.goffset, _root_.glib.GSeekType, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value
    def can_truncate : CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean] = struct._5
    def can_truncate_=(value: CFuncPtr1[Ptr[GSeekable], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def truncate_fn : CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def truncate_fn_=(value: CFuncPtr4[Ptr[GSeekable], _root_.glib.goffset, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettings.h
*/
opaque type _GSettings = CStruct2[_root_.gobject.GObject, Ptr[GSettingsPrivate]]
object _GSettings:
  given _tag: Tag[_GSettings] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSettingsPrivate]]
  def apply()(using Zone): Ptr[_GSettings] = scala.scalanative.unsafe.alloc[_GSettings](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSettingsPrivate])(using Zone): Ptr[_GSettings] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSettings)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSettingsPrivate] = struct._2
    def priv_=(value: Ptr[GSettingsPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSettingsBackend = CStruct0
object _GSettingsBackend:
  given _tag: Tag[_GSettingsBackend] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettings.h
*/
opaque type _GSettingsClass = CStruct6[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean], CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]]]
object _GSettingsClass:
  given _tag: Tag[_GSettingsClass] = Tag.materializeCStruct6Tag[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean], CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]]]
  def apply()(using Zone): Ptr[_GSettingsClass] = scala.scalanative.unsafe.alloc[_GSettingsClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, writable_changed : CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], changed : CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit], writable_change_event : CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean], change_event : CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]])(using Zone): Ptr[_GSettingsClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).writable_changed = writable_changed
    (!____ptr).changed = changed
    (!____ptr).writable_change_event = writable_change_event
    (!____ptr).change_event = change_event
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GSettingsClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def writable_changed : CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit] = struct._2
    def writable_changed_=(value: CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at2 = value
    def changed : CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit] = struct._3
    def changed_=(value: CFuncPtr2[Ptr[GSettings], Ptr[_root_.glib.gchar], Unit]): Unit = !struct.at3 = value
    def writable_change_event : CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean] = struct._4
    def writable_change_event_=(value: CFuncPtr2[Ptr[GSettings], _root_.glib.GQuark, _root_.glib.gboolean]): Unit = !struct.at4 = value
    def change_event : CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean] = struct._5
    def change_event_=(value: CFuncPtr3[Ptr[GSettings], Ptr[_root_.glib.GQuark], _root_.glib.gint, _root_.glib.gboolean]): Unit = !struct.at5 = value
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]] = struct._6
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._0]]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettings.h
*/
opaque type _GSettingsPrivate = CStruct0
object _GSettingsPrivate:
  given _tag: Tag[_GSettingsPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettingsschema.h
*/
opaque type _GSettingsSchema = CStruct0
object _GSettingsSchema:
  given _tag: Tag[_GSettingsSchema] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettingsschema.h
*/
opaque type _GSettingsSchemaKey = CStruct0
object _GSettingsSchemaKey:
  given _tag: Tag[_GSettingsSchemaKey] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsettingsschema.h
*/
opaque type _GSettingsSchemaSource = CStruct0
object _GSettingsSchemaSource:
  given _tag: Tag[_GSettingsSchemaSource] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSimpleAction = CStruct0
object _GSimpleAction:
  given _tag: Tag[_GSimpleAction] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleactiongroup.h
*/
opaque type _GSimpleActionGroup = CStruct2[_root_.gobject.GObject, Ptr[GSimpleActionGroupPrivate]]
object _GSimpleActionGroup:
  given _tag: Tag[_GSimpleActionGroup] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSimpleActionGroupPrivate]]
  def apply()(using Zone): Ptr[_GSimpleActionGroup] = scala.scalanative.unsafe.alloc[_GSimpleActionGroup](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSimpleActionGroupPrivate])(using Zone): Ptr[_GSimpleActionGroup] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSimpleActionGroup)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSimpleActionGroupPrivate] = struct._2
    def priv_=(value: Ptr[GSimpleActionGroupPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleactiongroup.h
*/
opaque type _GSimpleActionGroupClass = CStruct2[_root_.gobject.GObjectClass, CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]
object _GSimpleActionGroupClass:
  given _tag: Tag[_GSimpleActionGroupClass] = Tag.materializeCStruct2Tag[_root_.gobject.GObjectClass, CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]]
  def apply()(using Zone): Ptr[_GSimpleActionGroupClass] = scala.scalanative.unsafe.alloc[_GSimpleActionGroupClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]])(using Zone): Ptr[_GSimpleActionGroupClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GSimpleActionGroupClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]] = struct._2
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._2]]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleactiongroup.h
*/
opaque type _GSimpleActionGroupPrivate = CStruct0
object _GSimpleActionGroupPrivate:
  given _tag: Tag[_GSimpleActionGroupPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSimpleAsyncResult = CStruct0
object _GSimpleAsyncResult:
  given _tag: Tag[_GSimpleAsyncResult] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleasyncresult.h
*/
opaque type _GSimpleAsyncResultClass = CStruct0
object _GSimpleAsyncResultClass:
  given _tag: Tag[_GSimpleAsyncResultClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSimpleIOStream = CStruct0
object _GSimpleIOStream:
  given _tag: Tag[_GSimpleIOStream] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSimplePermission = CStruct0
object _GSimplePermission:
  given _tag: Tag[_GSimplePermission] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleproxyresolver.h
*/
opaque type _GSimpleProxyResolver = CStruct2[_root_.gobject.GObject, Ptr[GSimpleProxyResolverPrivate]]
object _GSimpleProxyResolver:
  given _tag: Tag[_GSimpleProxyResolver] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSimpleProxyResolverPrivate]]
  def apply()(using Zone): Ptr[_GSimpleProxyResolver] = scala.scalanative.unsafe.alloc[_GSimpleProxyResolver](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSimpleProxyResolverPrivate])(using Zone): Ptr[_GSimpleProxyResolver] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSimpleProxyResolver)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSimpleProxyResolverPrivate] = struct._2
    def priv_=(value: Ptr[GSimpleProxyResolverPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleproxyresolver.h
*/
opaque type _GSimpleProxyResolverClass = CStruct6[_root_.gobject.GObjectClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSimpleProxyResolverClass:
  given _tag: Tag[_GSimpleProxyResolverClass] = Tag.materializeCStruct6Tag[_root_.gobject.GObjectClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSimpleProxyResolverClass] = scala.scalanative.unsafe.alloc[_GSimpleProxyResolverClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GSimpleProxyResolverClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GSimpleProxyResolverClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsimpleproxyresolver.h
*/
opaque type _GSimpleProxyResolverPrivate = CStruct0
object _GSimpleProxyResolverPrivate:
  given _tag: Tag[_GSimpleProxyResolverPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocket.h
*/
opaque type _GSocket = CStruct2[_root_.gobject.GObject, Ptr[GSocketPrivate]]
object _GSocket:
  given _tag: Tag[_GSocket] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSocketPrivate]]
  def apply()(using Zone): Ptr[_GSocket] = scala.scalanative.unsafe.alloc[_GSocket](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketPrivate])(using Zone): Ptr[_GSocket] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSocket)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSocketPrivate] = struct._2
    def priv_=(value: Ptr[GSocketPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddress.h
*/
opaque type _GSocketAddress = CStruct1[_root_.gobject.GObject]
object _GSocketAddress:
  given _tag: Tag[_GSocketAddress] = Tag.materializeCStruct1Tag[_root_.gobject.GObject]
  def apply()(using Zone): Ptr[_GSocketAddress] = scala.scalanative.unsafe.alloc[_GSocketAddress](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[_GSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: _GSocketAddress)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddress.h
*/
opaque type _GSocketAddressClass = CStruct4[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GSocketAddress], GSocketFamily], CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize], CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
object _GSocketAddressClass:
  given _tag: Tag[_GSocketAddressClass] = Tag.materializeCStruct4Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GSocketAddress], GSocketFamily], CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize], CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]]
  def apply()(using Zone): Ptr[_GSocketAddressClass] = scala.scalanative.unsafe.alloc[_GSocketAddressClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_family : CFuncPtr1[Ptr[GSocketAddress], GSocketFamily], get_native_size : CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize], to_native : CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean])(using Zone): Ptr[_GSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_family = get_family
    (!____ptr).get_native_size = get_native_size
    (!____ptr).to_native = to_native
    ____ptr
  extension (struct: _GSocketAddressClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_family : CFuncPtr1[Ptr[GSocketAddress], GSocketFamily] = struct._2
    def get_family_=(value: CFuncPtr1[Ptr[GSocketAddress], GSocketFamily]): Unit = !struct.at2 = value
    def get_native_size : CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize] = struct._3
    def get_native_size_=(value: CFuncPtr1[Ptr[GSocketAddress], _root_.glib.gssize]): Unit = !struct.at3 = value
    def to_native : CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._4
    def to_native_=(value: CFuncPtr4[Ptr[GSocketAddress], _root_.glib.gpointer, _root_.glib.gsize, Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddressenumerator.h
*/
opaque type _GSocketAddressEnumerator = CStruct1[_root_.gobject.GObject]
object _GSocketAddressEnumerator:
  given _tag: Tag[_GSocketAddressEnumerator] = Tag.materializeCStruct1Tag[_root_.gobject.GObject]
  def apply()(using Zone): Ptr[_GSocketAddressEnumerator] = scala.scalanative.unsafe.alloc[_GSocketAddressEnumerator](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[_GSocketAddressEnumerator] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: _GSocketAddressEnumerator)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value

/**
 * GSocketAddressEnumeratorClass: : Virtual method for g_socket_address_enumerator_next(). _async: Virtual method for g_socket_address_enumerator_next_async(). _finish: Virtual method for g_socket_address_enumerator_next_finish().

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketaddressenumerator.h
*/
opaque type _GSocketAddressEnumeratorClass = CStruct4[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]], CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]]
object _GSocketAddressEnumeratorClass:
  given _tag: Tag[_GSocketAddressEnumeratorClass] = Tag.materializeCStruct4Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]], CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]]
  def apply()(using Zone): Ptr[_GSocketAddressEnumeratorClass] = scala.scalanative.unsafe.alloc[_GSocketAddressEnumeratorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, next : CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]], next_async : CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], next_finish : CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]])(using Zone): Ptr[_GSocketAddressEnumeratorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).next = next
    (!____ptr).next_async = next_async
    (!____ptr).next_finish = next_finish
    ____ptr
  extension (struct: _GSocketAddressEnumeratorClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def next : CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]] = struct._2
    def next_=(value: CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]): Unit = !struct.at2 = value
    def next_async : CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def next_async_=(value: CFuncPtr4[Ptr[GSocketAddressEnumerator], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def next_finish : CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]] = struct._4
    def next_finish_=(value: CFuncPtr3[Ptr[GSocketAddressEnumerator], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GSocketAddress]]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocket.h
*/
opaque type _GSocketClass = CStruct11[_root_.gobject.GObjectClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSocketClass:
  given _tag: Tag[_GSocketClass] = Tag.materializeCStruct11Tag[_root_.gobject.GObjectClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSocketClass] = scala.scalanative.unsafe.alloc[_GSocketClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit], _g_reserved7 : CFuncPtr0[Unit], _g_reserved8 : CFuncPtr0[Unit], _g_reserved9 : CFuncPtr0[Unit], _g_reserved10 : CFuncPtr0[Unit])(using Zone): Ptr[_GSocketClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    (!____ptr)._g_reserved7 = _g_reserved7
    (!____ptr)._g_reserved8 = _g_reserved8
    (!____ptr)._g_reserved9 = _g_reserved9
    (!____ptr)._g_reserved10 = _g_reserved10
    ____ptr
  extension (struct: _GSocketClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._7
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved7 : CFuncPtr0[Unit] = struct._8
    def _g_reserved7_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved8 : CFuncPtr0[Unit] = struct._9
    def _g_reserved8_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value
    def _g_reserved9 : CFuncPtr0[Unit] = struct._10
    def _g_reserved9_=(value: CFuncPtr0[Unit]): Unit = !struct.at10 = value
    def _g_reserved10 : CFuncPtr0[Unit] = struct._11
    def _g_reserved10_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketclient.h
*/
opaque type _GSocketClient = CStruct2[_root_.gobject.GObject, Ptr[GSocketClientPrivate]]
object _GSocketClient:
  given _tag: Tag[_GSocketClient] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSocketClientPrivate]]
  def apply()(using Zone): Ptr[_GSocketClient] = scala.scalanative.unsafe.alloc[_GSocketClient](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketClientPrivate])(using Zone): Ptr[_GSocketClient] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSocketClient)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSocketClientPrivate] = struct._2
    def priv_=(value: Ptr[GSocketClientPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketclient.h
*/
opaque type _GSocketClientClass = CStruct6[_root_.gobject.GObjectClass, CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSocketClientClass:
  given _tag: Tag[_GSocketClientClass] = Tag.materializeCStruct6Tag[_root_.gobject.GObjectClass, CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSocketClientClass] = scala.scalanative.unsafe.alloc[_GSocketClientClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, event : CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit])(using Zone): Ptr[_GSocketClientClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).event = event
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    ____ptr
  extension (struct: _GSocketClientClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def event : CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit] = struct._2
    def event_=(value: CFuncPtr4[Ptr[GSocketClient], GSocketClientEvent, Ptr[GSocketConnectable], Ptr[GIOStream], Unit]): Unit = !struct.at2 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._3
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._4
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._5
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._6
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketclient.h
*/
opaque type _GSocketClientPrivate = CStruct0
object _GSocketClientPrivate:
  given _tag: Tag[_GSocketClientPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSocketConnectable = CStruct0
object _GSocketConnectable:
  given _tag: Tag[_GSocketConnectable] = Tag.materializeCStruct0Tag

/**
 * GSocketConnectableIface: _iface: The parent interface. : Creates a #GSocketAddressEnumerator _enumerate: Creates a #GProxyAddressEnumerator _string: Format the connectable’s address as a string for debugging. Implementing this is optional. (Since: 2.48)

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnectable.h
*/
opaque type _GSocketConnectableIface = CStruct4[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]]
object _GSocketConnectableIface:
  given _tag: Tag[_GSocketConnectableIface] = Tag.materializeCStruct4Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]]
  def apply()(using Zone): Ptr[_GSocketConnectableIface] = scala.scalanative.unsafe.alloc[_GSocketConnectableIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, enumerate : CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], proxy_enumerate : CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]], to_string : CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]])(using Zone): Ptr[_GSocketConnectableIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).enumerate = enumerate
    (!____ptr).proxy_enumerate = proxy_enumerate
    (!____ptr).to_string = to_string
    ____ptr
  extension (struct: _GSocketConnectableIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def enumerate : CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]] = struct._2
    def enumerate_=(value: CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]): Unit = !struct.at2 = value
    def proxy_enumerate : CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]] = struct._3
    def proxy_enumerate_=(value: CFuncPtr1[Ptr[GSocketConnectable], Ptr[GSocketAddressEnumerator]]): Unit = !struct.at3 = value
    def to_string : CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]] = struct._4
    def to_string_=(value: CFuncPtr1[Ptr[GSocketConnectable], Ptr[_root_.glib.gchar]]): Unit = !struct.at4 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnection.h
*/
opaque type _GSocketConnection = CStruct2[GIOStream, Ptr[GSocketConnectionPrivate]]
object _GSocketConnection:
  given _tag: Tag[_GSocketConnection] = Tag.materializeCStruct2Tag[GIOStream, Ptr[GSocketConnectionPrivate]]
  def apply()(using Zone): Ptr[_GSocketConnection] = scala.scalanative.unsafe.alloc[_GSocketConnection](1)
  def apply(parent_instance : GIOStream, priv : Ptr[GSocketConnectionPrivate])(using Zone): Ptr[_GSocketConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSocketConnection)
    def parent_instance : GIOStream = struct._1
    def parent_instance_=(value: GIOStream): Unit = !struct.at1 = value
    def priv : Ptr[GSocketConnectionPrivate] = struct._2
    def priv_=(value: Ptr[GSocketConnectionPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnection.h
*/
opaque type _GSocketConnectionClass = CStruct7[GIOStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSocketConnectionClass:
  given _tag: Tag[_GSocketConnectionClass] = Tag.materializeCStruct7Tag[GIOStreamClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSocketConnectionClass] = scala.scalanative.unsafe.alloc[_GSocketConnectionClass](1)
  def apply(parent_class : GIOStreamClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[_GSocketConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: _GSocketConnectionClass)
    def parent_class : GIOStreamClass = struct._1
    def parent_class_=(value: GIOStreamClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._7
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketconnection.h
*/
opaque type _GSocketConnectionPrivate = CStruct0
object _GSocketConnectionPrivate:
  given _tag: Tag[_GSocketConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketcontrolmessage.h
*/
opaque type _GSocketControlMessage = CStruct2[_root_.gobject.GObject, Ptr[GSocketControlMessagePrivate]]
object _GSocketControlMessage:
  given _tag: Tag[_GSocketControlMessage] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSocketControlMessagePrivate]]
  def apply()(using Zone): Ptr[_GSocketControlMessage] = scala.scalanative.unsafe.alloc[_GSocketControlMessage](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketControlMessagePrivate])(using Zone): Ptr[_GSocketControlMessage] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSocketControlMessage)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSocketControlMessagePrivate] = struct._2
    def priv_=(value: Ptr[GSocketControlMessagePrivate]): Unit = !struct.at2 = value

/**
 * GSocketControlMessageClass: _size: gets the size of the message. _level: gets the protocol of the message. _type: gets the protocol specific type of the message. : Writes out the message data. : Tries to deserialize a message.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketcontrolmessage.h
*/
opaque type _GSocketControlMessageClass = CStruct11[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize], CFuncPtr1[Ptr[GSocketControlMessage], CInt], CFuncPtr1[Ptr[GSocketControlMessage], CInt], CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit], CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSocketControlMessageClass:
  given _tag: Tag[_GSocketControlMessageClass] = Tag.materializeCStruct11Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize], CFuncPtr1[Ptr[GSocketControlMessage], CInt], CFuncPtr1[Ptr[GSocketControlMessage], CInt], CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit], CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSocketControlMessageClass] = scala.scalanative.unsafe.alloc[_GSocketControlMessageClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_size : CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize], get_level : CFuncPtr1[Ptr[GSocketControlMessage], CInt], get_type : CFuncPtr1[Ptr[GSocketControlMessage], CInt], serialize : CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit], deserialize : CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GSocketControlMessageClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_size = get_size
    (!____ptr).get_level = get_level
    (!____ptr).get_type = get_type
    (!____ptr).serialize = serialize
    (!____ptr).deserialize = deserialize
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GSocketControlMessageClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_size : CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize] = struct._2
    def get_size_=(value: CFuncPtr1[Ptr[GSocketControlMessage], _root_.glib.gsize]): Unit = !struct.at2 = value
    def get_level : CFuncPtr1[Ptr[GSocketControlMessage], CInt] = struct._3
    def get_level_=(value: CFuncPtr1[Ptr[GSocketControlMessage], CInt]): Unit = !struct.at3 = value
    def get_type : CFuncPtr1[Ptr[GSocketControlMessage], CInt] = struct._4
    def get_type_=(value: CFuncPtr1[Ptr[GSocketControlMessage], CInt]): Unit = !struct.at4 = value
    def serialize : CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit] = struct._5
    def serialize_=(value: CFuncPtr2[Ptr[GSocketControlMessage], _root_.glib.gpointer, Unit]): Unit = !struct.at5 = value
    def deserialize : CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]] = struct._6
    def deserialize_=(value: CFuncPtr4[CInt, CInt, _root_.glib.gsize, _root_.glib.gpointer, Ptr[GSocketControlMessage]]): Unit = !struct.at6 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._7
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._8
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._9
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at9 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._10
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at10 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._11
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at11 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketcontrolmessage.h
*/
opaque type _GSocketControlMessagePrivate = CStruct0
object _GSocketControlMessagePrivate:
  given _tag: Tag[_GSocketControlMessagePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketlistener.h
*/
opaque type _GSocketListener = CStruct2[_root_.gobject.GObject, Ptr[GSocketListenerPrivate]]
object _GSocketListener:
  given _tag: Tag[_GSocketListener] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GSocketListenerPrivate]]
  def apply()(using Zone): Ptr[_GSocketListener] = scala.scalanative.unsafe.alloc[_GSocketListener](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GSocketListenerPrivate])(using Zone): Ptr[_GSocketListener] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSocketListener)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GSocketListenerPrivate] = struct._2
    def priv_=(value: Ptr[GSocketListenerPrivate]): Unit = !struct.at2 = value

/**
 * GSocketListenerClass: : virtual method called when the set of socket listened to changes

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketlistener.h
*/
opaque type _GSocketListenerClass = CStruct8[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GSocketListener], Unit], CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSocketListenerClass:
  given _tag: Tag[_GSocketListenerClass] = Tag.materializeCStruct8Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GSocketListener], Unit], CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSocketListenerClass] = scala.scalanative.unsafe.alloc[_GSocketListenerClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, changed : CFuncPtr1[Ptr[GSocketListener], Unit], event : CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[_GSocketListenerClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).changed = changed
    (!____ptr).event = event
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: _GSocketListenerClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def changed : CFuncPtr1[Ptr[GSocketListener], Unit] = struct._2
    def changed_=(value: CFuncPtr1[Ptr[GSocketListener], Unit]): Unit = !struct.at2 = value
    def event : CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit] = struct._3
    def event_=(value: CFuncPtr3[Ptr[GSocketListener], GSocketListenerEvent, Ptr[GSocket], Unit]): Unit = !struct.at3 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._4
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._5
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._6
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._7
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._8
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketlistener.h
*/
opaque type _GSocketListenerPrivate = CStruct0
object _GSocketListenerPrivate:
  given _tag: Tag[_GSocketListenerPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocket.h
*/
opaque type _GSocketPrivate = CStruct0
object _GSocketPrivate:
  given _tag: Tag[_GSocketPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketservice.h
*/
opaque type _GSocketService = CStruct2[GSocketListener, Ptr[GSocketServicePrivate]]
object _GSocketService:
  given _tag: Tag[_GSocketService] = Tag.materializeCStruct2Tag[GSocketListener, Ptr[GSocketServicePrivate]]
  def apply()(using Zone): Ptr[_GSocketService] = scala.scalanative.unsafe.alloc[_GSocketService](1)
  def apply(parent_instance : GSocketListener, priv : Ptr[GSocketServicePrivate])(using Zone): Ptr[_GSocketService] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GSocketService)
    def parent_instance : GSocketListener = struct._1
    def parent_instance_=(value: GSocketListener): Unit = !struct.at1 = value
    def priv : Ptr[GSocketServicePrivate] = struct._2
    def priv_=(value: Ptr[GSocketServicePrivate]): Unit = !struct.at2 = value

/**
 * GSocketServiceClass: : signal emitted when new connections are accepted

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketservice.h
*/
opaque type _GSocketServiceClass = CStruct8[GSocketListenerClass, CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GSocketServiceClass:
  given _tag: Tag[_GSocketServiceClass] = Tag.materializeCStruct8Tag[GSocketListenerClass, CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GSocketServiceClass] = scala.scalanative.unsafe.alloc[_GSocketServiceClass](1)
  def apply(parent_class : GSocketListenerClass, incoming : CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[_GSocketServiceClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).incoming = incoming
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: _GSocketServiceClass)
    def parent_class : GSocketListenerClass = struct._1
    def parent_class_=(value: GSocketListenerClass): Unit = !struct.at1 = value
    def incoming : CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean] = struct._2
    def incoming_=(value: CFuncPtr3[Ptr[GSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._3
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._4
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._5
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._6
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._7
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._8
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gsocketservice.h
*/
opaque type _GSocketServicePrivate = CStruct0
object _GSocketServicePrivate:
  given _tag: Tag[_GSocketServicePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSrvTarget = CStruct0
object _GSrvTarget:
  given _tag: Tag[_GSrvTarget] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gresource.h
*/
opaque type _GStaticResource = CStruct5[Ptr[_root_.glib.guint8], _root_.glib.gsize, Ptr[GResource], Ptr[Byte], _root_.glib.gpointer]
object _GStaticResource:
  given _tag: Tag[_GStaticResource] = Tag.materializeCStruct5Tag[Ptr[_root_.glib.guint8], _root_.glib.gsize, Ptr[GResource], Ptr[Byte], _root_.glib.gpointer]
  def apply()(using Zone): Ptr[_GStaticResource] = scala.scalanative.unsafe.alloc[_GStaticResource](1)
  def apply(data : Ptr[_root_.glib.guint8], data_len : _root_.glib.gsize, resource : Ptr[GResource], next : Ptr[GStaticResource], padding : _root_.glib.gpointer)(using Zone): Ptr[_GStaticResource] = 
    val ____ptr = apply()
    (!____ptr).data = data
    (!____ptr).data_len = data_len
    (!____ptr).resource = resource
    (!____ptr).next = next
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GStaticResource)
    def data : Ptr[_root_.glib.guint8] = struct._1
    def data_=(value: Ptr[_root_.glib.guint8]): Unit = !struct.at1 = value
    def data_len : _root_.glib.gsize = struct._2
    def data_len_=(value: _root_.glib.gsize): Unit = !struct.at2 = value
    def resource : Ptr[GResource] = struct._3
    def resource_=(value: Ptr[GResource]): Unit = !struct.at3 = value
    def next : Ptr[GStaticResource] = struct._4.asInstanceOf[Ptr[GStaticResource]]
    def next_=(value: Ptr[GStaticResource]): Unit = !struct.at4 = value.asInstanceOf[Ptr[Byte]]
    def padding : _root_.glib.gpointer = struct._5
    def padding_=(value: _root_.glib.gpointer): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSubprocess = CStruct0
object _GSubprocess:
  given _tag: Tag[_GSubprocess] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GSubprocessLauncher = CStruct0
object _GSubprocessLauncher:
  given _tag: Tag[_GSubprocessLauncher] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GTask = CStruct0
object _GTask:
  given _tag: Tag[_GTask] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtask.h
*/
opaque type _GTaskClass = CStruct0
object _GTaskClass:
  given _tag: Tag[_GTaskClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpconnection.h
*/
opaque type _GTcpConnection = CStruct2[GSocketConnection, Ptr[GTcpConnectionPrivate]]
object _GTcpConnection:
  given _tag: Tag[_GTcpConnection] = Tag.materializeCStruct2Tag[GSocketConnection, Ptr[GTcpConnectionPrivate]]
  def apply()(using Zone): Ptr[_GTcpConnection] = scala.scalanative.unsafe.alloc[_GTcpConnection](1)
  def apply(parent_instance : GSocketConnection, priv : Ptr[GTcpConnectionPrivate])(using Zone): Ptr[_GTcpConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTcpConnection)
    def parent_instance : GSocketConnection = struct._1
    def parent_instance_=(value: GSocketConnection): Unit = !struct.at1 = value
    def priv : Ptr[GTcpConnectionPrivate] = struct._2
    def priv_=(value: Ptr[GTcpConnectionPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpconnection.h
*/
opaque type _GTcpConnectionClass = CStruct1[GSocketConnectionClass]
object _GTcpConnectionClass:
  given _tag: Tag[_GTcpConnectionClass] = Tag.materializeCStruct1Tag[GSocketConnectionClass]
  def apply()(using Zone): Ptr[_GTcpConnectionClass] = scala.scalanative.unsafe.alloc[_GTcpConnectionClass](1)
  def apply(parent_class : GSocketConnectionClass)(using Zone): Ptr[_GTcpConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GTcpConnectionClass)
    def parent_class : GSocketConnectionClass = struct._1
    def parent_class_=(value: GSocketConnectionClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpconnection.h
*/
opaque type _GTcpConnectionPrivate = CStruct0
object _GTcpConnectionPrivate:
  given _tag: Tag[_GTcpConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpwrapperconnection.h
*/
opaque type _GTcpWrapperConnection = CStruct2[GTcpConnection, Ptr[GTcpWrapperConnectionPrivate]]
object _GTcpWrapperConnection:
  given _tag: Tag[_GTcpWrapperConnection] = Tag.materializeCStruct2Tag[GTcpConnection, Ptr[GTcpWrapperConnectionPrivate]]
  def apply()(using Zone): Ptr[_GTcpWrapperConnection] = scala.scalanative.unsafe.alloc[_GTcpWrapperConnection](1)
  def apply(parent_instance : GTcpConnection, priv : Ptr[GTcpWrapperConnectionPrivate])(using Zone): Ptr[_GTcpWrapperConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTcpWrapperConnection)
    def parent_instance : GTcpConnection = struct._1
    def parent_instance_=(value: GTcpConnection): Unit = !struct.at1 = value
    def priv : Ptr[GTcpWrapperConnectionPrivate] = struct._2
    def priv_=(value: Ptr[GTcpWrapperConnectionPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpwrapperconnection.h
*/
opaque type _GTcpWrapperConnectionClass = CStruct1[GTcpConnectionClass]
object _GTcpWrapperConnectionClass:
  given _tag: Tag[_GTcpWrapperConnectionClass] = Tag.materializeCStruct1Tag[GTcpConnectionClass]
  def apply()(using Zone): Ptr[_GTcpWrapperConnectionClass] = scala.scalanative.unsafe.alloc[_GTcpWrapperConnectionClass](1)
  def apply(parent_class : GTcpConnectionClass)(using Zone): Ptr[_GTcpWrapperConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GTcpWrapperConnectionClass)
    def parent_class : GTcpConnectionClass = struct._1
    def parent_class_=(value: GTcpConnectionClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtcpwrapperconnection.h
*/
opaque type _GTcpWrapperConnectionPrivate = CStruct0
object _GTcpWrapperConnectionPrivate:
  given _tag: Tag[_GTcpWrapperConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GTestDBus = CStruct0
object _GTestDBus:
  given _tag: Tag[_GTestDBus] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GThemedIcon = CStruct0
object _GThemedIcon:
  given _tag: Tag[_GThemedIcon] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthemedicon.h
*/
opaque type _GThemedIconClass = CStruct0
object _GThemedIconClass:
  given _tag: Tag[_GThemedIconClass] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthreadedsocketservice.h
*/
opaque type _GThreadedSocketService = CStruct2[GSocketService, Ptr[GThreadedSocketServicePrivate]]
object _GThreadedSocketService:
  given _tag: Tag[_GThreadedSocketService] = Tag.materializeCStruct2Tag[GSocketService, Ptr[GThreadedSocketServicePrivate]]
  def apply()(using Zone): Ptr[_GThreadedSocketService] = scala.scalanative.unsafe.alloc[_GThreadedSocketService](1)
  def apply(parent_instance : GSocketService, priv : Ptr[GThreadedSocketServicePrivate])(using Zone): Ptr[_GThreadedSocketService] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GThreadedSocketService)
    def parent_instance : GSocketService = struct._1
    def parent_instance_=(value: GSocketService): Unit = !struct.at1 = value
    def priv : Ptr[GThreadedSocketServicePrivate] = struct._2
    def priv_=(value: Ptr[GThreadedSocketServicePrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthreadedsocketservice.h
*/
opaque type _GThreadedSocketServiceClass = CStruct7[GSocketServiceClass, CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GThreadedSocketServiceClass:
  given _tag: Tag[_GThreadedSocketServiceClass] = Tag.materializeCStruct7Tag[GSocketServiceClass, CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GThreadedSocketServiceClass] = scala.scalanative.unsafe.alloc[_GThreadedSocketServiceClass](1)
  def apply(parent_class : GSocketServiceClass, run : CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GThreadedSocketServiceClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).run = run
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GThreadedSocketServiceClass)
    def parent_class : GSocketServiceClass = struct._1
    def parent_class_=(value: GSocketServiceClass): Unit = !struct.at1 = value
    def run : CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean] = struct._2
    def run_=(value: CFuncPtr3[Ptr[GThreadedSocketService], Ptr[GSocketConnection], Ptr[_root_.gobject.GObject], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._3
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._4
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._5
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._6
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._7
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at7 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gthreadedsocketservice.h
*/
opaque type _GThreadedSocketServicePrivate = CStruct0
object _GThreadedSocketServicePrivate:
  given _tag: Tag[_GThreadedSocketServicePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsbackend.h
*/
opaque type _GTlsBackend = CStruct0
object _GTlsBackend:
  given _tag: Tag[_GTlsBackend] = Tag.materializeCStruct0Tag

/**
 * GTlsBackendInterface: _iface: The parent interface. _tls: returns whether the backend supports TLS. _dtls: returns whether the backend supports DTLS _default_database: returns a default #GTlsDatabase instance. _certificate_type: returns the #GTlsCertificate implementation type _client_connection_type: returns the #GTlsClientConnection implementation type _server_connection_type: returns the #GTlsServerConnection implementation type _file_database_type: returns the #GTlsFileDatabase implementation type. _dtls_client_connection_type: returns the #GDtlsClientConnection implementation type _dtls_server_connection_type: returns the #GDtlsServerConnection implementation type

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsbackend.h
*/
opaque type _GTlsBackendInterface = CStruct10[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType], CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]], CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType]]
object _GTlsBackendInterface:
  given _tag: Tag[_GTlsBackendInterface] = Tag.materializeCStruct10Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType], CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]], CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], CFuncPtr0[_root_.gobject.GType], CFuncPtr0[_root_.gobject.GType]]
  def apply()(using Zone): Ptr[_GTlsBackendInterface] = scala.scalanative.unsafe.alloc[_GTlsBackendInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, supports_tls : CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], get_certificate_type : CFuncPtr0[_root_.gobject.GType], get_client_connection_type : CFuncPtr0[_root_.gobject.GType], get_server_connection_type : CFuncPtr0[_root_.gobject.GType], get_file_database_type : CFuncPtr0[_root_.gobject.GType], get_default_database : CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]], supports_dtls : CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean], get_dtls_client_connection_type : CFuncPtr0[_root_.gobject.GType], get_dtls_server_connection_type : CFuncPtr0[_root_.gobject.GType])(using Zone): Ptr[_GTlsBackendInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).supports_tls = supports_tls
    (!____ptr).get_certificate_type = get_certificate_type
    (!____ptr).get_client_connection_type = get_client_connection_type
    (!____ptr).get_server_connection_type = get_server_connection_type
    (!____ptr).get_file_database_type = get_file_database_type
    (!____ptr).get_default_database = get_default_database
    (!____ptr).supports_dtls = supports_dtls
    (!____ptr).get_dtls_client_connection_type = get_dtls_client_connection_type
    (!____ptr).get_dtls_server_connection_type = get_dtls_server_connection_type
    ____ptr
  extension (struct: _GTlsBackendInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def supports_tls : CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean] = struct._2
    def supports_tls_=(value: CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def get_certificate_type : CFuncPtr0[_root_.gobject.GType] = struct._3
    def get_certificate_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at3 = value
    def get_client_connection_type : CFuncPtr0[_root_.gobject.GType] = struct._4
    def get_client_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at4 = value
    def get_server_connection_type : CFuncPtr0[_root_.gobject.GType] = struct._5
    def get_server_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at5 = value
    def get_file_database_type : CFuncPtr0[_root_.gobject.GType] = struct._6
    def get_file_database_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at6 = value
    def get_default_database : CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]] = struct._7
    def get_default_database_=(value: CFuncPtr1[Ptr[GTlsBackend], Ptr[GTlsDatabase]]): Unit = !struct.at7 = value
    def supports_dtls : CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean] = struct._8
    def supports_dtls_=(value: CFuncPtr1[Ptr[GTlsBackend], _root_.glib.gboolean]): Unit = !struct.at8 = value
    def get_dtls_client_connection_type : CFuncPtr0[_root_.gobject.GType] = struct._9
    def get_dtls_client_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at9 = value
    def get_dtls_server_connection_type : CFuncPtr0[_root_.gobject.GType] = struct._10
    def get_dtls_server_connection_type_=(value: CFuncPtr0[_root_.gobject.GType]): Unit = !struct.at10 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlscertificate.h
*/
opaque type _GTlsCertificate = CStruct2[_root_.gobject.GObject, Ptr[GTlsCertificatePrivate]]
object _GTlsCertificate:
  given _tag: Tag[_GTlsCertificate] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GTlsCertificatePrivate]]
  def apply()(using Zone): Ptr[_GTlsCertificate] = scala.scalanative.unsafe.alloc[_GTlsCertificate](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsCertificatePrivate])(using Zone): Ptr[_GTlsCertificate] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTlsCertificate)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GTlsCertificatePrivate] = struct._2
    def priv_=(value: Ptr[GTlsCertificatePrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlscertificate.h
*/
opaque type _GTlsCertificateClass = CStruct3[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags], CArray[_root_.glib.gpointer, Nat._8]]
object _GTlsCertificateClass:
  given _tag: Tag[_GTlsCertificateClass] = Tag.materializeCStruct3Tag[_root_.gobject.GObjectClass, CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags], CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GTlsCertificateClass] = scala.scalanative.unsafe.alloc[_GTlsCertificateClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, verify : CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags], padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GTlsCertificateClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).verify = verify
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GTlsCertificateClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def verify : CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags] = struct._2
    def verify_=(value: CFuncPtr3[Ptr[GTlsCertificate], Ptr[GSocketConnectable], Ptr[GTlsCertificate], GTlsCertificateFlags]): Unit = !struct.at2 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._3
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlscertificate.h
*/
opaque type _GTlsCertificatePrivate = CStruct0
object _GTlsCertificatePrivate:
  given _tag: Tag[_GTlsCertificatePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GTlsClientConnection = CStruct0
object _GTlsClientConnection:
  given _tag: Tag[_GTlsClientConnection] = Tag.materializeCStruct0Tag

/**
 * GTlsClientConnectionInterface: _iface: The parent interface. _session_state: Copies session state from one #GTlsClientConnection to another.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsclientconnection.h
*/
opaque type _GTlsClientConnectionInterface = CStruct2[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]]
object _GTlsClientConnectionInterface:
  given _tag: Tag[_GTlsClientConnectionInterface] = Tag.materializeCStruct2Tag[_root_.gobject.GTypeInterface, CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]]
  def apply()(using Zone): Ptr[_GTlsClientConnectionInterface] = scala.scalanative.unsafe.alloc[_GTlsClientConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, copy_session_state : CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit])(using Zone): Ptr[_GTlsClientConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).copy_session_state = copy_session_state
    ____ptr
  extension (struct: _GTlsClientConnectionInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def copy_session_state : CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit] = struct._2
    def copy_session_state_=(value: CFuncPtr2[Ptr[GTlsClientConnection], Ptr[GTlsClientConnection], Unit]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsconnection.h
*/
opaque type _GTlsConnection = CStruct2[GIOStream, Ptr[GTlsConnectionPrivate]]
object _GTlsConnection:
  given _tag: Tag[_GTlsConnection] = Tag.materializeCStruct2Tag[GIOStream, Ptr[GTlsConnectionPrivate]]
  def apply()(using Zone): Ptr[_GTlsConnection] = scala.scalanative.unsafe.alloc[_GTlsConnection](1)
  def apply(parent_instance : GIOStream, priv : Ptr[GTlsConnectionPrivate])(using Zone): Ptr[_GTlsConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTlsConnection)
    def parent_instance : GIOStream = struct._1
    def parent_instance_=(value: GIOStream): Unit = !struct.at1 = value
    def priv : Ptr[GTlsConnectionPrivate] = struct._2
    def priv_=(value: Ptr[GTlsConnectionPrivate]): Unit = !struct.at2 = value

/**
 * GTlsConnectionClass: _class: The parent class. _certificate: Check whether to accept a certificate. : Perform a handshake operation. _async: Start an asynchronous handshake operation. _finish: Finish an asynchronous handshake operation. _binding_data: Retrieve TLS channel binding data (Since: 2.66) _negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsconnection.h
*/
opaque type _GTlsConnectionClass = CStruct8[GIOStreamClass, CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]], CArray[_root_.glib.gpointer, Nat._6]]
object _GTlsConnectionClass:
  given _tag: Tag[_GTlsConnectionClass] = Tag.materializeCStruct8Tag[GIOStreamClass, CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]], CArray[_root_.glib.gpointer, Nat._6]]
  def apply()(using Zone): Ptr[_GTlsConnectionClass] = scala.scalanative.unsafe.alloc[_GTlsConnectionClass](1)
  def apply(parent_class : GIOStreamClass, accept_certificate : CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean], handshake : CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], handshake_async : CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], handshake_finish : CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_binding_data : CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_negotiated_protocol : CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]], padding : CArray[_root_.glib.gpointer, Nat._6])(using Zone): Ptr[_GTlsConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).accept_certificate = accept_certificate
    (!____ptr).handshake = handshake
    (!____ptr).handshake_async = handshake_async
    (!____ptr).handshake_finish = handshake_finish
    (!____ptr).get_binding_data = get_binding_data
    (!____ptr).get_negotiated_protocol = get_negotiated_protocol
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GTlsConnectionClass)
    def parent_class : GIOStreamClass = struct._1
    def parent_class_=(value: GIOStreamClass): Unit = !struct.at1 = value
    def accept_certificate : CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean] = struct._2
    def accept_certificate_=(value: CFuncPtr3[Ptr[GTlsConnection], Ptr[GTlsCertificate], GTlsCertificateFlags, _root_.glib.gboolean]): Unit = !struct.at2 = value
    def handshake : CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._3
    def handshake_=(value: CFuncPtr3[Ptr[GTlsConnection], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at3 = value
    def handshake_async : CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._4
    def handshake_async_=(value: CFuncPtr5[Ptr[GTlsConnection], CInt, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at4 = value
    def handshake_finish : CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._5
    def handshake_finish_=(value: CFuncPtr3[Ptr[GTlsConnection], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at5 = value
    def get_binding_data : CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._6
    def get_binding_data_=(value: CFuncPtr4[Ptr[GTlsConnection], GTlsChannelBindingType, Ptr[_root_.glib.GByteArray], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at6 = value
    def get_negotiated_protocol : CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]] = struct._7
    def get_negotiated_protocol_=(value: CFuncPtr1[Ptr[GTlsConnection], Ptr[_root_.glib.gchar]]): Unit = !struct.at7 = value
    def padding : CArray[_root_.glib.gpointer, Nat._6] = struct._8
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._6]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsconnection.h
*/
opaque type _GTlsConnectionPrivate = CStruct0
object _GTlsConnectionPrivate:
  given _tag: Tag[_GTlsConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsdatabase.h
*/
opaque type _GTlsDatabase = CStruct2[_root_.gobject.GObject, Ptr[GTlsDatabasePrivate]]
object _GTlsDatabase:
  given _tag: Tag[_GTlsDatabase] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GTlsDatabasePrivate]]
  def apply()(using Zone): Ptr[_GTlsDatabase] = scala.scalanative.unsafe.alloc[_GTlsDatabase](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsDatabasePrivate])(using Zone): Ptr[_GTlsDatabase] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTlsDatabase)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GTlsDatabasePrivate] = struct._2
    def priv_=(value: Ptr[GTlsDatabasePrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsdatabase.h
*/
opaque type _GTlsDatabaseClass = CStruct15[_root_.gobject.GObjectClass, CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]], CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]
object _GTlsDatabaseClass:
  given _tag: Tag[_GTlsDatabaseClass] = Tag.materializeCStruct15Tag[_root_.gobject.GObjectClass, CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]], CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]]
  def apply()(using Zone): Ptr[_GTlsDatabaseClass] = scala.scalanative.unsafe.alloc[_GTlsDatabaseClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, verify_chain : CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], verify_chain_async : CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], verify_chain_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags], create_certificate_handle : CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]], lookup_certificate_for_handle : CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificate_for_handle_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_certificate_for_handle_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificate_issuer : CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificate_issuer_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_certificate_issuer_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]], lookup_certificates_issued_by : CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], lookup_certificates_issued_by_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], lookup_certificates_issued_by_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]])(using Zone): Ptr[_GTlsDatabaseClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).verify_chain = verify_chain
    (!____ptr).verify_chain_async = verify_chain_async
    (!____ptr).verify_chain_finish = verify_chain_finish
    (!____ptr).create_certificate_handle = create_certificate_handle
    (!____ptr).lookup_certificate_for_handle = lookup_certificate_for_handle
    (!____ptr).lookup_certificate_for_handle_async = lookup_certificate_for_handle_async
    (!____ptr).lookup_certificate_for_handle_finish = lookup_certificate_for_handle_finish
    (!____ptr).lookup_certificate_issuer = lookup_certificate_issuer
    (!____ptr).lookup_certificate_issuer_async = lookup_certificate_issuer_async
    (!____ptr).lookup_certificate_issuer_finish = lookup_certificate_issuer_finish
    (!____ptr).lookup_certificates_issued_by = lookup_certificates_issued_by
    (!____ptr).lookup_certificates_issued_by_async = lookup_certificates_issued_by_async
    (!____ptr).lookup_certificates_issued_by_finish = lookup_certificates_issued_by_finish
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GTlsDatabaseClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def verify_chain : CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags] = struct._2
    def verify_chain_=(value: CFuncPtr8[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]): Unit = !struct.at2 = value
    def verify_chain_async : CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def verify_chain_async_=(value: CFuncPtr9[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar], Ptr[GSocketConnectable], Ptr[GTlsInteraction], GTlsDatabaseVerifyFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def verify_chain_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags] = struct._4
    def verify_chain_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsCertificateFlags]): Unit = !struct.at4 = value
    def create_certificate_handle : CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]] = struct._5
    def create_certificate_handle_=(value: CFuncPtr2[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[_root_.glib.gchar]]): Unit = !struct.at5 = value
    def lookup_certificate_for_handle : CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = struct._6
    def lookup_certificate_for_handle_=(value: CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at6 = value
    def lookup_certificate_for_handle_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._7
    def lookup_certificate_for_handle_async_=(value: CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.gchar], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at7 = value
    def lookup_certificate_for_handle_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = struct._8
    def lookup_certificate_for_handle_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at8 = value
    def lookup_certificate_issuer : CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = struct._9
    def lookup_certificate_issuer_=(value: CFuncPtr6[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at9 = value
    def lookup_certificate_issuer_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._10
    def lookup_certificate_issuer_async_=(value: CFuncPtr7[Ptr[GTlsDatabase], Ptr[GTlsCertificate], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at10 = value
    def lookup_certificate_issuer_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]] = struct._11
    def lookup_certificate_issuer_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[GTlsCertificate]]): Unit = !struct.at11 = value
    def lookup_certificates_issued_by : CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._12.asInstanceOf[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_certificates_issued_by_=(value: CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at12 = value.asInstanceOf[CFuncPtr6[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def lookup_certificates_issued_by_async : CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._13
    def lookup_certificates_issued_by_async_=(value: CFuncPtr7[Ptr[GTlsDatabase], Ptr[_root_.glib.GByteArray], Ptr[GTlsInteraction], GTlsDatabaseLookupFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at13 = value
    def lookup_certificates_issued_by_finish : CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]] = struct._14.asInstanceOf[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]]
    def lookup_certificates_issued_by_finish_=(value: CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[_root_.glib.GList]]): Unit = !struct.at14 = value.asInstanceOf[CFuncPtr3[Ptr[GTlsDatabase], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], Ptr[Byte]]]
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]] = struct._15
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._1, Nat._6]]): Unit = !struct.at15 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsdatabase.h
*/
opaque type _GTlsDatabasePrivate = CStruct0
object _GTlsDatabasePrivate:
  given _tag: Tag[_GTlsDatabasePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GTlsFileDatabase = CStruct0
object _GTlsFileDatabase:
  given _tag: Tag[_GTlsFileDatabase] = Tag.materializeCStruct0Tag

/**
 * GTlsFileDatabaseInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsfiledatabase.h
*/
opaque type _GTlsFileDatabaseInterface = CStruct2[_root_.gobject.GTypeInterface, CArray[_root_.glib.gpointer, Nat._8]]
object _GTlsFileDatabaseInterface:
  given _tag: Tag[_GTlsFileDatabaseInterface] = Tag.materializeCStruct2Tag[_root_.gobject.GTypeInterface, CArray[_root_.glib.gpointer, Nat._8]]
  def apply()(using Zone): Ptr[_GTlsFileDatabaseInterface] = scala.scalanative.unsafe.alloc[_GTlsFileDatabaseInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, padding : CArray[_root_.glib.gpointer, Nat._8])(using Zone): Ptr[_GTlsFileDatabaseInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GTlsFileDatabaseInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def padding : CArray[_root_.glib.gpointer, Nat._8] = struct._2
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._8]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsinteraction.h
*/
opaque type _GTlsInteraction = CStruct2[_root_.gobject.GObject, Ptr[GTlsInteractionPrivate]]
object _GTlsInteraction:
  given _tag: Tag[_GTlsInteraction] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GTlsInteractionPrivate]]
  def apply()(using Zone): Ptr[_GTlsInteraction] = scala.scalanative.unsafe.alloc[_GTlsInteraction](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsInteractionPrivate])(using Zone): Ptr[_GTlsInteraction] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTlsInteraction)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GTlsInteractionPrivate] = struct._2
    def priv_=(value: Ptr[GTlsInteractionPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsinteraction.h
*/
opaque type _GTlsInteractionClass = CStruct8[_root_.gobject.GObjectClass, CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]]]
object _GTlsInteractionClass:
  given _tag: Tag[_GTlsInteractionClass] = Tag.materializeCStruct8Tag[_root_.gobject.GObjectClass, CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]]]
  def apply()(using Zone): Ptr[_GTlsInteractionClass] = scala.scalanative.unsafe.alloc[_GTlsInteractionClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, ask_password : CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], ask_password_async : CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], ask_password_finish : CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], request_certificate : CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], request_certificate_async : CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], request_certificate_finish : CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult], padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]])(using Zone): Ptr[_GTlsInteractionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).ask_password = ask_password
    (!____ptr).ask_password_async = ask_password_async
    (!____ptr).ask_password_finish = ask_password_finish
    (!____ptr).request_certificate = request_certificate
    (!____ptr).request_certificate_async = request_certificate_async
    (!____ptr).request_certificate_finish = request_certificate_finish
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GTlsInteractionClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def ask_password : CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = struct._2
    def ask_password_=(value: CFuncPtr4[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at2 = value
    def ask_password_async : CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._3
    def ask_password_async_=(value: CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsPassword], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at3 = value
    def ask_password_finish : CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = struct._4
    def ask_password_finish_=(value: CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at4 = value
    def request_certificate : CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = struct._5
    def request_certificate_=(value: CFuncPtr5[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at5 = value
    def request_certificate_async : CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._6
    def request_certificate_async_=(value: CFuncPtr6[Ptr[GTlsInteraction], Ptr[GTlsConnection], GTlsCertificateRequestFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at6 = value
    def request_certificate_finish : CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult] = struct._7
    def request_certificate_finish_=(value: CFuncPtr3[Ptr[GTlsInteraction], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], GTlsInteractionResult]): Unit = !struct.at7 = value
    def padding : CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]] = struct._8
    def padding_=(value: CArray[_root_.glib.gpointer, Nat.Digit2[Nat._2, Nat._1]]): Unit = !struct.at8 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsinteraction.h
*/
opaque type _GTlsInteractionPrivate = CStruct0
object _GTlsInteractionPrivate:
  given _tag: Tag[_GTlsInteractionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlspassword.h
*/
opaque type _GTlsPassword = CStruct2[_root_.gobject.GObject, Ptr[GTlsPasswordPrivate]]
object _GTlsPassword:
  given _tag: Tag[_GTlsPassword] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GTlsPasswordPrivate]]
  def apply()(using Zone): Ptr[_GTlsPassword] = scala.scalanative.unsafe.alloc[_GTlsPassword](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GTlsPasswordPrivate])(using Zone): Ptr[_GTlsPassword] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GTlsPassword)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GTlsPasswordPrivate] = struct._2
    def priv_=(value: Ptr[GTlsPasswordPrivate]): Unit = !struct.at2 = value

/**
 * GTlsPasswordClass: _value: virtual method for g_tls_password_get_value()

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlspassword.h
*/
opaque type _GTlsPasswordClass = CStruct5[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]], CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit], CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]], CArray[_root_.glib.gpointer, Nat._4]]
object _GTlsPasswordClass:
  given _tag: Tag[_GTlsPasswordClass] = Tag.materializeCStruct5Tag[_root_.gobject.GObjectClass, CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]], CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit], CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]], CArray[_root_.glib.gpointer, Nat._4]]
  def apply()(using Zone): Ptr[_GTlsPasswordClass] = scala.scalanative.unsafe.alloc[_GTlsPasswordClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, get_value : CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]], set_value : CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit], get_default_warning : CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]], padding : CArray[_root_.glib.gpointer, Nat._4])(using Zone): Ptr[_GTlsPasswordClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).get_value = get_value
    (!____ptr).set_value = set_value
    (!____ptr).get_default_warning = get_default_warning
    (!____ptr).padding = padding
    ____ptr
  extension (struct: _GTlsPasswordClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def get_value : CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]] = struct._2
    def get_value_=(value: CFuncPtr2[Ptr[GTlsPassword], Ptr[_root_.glib.gsize], Ptr[_root_.glib.guchar]]): Unit = !struct.at2 = value
    def set_value : CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit] = struct._3
    def set_value_=(value: CFuncPtr4[Ptr[GTlsPassword], Ptr[_root_.glib.guchar], _root_.glib.gssize, _root_.glib.GDestroyNotify, Unit]): Unit = !struct.at3 = value
    def get_default_warning : CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]] = struct._4
    def get_default_warning_=(value: CFuncPtr1[Ptr[GTlsPassword], Ptr[_root_.glib.gchar]]): Unit = !struct.at4 = value
    def padding : CArray[_root_.glib.gpointer, Nat._4] = struct._5
    def padding_=(value: CArray[_root_.glib.gpointer, Nat._4]): Unit = !struct.at5 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlspassword.h
*/
opaque type _GTlsPasswordPrivate = CStruct0
object _GTlsPasswordPrivate:
  given _tag: Tag[_GTlsPasswordPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GTlsServerConnection = CStruct0
object _GTlsServerConnection:
  given _tag: Tag[_GTlsServerConnection] = Tag.materializeCStruct0Tag

/**
 * GTlsServerConnectionInterface: _iface: The parent interface.

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gtlsserverconnection.h
*/
opaque type _GTlsServerConnectionInterface = CStruct1[_root_.gobject.GTypeInterface]
object _GTlsServerConnectionInterface:
  given _tag: Tag[_GTlsServerConnectionInterface] = Tag.materializeCStruct1Tag[_root_.gobject.GTypeInterface]
  def apply()(using Zone): Ptr[_GTlsServerConnectionInterface] = scala.scalanative.unsafe.alloc[_GTlsServerConnectionInterface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface)(using Zone): Ptr[_GTlsServerConnectionInterface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    ____ptr
  extension (struct: _GTlsServerConnectionInterface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixconnection.h
*/
opaque type _GUnixConnection = CStruct2[GSocketConnection, Ptr[GUnixConnectionPrivate]]
object _GUnixConnection:
  given _tag: Tag[_GUnixConnection] = Tag.materializeCStruct2Tag[GSocketConnection, Ptr[GUnixConnectionPrivate]]
  def apply()(using Zone): Ptr[_GUnixConnection] = scala.scalanative.unsafe.alloc[_GUnixConnection](1)
  def apply(parent_instance : GSocketConnection, priv : Ptr[GUnixConnectionPrivate])(using Zone): Ptr[_GUnixConnection] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GUnixConnection)
    def parent_instance : GSocketConnection = struct._1
    def parent_instance_=(value: GSocketConnection): Unit = !struct.at1 = value
    def priv : Ptr[GUnixConnectionPrivate] = struct._2
    def priv_=(value: Ptr[GUnixConnectionPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixconnection.h
*/
opaque type _GUnixConnectionClass = CStruct1[GSocketConnectionClass]
object _GUnixConnectionClass:
  given _tag: Tag[_GUnixConnectionClass] = Tag.materializeCStruct1Tag[GSocketConnectionClass]
  def apply()(using Zone): Ptr[_GUnixConnectionClass] = scala.scalanative.unsafe.alloc[_GUnixConnectionClass](1)
  def apply(parent_class : GSocketConnectionClass)(using Zone): Ptr[_GUnixConnectionClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GUnixConnectionClass)
    def parent_class : GSocketConnectionClass = struct._1
    def parent_class_=(value: GSocketConnectionClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixconnection.h
*/
opaque type _GUnixConnectionPrivate = CStruct0
object _GUnixConnectionPrivate:
  given _tag: Tag[_GUnixConnectionPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixcredentialsmessage.h
*/
opaque type _GUnixCredentialsMessage = CStruct2[GSocketControlMessage, Ptr[GUnixCredentialsMessagePrivate]]
object _GUnixCredentialsMessage:
  given _tag: Tag[_GUnixCredentialsMessage] = Tag.materializeCStruct2Tag[GSocketControlMessage, Ptr[GUnixCredentialsMessagePrivate]]
  def apply()(using Zone): Ptr[_GUnixCredentialsMessage] = scala.scalanative.unsafe.alloc[_GUnixCredentialsMessage](1)
  def apply(parent_instance : GSocketControlMessage, priv : Ptr[GUnixCredentialsMessagePrivate])(using Zone): Ptr[_GUnixCredentialsMessage] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GUnixCredentialsMessage)
    def parent_instance : GSocketControlMessage = struct._1
    def parent_instance_=(value: GSocketControlMessage): Unit = !struct.at1 = value
    def priv : Ptr[GUnixCredentialsMessagePrivate] = struct._2
    def priv_=(value: Ptr[GUnixCredentialsMessagePrivate]): Unit = !struct.at2 = value

/**
 * GUnixCredentialsMessageClass:

 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixcredentialsmessage.h
*/
opaque type _GUnixCredentialsMessageClass = CStruct3[GSocketControlMessageClass, CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GUnixCredentialsMessageClass:
  given _tag: Tag[_GUnixCredentialsMessageClass] = Tag.materializeCStruct3Tag[GSocketControlMessageClass, CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GUnixCredentialsMessageClass] = scala.scalanative.unsafe.alloc[_GUnixCredentialsMessageClass](1)
  def apply(parent_class : GSocketControlMessageClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit])(using Zone): Ptr[_GUnixCredentialsMessageClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    ____ptr
  extension (struct: _GUnixCredentialsMessageClass)
    def parent_class : GSocketControlMessageClass = struct._1
    def parent_class_=(value: GSocketControlMessageClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixcredentialsmessage.h
*/
opaque type _GUnixCredentialsMessagePrivate = CStruct0
object _GUnixCredentialsMessagePrivate:
  given _tag: Tag[_GUnixCredentialsMessagePrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixfdlist.h
*/
opaque type _GUnixFDList = CStruct2[_root_.gobject.GObject, Ptr[GUnixFDListPrivate]]
object _GUnixFDList:
  given _tag: Tag[_GUnixFDList] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, Ptr[GUnixFDListPrivate]]
  def apply()(using Zone): Ptr[_GUnixFDList] = scala.scalanative.unsafe.alloc[_GUnixFDList](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : Ptr[GUnixFDListPrivate])(using Zone): Ptr[_GUnixFDList] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GUnixFDList)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : Ptr[GUnixFDListPrivate] = struct._2
    def priv_=(value: Ptr[GUnixFDListPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixfdlist.h
*/
opaque type _GUnixFDListClass = CStruct6[_root_.gobject.GObjectClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GUnixFDListClass:
  given _tag: Tag[_GUnixFDListClass] = Tag.materializeCStruct6Tag[_root_.gobject.GObjectClass, CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GUnixFDListClass] = scala.scalanative.unsafe.alloc[_GUnixFDListClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit])(using Zone): Ptr[_GUnixFDListClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    ____ptr
  extension (struct: _GUnixFDListClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._2
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at2 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._3
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at3 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._4
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at4 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._5
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at5 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._6
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at6 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixfdlist.h
*/
opaque type _GUnixFDListPrivate = CStruct0
object _GUnixFDListPrivate:
  given _tag: Tag[_GUnixFDListPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixsocketaddress.h
*/
opaque type _GUnixSocketAddress = CStruct2[GSocketAddress, Ptr[GUnixSocketAddressPrivate]]
object _GUnixSocketAddress:
  given _tag: Tag[_GUnixSocketAddress] = Tag.materializeCStruct2Tag[GSocketAddress, Ptr[GUnixSocketAddressPrivate]]
  def apply()(using Zone): Ptr[_GUnixSocketAddress] = scala.scalanative.unsafe.alloc[_GUnixSocketAddress](1)
  def apply(parent_instance : GSocketAddress, priv : Ptr[GUnixSocketAddressPrivate])(using Zone): Ptr[_GUnixSocketAddress] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GUnixSocketAddress)
    def parent_instance : GSocketAddress = struct._1
    def parent_instance_=(value: GSocketAddress): Unit = !struct.at1 = value
    def priv : Ptr[GUnixSocketAddressPrivate] = struct._2
    def priv_=(value: Ptr[GUnixSocketAddressPrivate]): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixsocketaddress.h
*/
opaque type _GUnixSocketAddressClass = CStruct1[GSocketAddressClass]
object _GUnixSocketAddressClass:
  given _tag: Tag[_GUnixSocketAddressClass] = Tag.materializeCStruct1Tag[GSocketAddressClass]
  def apply()(using Zone): Ptr[_GUnixSocketAddressClass] = scala.scalanative.unsafe.alloc[_GUnixSocketAddressClass](1)
  def apply(parent_class : GSocketAddressClass)(using Zone): Ptr[_GUnixSocketAddressClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GUnixSocketAddressClass)
    def parent_class : GSocketAddressClass = struct._1
    def parent_class_=(value: GSocketAddressClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gunixsocketaddress.h
*/
opaque type _GUnixSocketAddressPrivate = CStruct0
object _GUnixSocketAddressPrivate:
  given _tag: Tag[_GUnixSocketAddressPrivate] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvfs.h
*/
opaque type _GVfs = CStruct1[_root_.gobject.GObject]
object _GVfs:
  given _tag: Tag[_GVfs] = Tag.materializeCStruct1Tag[_root_.gobject.GObject]
  def apply()(using Zone): Ptr[_GVfs] = scala.scalanative.unsafe.alloc[_GVfs](1)
  def apply(parent_instance : _root_.gobject.GObject)(using Zone): Ptr[_GVfs] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    ____ptr
  extension (struct: _GVfs)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvfs.h
*/
opaque type _GVfsClass = CStruct18[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean], CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]], CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit], CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit], CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr2[Ptr[GVfs], CString, Unit], CFuncPtr3[Ptr[GVfs], CString, CString, Unit], CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
object _GVfsClass:
  given _tag: Tag[_GVfsClass] = Tag.materializeCStruct18Tag[_root_.gobject.GObjectClass, CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean], CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]], CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit], CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit], CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr2[Ptr[GVfs], CString, Unit], CFuncPtr3[Ptr[GVfs], CString, CString, Unit], CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit], CFuncPtr0[Unit]]
  def apply()(using Zone): Ptr[_GVfsClass] = scala.scalanative.unsafe.alloc[_GVfsClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, is_active : CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean], get_file_for_path : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], get_file_for_uri : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], get_supported_uri_schemes : CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]], parse_name : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]], local_file_add_info : CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit], add_writable_namespaces : CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit], local_file_set_attributes : CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], local_file_removed : CFuncPtr2[Ptr[GVfs], CString, Unit], local_file_moved : CFuncPtr3[Ptr[GVfs], CString, CString, Unit], deserialize_icon : CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[_GVfsClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).is_active = is_active
    (!____ptr).get_file_for_path = get_file_for_path
    (!____ptr).get_file_for_uri = get_file_for_uri
    (!____ptr).get_supported_uri_schemes = get_supported_uri_schemes
    (!____ptr).parse_name = parse_name
    (!____ptr).local_file_add_info = local_file_add_info
    (!____ptr).add_writable_namespaces = add_writable_namespaces
    (!____ptr).local_file_set_attributes = local_file_set_attributes
    (!____ptr).local_file_removed = local_file_removed
    (!____ptr).local_file_moved = local_file_moved
    (!____ptr).deserialize_icon = deserialize_icon
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: _GVfsClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value
    def is_active : CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean] = struct._2
    def is_active_=(value: CFuncPtr1[Ptr[GVfs], _root_.glib.gboolean]): Unit = !struct.at2 = value
    def get_file_for_path : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]] = struct._3
    def get_file_for_path_=(value: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]): Unit = !struct.at3 = value
    def get_file_for_uri : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]] = struct._4
    def get_file_for_uri_=(value: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]): Unit = !struct.at4 = value
    def get_supported_uri_schemes : CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]] = struct._5
    def get_supported_uri_schemes_=(value: CFuncPtr1[Ptr[GVfs], Ptr[Ptr[_root_.glib.gchar]]]): Unit = !struct.at5 = value
    def parse_name : CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]] = struct._6
    def parse_name_=(value: CFuncPtr2[Ptr[GVfs], CString, Ptr[GFile]]): Unit = !struct.at6 = value
    def local_file_add_info : CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit] = struct._7
    def local_file_add_info_=(value: CFuncPtr8[Ptr[GVfs], CString, _root_.glib.guint64, Ptr[GFileAttributeMatcher], Ptr[GFileInfo], Ptr[GCancellable], Ptr[_root_.glib.gpointer], Ptr[_root_.glib.GDestroyNotify], Unit]): Unit = !struct.at7 = value
    def add_writable_namespaces : CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit] = struct._8
    def add_writable_namespaces_=(value: CFuncPtr2[Ptr[GVfs], Ptr[GFileAttributeInfoList], Unit]): Unit = !struct.at8 = value
    def local_file_set_attributes : CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._9
    def local_file_set_attributes_=(value: CFuncPtr6[Ptr[GVfs], CString, Ptr[GFileInfo], GFileQueryInfoFlags, Ptr[GCancellable], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at9 = value
    def local_file_removed : CFuncPtr2[Ptr[GVfs], CString, Unit] = struct._10
    def local_file_removed_=(value: CFuncPtr2[Ptr[GVfs], CString, Unit]): Unit = !struct.at10 = value
    def local_file_moved : CFuncPtr3[Ptr[GVfs], CString, CString, Unit] = struct._11
    def local_file_moved_=(value: CFuncPtr3[Ptr[GVfs], CString, CString, Unit]): Unit = !struct.at11 = value
    def deserialize_icon : CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]] = struct._12
    def deserialize_icon_=(value: CFuncPtr2[Ptr[GVfs], Ptr[_root_.glib.GVariant], Ptr[GIcon]]): Unit = !struct.at12 = value
    def _g_reserved1 : CFuncPtr0[Unit] = struct._13
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at13 = value
    def _g_reserved2 : CFuncPtr0[Unit] = struct._14
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at14 = value
    def _g_reserved3 : CFuncPtr0[Unit] = struct._15
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at15 = value
    def _g_reserved4 : CFuncPtr0[Unit] = struct._16
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at16 = value
    def _g_reserved5 : CFuncPtr0[Unit] = struct._17
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at17 = value
    def _g_reserved6 : CFuncPtr0[Unit] = struct._18
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at18 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GVolume = CStruct0
object _GVolume:
  given _tag: Tag[_GVolume] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvolume.h
*/
opaque type _GVolumeIface = CStruct22[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GVolume], Unit], CFuncPtr1[Ptr[GVolume], Unit], CFuncPtr1[Ptr[GVolume], CString], CFuncPtr1[Ptr[GVolume], Ptr[GIcon]], CFuncPtr1[Ptr[GVolume], CString], CFuncPtr1[Ptr[GVolume], Ptr[GDrive]], CFuncPtr1[Ptr[GVolume], Ptr[GMount]], CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr2[Ptr[GVolume], CString, CString], CFuncPtr1[Ptr[GVolume], Ptr[CString]], CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], CFuncPtr1[Ptr[GVolume], Ptr[GFile]], CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]]
object _GVolumeIface:
  given _tag: Tag[_GVolumeIface] = Tag.materializeCStruct22Tag[_root_.gobject.GTypeInterface, CFuncPtr1[Ptr[GVolume], Unit], CFuncPtr1[Ptr[GVolume], Unit], CFuncPtr1[Ptr[GVolume], CString], CFuncPtr1[Ptr[GVolume], Ptr[GIcon]], CFuncPtr1[Ptr[GVolume], CString], CFuncPtr1[Ptr[GVolume], Ptr[GDrive]], CFuncPtr1[Ptr[GVolume], Ptr[GMount]], CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr2[Ptr[GVolume], CString, CString], CFuncPtr1[Ptr[GVolume], Ptr[CString]], CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], CFuncPtr1[Ptr[GVolume], Ptr[GFile]], CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]], CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]]
  def apply()(using Zone): Ptr[_GVolumeIface] = scala.scalanative.unsafe.alloc[_GVolumeIface](1)
  def apply(g_iface : _root_.gobject.GTypeInterface, changed : CFuncPtr1[Ptr[GVolume], Unit], removed : CFuncPtr1[Ptr[GVolume], Unit], get_name : CFuncPtr1[Ptr[GVolume], CString], get_icon : CFuncPtr1[Ptr[GVolume], Ptr[GIcon]], get_uuid : CFuncPtr1[Ptr[GVolume], CString], get_drive : CFuncPtr1[Ptr[GVolume], Ptr[GDrive]], get_mount : CFuncPtr1[Ptr[GVolume], Ptr[GMount]], can_mount : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], can_eject : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], mount_fn : CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], mount_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], eject : CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_identifier : CFuncPtr2[Ptr[GVolume], CString, CString], enumerate_identifiers : CFuncPtr1[Ptr[GVolume], Ptr[CString]], should_automount : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean], get_activation_root : CFuncPtr1[Ptr[GVolume], Ptr[GFile]], eject_with_operation : CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit], eject_with_operation_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean], get_sort_key : CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]], get_symbolic_icon : CFuncPtr1[Ptr[GVolume], Ptr[GIcon]])(using Zone): Ptr[_GVolumeIface] = 
    val ____ptr = apply()
    (!____ptr).g_iface = g_iface
    (!____ptr).changed = changed
    (!____ptr).removed = removed
    (!____ptr).get_name = get_name
    (!____ptr).get_icon = get_icon
    (!____ptr).get_uuid = get_uuid
    (!____ptr).get_drive = get_drive
    (!____ptr).get_mount = get_mount
    (!____ptr).can_mount = can_mount
    (!____ptr).can_eject = can_eject
    (!____ptr).mount_fn = mount_fn
    (!____ptr).mount_finish = mount_finish
    (!____ptr).eject = eject
    (!____ptr).eject_finish = eject_finish
    (!____ptr).get_identifier = get_identifier
    (!____ptr).enumerate_identifiers = enumerate_identifiers
    (!____ptr).should_automount = should_automount
    (!____ptr).get_activation_root = get_activation_root
    (!____ptr).eject_with_operation = eject_with_operation
    (!____ptr).eject_with_operation_finish = eject_with_operation_finish
    (!____ptr).get_sort_key = get_sort_key
    (!____ptr).get_symbolic_icon = get_symbolic_icon
    ____ptr
  extension (struct: _GVolumeIface)
    def g_iface : _root_.gobject.GTypeInterface = struct._1
    def g_iface_=(value: _root_.gobject.GTypeInterface): Unit = !struct.at1 = value
    def changed : CFuncPtr1[Ptr[GVolume], Unit] = struct._2
    def changed_=(value: CFuncPtr1[Ptr[GVolume], Unit]): Unit = !struct.at2 = value
    def removed : CFuncPtr1[Ptr[GVolume], Unit] = struct._3
    def removed_=(value: CFuncPtr1[Ptr[GVolume], Unit]): Unit = !struct.at3 = value
    def get_name : CFuncPtr1[Ptr[GVolume], CString] = struct._4
    def get_name_=(value: CFuncPtr1[Ptr[GVolume], CString]): Unit = !struct.at4 = value
    def get_icon : CFuncPtr1[Ptr[GVolume], Ptr[GIcon]] = struct._5
    def get_icon_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]): Unit = !struct.at5 = value
    def get_uuid : CFuncPtr1[Ptr[GVolume], CString] = struct._6
    def get_uuid_=(value: CFuncPtr1[Ptr[GVolume], CString]): Unit = !struct.at6 = value
    def get_drive : CFuncPtr1[Ptr[GVolume], Ptr[GDrive]] = struct._7
    def get_drive_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GDrive]]): Unit = !struct.at7 = value
    def get_mount : CFuncPtr1[Ptr[GVolume], Ptr[GMount]] = struct._8
    def get_mount_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GMount]]): Unit = !struct.at8 = value
    def can_mount : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean] = struct._9
    def can_mount_=(value: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]): Unit = !struct.at9 = value
    def can_eject : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean] = struct._10
    def can_eject_=(value: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]): Unit = !struct.at10 = value
    def mount_fn : CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._11
    def mount_fn_=(value: CFuncPtr6[Ptr[GVolume], GMountMountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at11 = value
    def mount_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._12
    def mount_finish_=(value: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at12 = value
    def eject : CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._13
    def eject_=(value: CFuncPtr5[Ptr[GVolume], GMountUnmountFlags, Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at13 = value
    def eject_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._14
    def eject_finish_=(value: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at14 = value
    def get_identifier : CFuncPtr2[Ptr[GVolume], CString, CString] = struct._15
    def get_identifier_=(value: CFuncPtr2[Ptr[GVolume], CString, CString]): Unit = !struct.at15 = value
    def enumerate_identifiers : CFuncPtr1[Ptr[GVolume], Ptr[CString]] = struct._16
    def enumerate_identifiers_=(value: CFuncPtr1[Ptr[GVolume], Ptr[CString]]): Unit = !struct.at16 = value
    def should_automount : CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean] = struct._17
    def should_automount_=(value: CFuncPtr1[Ptr[GVolume], _root_.glib.gboolean]): Unit = !struct.at17 = value
    def get_activation_root : CFuncPtr1[Ptr[GVolume], Ptr[GFile]] = struct._18
    def get_activation_root_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GFile]]): Unit = !struct.at18 = value
    def eject_with_operation : CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit] = struct._19
    def eject_with_operation_=(value: CFuncPtr6[Ptr[GVolume], GMountUnmountFlags, Ptr[GMountOperation], Ptr[GCancellable], GAsyncReadyCallback, _root_.glib.gpointer, Unit]): Unit = !struct.at19 = value
    def eject_with_operation_finish : CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean] = struct._20
    def eject_with_operation_finish_=(value: CFuncPtr3[Ptr[GVolume], Ptr[GAsyncResult], Ptr[Ptr[_root_.glib.GError]], _root_.glib.gboolean]): Unit = !struct.at20 = value
    def get_sort_key : CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]] = struct._21
    def get_sort_key_=(value: CFuncPtr1[Ptr[GVolume], Ptr[_root_.glib.gchar]]): Unit = !struct.at21 = value
    def get_symbolic_icon : CFuncPtr1[Ptr[GVolume], Ptr[GIcon]] = struct._22
    def get_symbolic_icon_=(value: CFuncPtr1[Ptr[GVolume], Ptr[GIcon]]): Unit = !struct.at22 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvolumemonitor.h
*/
opaque type _GVolumeMonitor = CStruct2[_root_.gobject.GObject, _root_.glib.gpointer]
object _GVolumeMonitor:
  given _tag: Tag[_GVolumeMonitor] = Tag.materializeCStruct2Tag[_root_.gobject.GObject, _root_.glib.gpointer]
  def apply()(using Zone): Ptr[_GVolumeMonitor] = scala.scalanative.unsafe.alloc[_GVolumeMonitor](1)
  def apply(parent_instance : _root_.gobject.GObject, priv : _root_.glib.gpointer)(using Zone): Ptr[_GVolumeMonitor] = 
    val ____ptr = apply()
    (!____ptr).parent_instance = parent_instance
    (!____ptr).priv = priv
    ____ptr
  extension (struct: _GVolumeMonitor)
    def parent_instance : _root_.gobject.GObject = struct._1
    def parent_instance_=(value: _root_.gobject.GObject): Unit = !struct.at1 = value
    def priv : _root_.glib.gpointer = struct._2
    def priv_=(value: _root_.glib.gpointer): Unit = !struct.at2 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gvolumemonitor.h
*/
opaque type _GVolumeMonitorClass = CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]]
object _GVolumeMonitorClass:
  given _tag: Tag[_GVolumeMonitorClass] = Tag.CArray[CChar, Nat.Digit3[Nat._3, Nat._3, Nat._6]](Tag.Byte, Tag.Digit3[Nat._3, Nat._3, Nat._6](Tag.Nat3, Tag.Nat3, Tag.Nat6))
  def apply()(using Zone): Ptr[_GVolumeMonitorClass] = scala.scalanative.unsafe.alloc[_GVolumeMonitorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass, volume_added : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit], volume_removed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit], volume_changed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit], mount_added : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], mount_removed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], mount_pre_unmount : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], mount_changed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit], drive_connected : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], drive_disconnected : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], drive_changed : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], is_supported : CFuncPtr0[_root_.glib.gboolean], get_connected_drives : CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]], get_volumes : CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]], get_mounts : CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]], get_volume_for_uuid : CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]], get_mount_for_uuid : CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]], adopt_orphan_mount : CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]], drive_eject_button : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], drive_stop_button : CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit], _g_reserved1 : CFuncPtr0[Unit], _g_reserved2 : CFuncPtr0[Unit], _g_reserved3 : CFuncPtr0[Unit], _g_reserved4 : CFuncPtr0[Unit], _g_reserved5 : CFuncPtr0[Unit], _g_reserved6 : CFuncPtr0[Unit])(using Zone): Ptr[_GVolumeMonitorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    (!____ptr).volume_added = volume_added
    (!____ptr).volume_removed = volume_removed
    (!____ptr).volume_changed = volume_changed
    (!____ptr).mount_added = mount_added
    (!____ptr).mount_removed = mount_removed
    (!____ptr).mount_pre_unmount = mount_pre_unmount
    (!____ptr).mount_changed = mount_changed
    (!____ptr).drive_connected = drive_connected
    (!____ptr).drive_disconnected = drive_disconnected
    (!____ptr).drive_changed = drive_changed
    (!____ptr).is_supported = is_supported
    (!____ptr).get_connected_drives = get_connected_drives
    (!____ptr).get_volumes = get_volumes
    (!____ptr).get_mounts = get_mounts
    (!____ptr).get_volume_for_uuid = get_volume_for_uuid
    (!____ptr).get_mount_for_uuid = get_mount_for_uuid
    (!____ptr).adopt_orphan_mount = adopt_orphan_mount
    (!____ptr).drive_eject_button = drive_eject_button
    (!____ptr).drive_stop_button = drive_stop_button
    (!____ptr)._g_reserved1 = _g_reserved1
    (!____ptr)._g_reserved2 = _g_reserved2
    (!____ptr)._g_reserved3 = _g_reserved3
    (!____ptr)._g_reserved4 = _g_reserved4
    (!____ptr)._g_reserved5 = _g_reserved5
    (!____ptr)._g_reserved6 = _g_reserved6
    ____ptr
  extension (struct: _GVolumeMonitorClass)
    def parent_class: _root_.gobject.GObjectClass = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]]
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at(offsets(0)).asInstanceOf[Ptr[_root_.gobject.GObjectClass]] = value
    def volume_added: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit] = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]]
    def volume_added_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]): Unit = !struct.at(offsets(1)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]] = value
    def volume_removed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit] = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]]
    def volume_removed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]): Unit = !struct.at(offsets(2)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]] = value
    def volume_changed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit] = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]]
    def volume_changed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]): Unit = !struct.at(offsets(3)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]]] = value
    def mount_added: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_added_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(4)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def mount_removed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_removed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(5)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def mount_pre_unmount: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_pre_unmount_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(6)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def mount_changed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit] = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]]
    def mount_changed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]): Unit = !struct.at(offsets(7)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]]] = value
    def drive_connected: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_connected_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(8)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def drive_disconnected: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_disconnected_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(9)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def drive_changed: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_changed_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(10)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def is_supported: CFuncPtr0[_root_.glib.gboolean] = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[_root_.glib.gboolean]]]
    def is_supported_=(value: CFuncPtr0[_root_.glib.gboolean]): Unit = !struct.at(offsets(11)).asInstanceOf[Ptr[CFuncPtr0[_root_.glib.gboolean]]] = value
    def get_connected_drives: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]] = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]]
    def get_connected_drives_=(value: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(12)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]] = value
    def get_volumes: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]] = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]]
    def get_volumes_=(value: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(13)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]] = value
    def get_mounts: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]] = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]]
    def get_mounts_=(value: CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]): Unit = !struct.at(offsets(14)).asInstanceOf[Ptr[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]]] = value
    def get_volume_for_uuid: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]] = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]]]
    def get_volume_for_uuid_=(value: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]): Unit = !struct.at(offsets(15)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]]] = value
    def get_mount_for_uuid: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]] = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]]]
    def get_mount_for_uuid_=(value: CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]): Unit = !struct.at(offsets(16)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]]] = value
    def adopt_orphan_mount: CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]] = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]]]
    def adopt_orphan_mount_=(value: CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]): Unit = !struct.at(offsets(17)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]]] = value
    def drive_eject_button: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_eject_button_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(18)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def drive_stop_button: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit] = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]]
    def drive_stop_button_=(value: CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]): Unit = !struct.at(offsets(19)).asInstanceOf[Ptr[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]]] = value
    def _g_reserved1: CFuncPtr0[Unit] = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved1_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(20)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved2: CFuncPtr0[Unit] = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved2_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(21)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved3: CFuncPtr0[Unit] = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved3_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(22)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved4: CFuncPtr0[Unit] = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved4_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(23)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved5: CFuncPtr0[Unit] = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved5_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(24)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
    def _g_reserved6: CFuncPtr0[Unit] = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr0[Unit]]]
    def _g_reserved6_=(value: CFuncPtr0[Unit]): Unit = !struct.at(offsets(25)).asInstanceOf[Ptr[CFuncPtr0[Unit]]] = value
  val offsets: Array[Int] = 
    val res = Array.ofDim[Int](26)
    def align(offset: Int, alignment: Int) = {
      val alignmentMask = alignment - 1
      val padding =
        if ((offset & alignmentMask) == 0) 0
        else alignment - (offset & alignmentMask)
      offset + padding
    }
    
    res(0) = align(0, alignmentof[_root_.gobject.GObjectClass].toInt)
    res(1) = align(res(0) + sizeof[_root_.gobject.GObjectClass].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt)
    res(2) = align(res(1) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt)
    res(3) = align(res(2) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt)
    res(4) = align(res(3) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GVolume], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(5) = align(res(4) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(6) = align(res(5) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(7) = align(res(6) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt)
    res(8) = align(res(7) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GMount], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(9) = align(res(8) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(10) = align(res(9) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(11) = align(res(10) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr0[_root_.glib.gboolean]].toInt)
    res(12) = align(res(11) + sizeof[CFuncPtr0[_root_.glib.gboolean]].toInt, alignmentof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt)
    res(13) = align(res(12) + sizeof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt)
    res(14) = align(res(13) + sizeof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt)
    res(15) = align(res(14) + sizeof[CFuncPtr1[Ptr[GVolumeMonitor], Ptr[_root_.glib.GList]]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]].toInt)
    res(16) = align(res(15) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GVolume]]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]].toInt)
    res(17) = align(res(16) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], CString, Ptr[GMount]]].toInt, alignmentof[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]].toInt)
    res(18) = align(res(17) + sizeof[CFuncPtr2[Ptr[GMount], Ptr[GVolumeMonitor], Ptr[GVolume]]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(19) = align(res(18) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt)
    res(20) = align(res(19) + sizeof[CFuncPtr2[Ptr[GVolumeMonitor], Ptr[GDrive], Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(21) = align(res(20) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(22) = align(res(21) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(23) = align(res(22) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(24) = align(res(23) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res(25) = align(res(24) + sizeof[CFuncPtr0[Unit]].toInt, alignmentof[CFuncPtr0[Unit]].toInt)
    res
  end offsets

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GZlibCompressor = CStruct0
object _GZlibCompressor:
  given _tag: Tag[_GZlibCompressor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gzlibcompressor.h
*/
opaque type _GZlibCompressorClass = CStruct1[_root_.gobject.GObjectClass]
object _GZlibCompressorClass:
  given _tag: Tag[_GZlibCompressorClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GZlibCompressorClass] = scala.scalanative.unsafe.alloc[_GZlibCompressorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GZlibCompressorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GZlibCompressorClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/giotypes.h
*/
opaque type _GZlibDecompressor = CStruct0
object _GZlibDecompressor:
  given _tag: Tag[_GZlibDecompressor] = Tag.materializeCStruct0Tag

/**
 * [bindgen] header: /opt/homebrew/Cellar/glib/2.82.4/include/glib-2.0/gio/gzlibdecompressor.h
*/
opaque type _GZlibDecompressorClass = CStruct1[_root_.gobject.GObjectClass]
object _GZlibDecompressorClass:
  given _tag: Tag[_GZlibDecompressorClass] = Tag.materializeCStruct1Tag[_root_.gobject.GObjectClass]
  def apply()(using Zone): Ptr[_GZlibDecompressorClass] = scala.scalanative.unsafe.alloc[_GZlibDecompressorClass](1)
  def apply(parent_class : _root_.gobject.GObjectClass)(using Zone): Ptr[_GZlibDecompressorClass] = 
    val ____ptr = apply()
    (!____ptr).parent_class = parent_class
    ____ptr
  extension (struct: _GZlibDecompressorClass)
    def parent_class : _root_.gobject.GObjectClass = struct._1
    def parent_class_=(value: _root_.gobject.GObjectClass): Unit = !struct.at1 = value